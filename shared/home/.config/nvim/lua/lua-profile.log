SCRIPT  /usr/share/nvim/runtime/ftplugin/lua.vim
Sourced 3 times
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
                            " Vim filetype plugin file.
                            " Language:		Lua
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Previous Maintainer:	Max Ischenko <mfi@ukr.net>
                            " Contributor:		Dorai Sitaram <ds26@gte.com>
                            " Last Change:		2022 Sep 05
                            
    3              0.000010 if exists("b:did_ftplugin")
                              finish
    3              0.000001 endif
    3              0.000005 let b:did_ftplugin = 1
                            
    3              0.000009 let s:cpo_save = &cpo
    3              0.000021 set cpo&vim
                            
    3              0.000007 setlocal comments=:--
    3              0.000005 setlocal commentstring=--\ %s
    3              0.000009 setlocal formatoptions-=t formatoptions+=croql
                            
    3              0.000007 let &l:define = '\<function\|\<local\%(\s\+function\)\='
                            
    3              0.000005 setlocal suffixesadd=.lua
                            
    3              0.000004 let b:undo_ftplugin = "setlocal cms< com< def< fo< sua<"
                            
    3              0.000007 if exists("loaded_matchit") && !exists("b:match_words")
    3              0.000003   let b:match_ignorecase = 0
    3              0.000010   let b:match_words =
                            	\ '\<\%(do\|function\|if\)\>:' ..
                            	\ '\<\%(return\|else\|elseif\)\>:' ..
                            	\ '\<end\>,' ..
                            	\ '\<repeat\>:\<until\>,' ..
                            	\ '\%(--\)\=\[\(=*\)\[:]\1]'
    3              0.000006   let b:undo_ftplugin ..= " | unlet! b:match_words b:match_ignorecase"
    3              0.000001 endif
                            
    3              0.000012 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              let b:browsefilter = "Lua Source Files (*.lua)\t*.lua\n" ..
                            	\	       "All Files (*.*)\t*.*\n"
                              let b:undo_ftplugin ..= " | unlet! b:browsefilter"
    3              0.000001 endif
                            
    3              0.000015 let &cpo = s:cpo_save
    3              0.000003 unlet s:cpo_save
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet:

SCRIPT  /home/khaneliman/.local/share/nvim/site/pack/packer/opt/vim-matchup/after/ftplugin/lua_matchup.vim
Sourced 3 times
Total time:   0.000134
 Self time:   0.000107

count  total (s)   self (s)
                            " vim match-up - even better matching
                            "
                            " Maintainer: Andy Massimino
                            " Email:      a@normed.space
                            "
                            
    3              0.000013 if !exists('g:loaded_matchup') || !exists('b:did_ftplugin')
                              finish
    3              0.000001 endif
                            
    3              0.000009 let s:save_cpo = &cpo
    3              0.000013 set cpo&vim
                            
    3              0.000007 let b:match_midmap = [
                                  \ ['luaFunction', 'return'],
                                  \]
    3              0.000004 let b:undo_ftplugin .= '| unlet! b:match_midmap'
                            
    3   0.000051   0.000024 call matchup#util#append_match_words('--\[\(=*\)\[:]\1]')
                            
    3              0.000015 let &cpo = s:save_cpo
                            
                            " vim: fdm=marker sw=2
                            

SCRIPT  /usr/share/nvim/runtime/ftplugin/lua.lua
Sourced 3 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
                            if vim.g.ts_highlight_lua then
                              vim.treesitter.start()
                            end

SCRIPT  /usr/share/nvim/runtime/indent/lua.vim
Sourced 3 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Lua script
                            " Maintainer:	Marcus Aurelius Farias <marcus.cf 'at' bol.com.br>
                            " First Author:	Max Ischenko <mfi 'at' ukr.net>
                            " Last Change:	2017 Jun 13
                            "		2022 Sep 07: b:undo_indent added by Doug Kearns
                            
                            " Only load this indent file when no other was loaded.
    3              0.000008 if exists("b:did_indent")
                              finish
    3              0.000001 endif
    3              0.000004 let b:did_indent = 1
                            
    3              0.000009 setlocal indentexpr=GetLuaIndent()
                            
                            " To make Vim call GetLuaIndent() when it finds '\s*end' or '\s*until'
                            " on the current line ('else' is default and includes 'elseif').
    3              0.000006 setlocal indentkeys+=0=end,0=until
                            
    3              0.000011 setlocal autoindent
                            
    3              0.000006 let b:undo_indent = "setlocal autoindent< indentexpr< indentkeys<"
                            
                            " Only define the function once.
    3              0.000007 if exists("*GetLuaIndent")
    3              0.000002   finish
                            endif
                            
                            function! GetLuaIndent()
                              " Find a non-blank line above the current line.
                              let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
                              if prevlnum == 0
                                return 0
                              endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{'
                              let ind = indent(prevlnum)
                              let prevline = getline(prevlnum)
                              let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
                              if midx == -1
                                let midx = match(prevline, '{\s*$')
                                if midx == -1
                                  let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
                                endif
                              endif
                            
                              if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
                                if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
                                  let ind = ind + shiftwidth()
                                endif
                              endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until and '}'
                              " This is the part that requires 'indentkeys'.
                              let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\)')
                              if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction

SCRIPT  /usr/share/nvim/runtime/syntax/lua.vim
Sourced 3 times
Total time:   0.001576
 Self time:   0.001576

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Lua 4.0, Lua 5.0, Lua 5.1, Lua 5.2 and Lua 5.3
                            " Maintainer:   Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
                            " First Author: Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
                            " Last Change:  2022 Sep 07
                            " Options:      lua_version = 4 or 5
                            "               lua_subversion = 0 (for 4.0 or 5.0)
                            "                               or 1, 2, 3 (for 5.1, 5.2 or 5.3)
                            "               the default is 5.3
                            
                            " quit when a syntax file was already loaded
    3              0.000007 if exists("b:current_syntax")
                              finish
    3              0.000001 endif
                            
    3              0.000010 let s:cpo_save = &cpo
    3              0.000014 set cpo&vim
                            
    3              0.000004 if !exists("lua_version")
                              " Default is lua 5.3
                              let lua_version = 5
                              let lua_subversion = 3
    3              0.000004 elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. In this case set it to 0
                              let lua_subversion = 0
    3              0.000001 endif
                            
    3              0.000002 syn case match
                            
                            " syncing method
    3              0.000004 syn sync minlines=1000
                            
    3              0.000003 if lua_version >= 5
    3              0.000007   syn keyword luaMetaMethod __add __sub __mul __div __pow __unm __concat
    3              0.000003   syn keyword luaMetaMethod __eq __lt __le
    3              0.000003   syn keyword luaMetaMethod __index __newindex __call
    3              0.000004   syn keyword luaMetaMethod __metatable __mode __gc __tostring
    3              0.000001 endif
                            
    3              0.000005 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
    3              0.000002   syn keyword luaMetaMethod __mod __len
    3              0.000001 endif
                            
    3              0.000003 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    3              0.000002   syn keyword luaMetaMethod __pairs
    3              0.000001 endif
                            
    3              0.000003 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 3)
    3              0.000002   syn keyword luaMetaMethod __idiv __name
    3              0.000003   syn keyword luaMetaMethod __band __bor __bxor __bnot __shl __shr
    3              0.000001 endif
                            
    3              0.000003 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 4)
                              syn keyword luaMetaMethod __close
    3              0.000001 endif
                            
                            " catch errors caused by wrong parenthesis and wrong curly brackets or
                            " keywords placed outside their respective blocks
                            
    3              0.000017 syn region luaParen transparent start='(' end=')' contains=TOP,luaParenError
    3              0.000004 syn match  luaParenError ")"
    3              0.000004 syn match  luaError "}"
    3              0.000011 syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
                            
                            " Function declaration
    3              0.000016 syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=TOP
                            
                            " else
    3              0.000006 syn keyword luaCondElse matchgroup=luaCond contained containedin=luaCondEnd else
                            
                            " then ... end
    3              0.000013 syn region luaCondEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=TOP
                            
                            " elseif ... then
    3              0.000015 syn region luaCondElseif contained containedin=luaCondEnd transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=TOP
                            
                            " if ... then
    3              0.000012 syn region luaCondStart transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4 contains=TOP nextgroup=luaCondEnd skipwhite skipempty
                            
                            " do ... end
    3              0.000009 syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>" contains=TOP
                            " repeat ... until
    3              0.000010 syn region luaRepeatBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>" contains=TOP
                            
                            " while ... do
    3              0.000010 syn region luaWhile transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
                            " for ... do and for ... in ... do
    3              0.000011 syn region luaFor transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
    3              0.000004 syn keyword luaFor contained containedin=luaFor in
                            
                            " other keywords
    3              0.000003 syn keyword luaStatement return local break
    3              0.000004 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    3              0.000002   syn keyword luaStatement goto
    3              0.000007   syn match luaLabel "::\I\i*::"
    3              0.000001 endif
                            
                            " operators
    3              0.000003 syn keyword luaOperator and or not
                            
    3              0.000004 if (lua_version == 5 && lua_subversion >= 3) || lua_version > 5
    3              0.000010   syn match luaSymbolOperator "[#<>=~^&|*/%+-]\|\.\{2,3}"
                            elseif lua_version == 5 && (lua_subversion == 1 || lua_subversion == 2)
                              syn match luaSymbolOperator "[#<>=~^*/%+-]\|\.\{2,3}"
                            else
                              syn match luaSymbolOperator "[<>=~^*/+-]\|\.\{2,3}"
    3              0.000001 endif
                            
                            " comments
    3              0.000004 syn keyword luaTodo            contained TODO FIXME XXX
    3              0.000010 syn match   luaComment         "--.*$" contains=luaTodo,@Spell
    3              0.000007 if lua_version == 5 && lua_subversion == 0
                              syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
                              syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
    3              0.000004 elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
                              " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
    3              0.000013   syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
    3              0.000001 endif
                            
                            " first line may start with #!
    3              0.000005 syn match luaComment "\%^#!.*"
                            
    3              0.000003 syn keyword luaConstant nil
    3              0.000002 if lua_version > 4
    3              0.000009   syn keyword luaConstant true false
    3              0.000001 endif
                            
                            " strings
    3              0.000013 syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
    3              0.000002 if lua_version == 5
    3              0.000002   if lua_subversion == 0
                                syn region luaString2 matchgroup=luaStringDelimiter start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
    3              0.000001   else
    3              0.000002     if lua_subversion >= 2
    3              0.000009       syn match  luaSpecial contained #\\z\|\\x[[:xdigit:]]\{2}#
    3              0.000001     endif
    3              0.000002     if lua_subversion >= 3
    3              0.000009       syn match  luaSpecial contained #\\u{[[:xdigit:]]\+}#
    3              0.000001     endif
    3              0.000016     syn region luaString2 matchgroup=luaStringDelimiter start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
    3              0.000001   endif
    3              0.000001 endif
    3              0.000014 syn region luaString matchgroup=luaStringDelimiter start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
    3              0.000011 syn region luaString matchgroup=luaStringDelimiter start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
                            
                            " integer number
    3              0.000007 syn match luaNumber "\<\d\+\>"
                            " floating point number, with dot, optional exponent
    3              0.000011 syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\="
                            " floating point number, starting with a dot, optional exponent
    3              0.000010 syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, without dot, with exponent
    3              0.000005 syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
                            
                            " hex numbers
    3              0.000002 if lua_version >= 5
    3              0.000002   if lua_subversion == 1
                                syn match luaNumber "\<0[xX]\x\+\>"
    3              0.000002   elseif lua_subversion >= 2
    3              0.000009     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
    3              0.000001   endif
    3              0.000001 endif
                            
                            " tables
    3              0.000013 syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=TOP,luaStatement
                            
                            " methods
    3              0.000006 syntax match luaFunc ":\@<=\k\+"
                            
                            " built-in functions
    3              0.000010 syn keyword luaFunc assert collectgarbage dofile error next
    3              0.000007 syn keyword luaFunc print rawget rawset self tonumber tostring type _VERSION
                            
    3              0.000002 if lua_version == 4
                              syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
                              syn keyword luaFunc call copytagmethods dostring
                              syn keyword luaFunc foreach foreachi getglobal getn
                              syn keyword luaFunc gettagmethod globals newtag
                              syn keyword luaFunc setglobal settag settagmethod sort
                              syn keyword luaFunc tag tinsert tremove
                              syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
                              syn keyword luaFunc openfile closefile flush seek
                              syn keyword luaFunc setlocale execute remove rename tmpname
                              syn keyword luaFunc getenv date clock exit
                              syn keyword luaFunc readfrom writeto appendto read write
                              syn keyword luaFunc PI abs sin cos tan asin
                              syn keyword luaFunc acos atan atan2 ceil floor
                              syn keyword luaFunc mod frexp ldexp sqrt min max log
                              syn keyword luaFunc log10 exp deg rad random
                              syn keyword luaFunc randomseed strlen strsub strlower strupper
                              syn keyword luaFunc strchar strrep ascii strbyte
                              syn keyword luaFunc format strfind gsub
                              syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
    3              0.000002 elseif lua_version == 5
    3              0.000003   syn keyword luaFunc getmetatable setmetatable
    3              0.000002   syn keyword luaFunc ipairs pairs
    3              0.000002   syn keyword luaFunc pcall xpcall
    3              0.000003   syn keyword luaFunc _G loadfile rawequal require
    3              0.000002   if lua_subversion == 0
                                syn keyword luaFunc getfenv setfenv
                                syn keyword luaFunc loadstring unpack
                                syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
    3              0.000001   else
    3              0.000002     syn keyword luaFunc load select
    3              0.000006     syn match   luaFunc /\<package\.cpath\>/
    3              0.000005     syn match   luaFunc /\<package\.loaded\>/
    3              0.000005     syn match   luaFunc /\<package\.loadlib\>/
    3              0.000005     syn match   luaFunc /\<package\.path\>/
    3              0.000005     syn match   luaFunc /\<package\.preload\>/
    3              0.000002     if lua_subversion == 1
                                  syn keyword luaFunc getfenv setfenv
                                  syn keyword luaFunc loadstring module unpack
                                  syn match   luaFunc /\<package\.loaders\>/
                                  syn match   luaFunc /\<package\.seeall\>/
    3              0.000002     elseif lua_subversion >= 2
    3              0.000003       syn keyword luaFunc _ENV rawlen
    3              0.000004       syn match   luaFunc /\<package\.config\>/
    3              0.000004       syn match   luaFunc /\<package\.preload\>/
    3              0.000005       syn match   luaFunc /\<package\.searchers\>/
    3              0.000005       syn match   luaFunc /\<package\.searchpath\>/
    3              0.000001     endif
                            
    3              0.000002     if lua_subversion >= 3
    3              0.000006       syn match luaFunc /\<coroutine\.isyieldable\>/
    3              0.000001     endif
    3              0.000002     if lua_subversion >= 4
                                  syn keyword luaFunc warn
                                  syn match luaFunc /\<coroutine\.close\>/
    3              0.000001     endif
    3              0.000006     syn match luaFunc /\<coroutine\.running\>/
    3              0.000002   endif
    3              0.000006   syn match   luaFunc /\<coroutine\.create\>/
    3              0.000006   syn match   luaFunc /\<coroutine\.resume\>/
    3              0.000007   syn match   luaFunc /\<coroutine\.status\>/
    3              0.000005   syn match   luaFunc /\<coroutine\.wrap\>/
    3              0.000004   syn match   luaFunc /\<coroutine\.yield\>/
                            
    3              0.000004   syn match   luaFunc /\<string\.byte\>/
    3              0.000005   syn match   luaFunc /\<string\.char\>/
    3              0.000008   syn match   luaFunc /\<string\.dump\>/
    3              0.000005   syn match   luaFunc /\<string\.find\>/
    3              0.000005   syn match   luaFunc /\<string\.format\>/
    3              0.000004   syn match   luaFunc /\<string\.gsub\>/
    3              0.000007   syn match   luaFunc /\<string\.len\>/
    3              0.000004   syn match   luaFunc /\<string\.lower\>/
    3              0.000004   syn match   luaFunc /\<string\.rep\>/
    3              0.000004   syn match   luaFunc /\<string\.sub\>/
    3              0.000004   syn match   luaFunc /\<string\.upper\>/
    3              0.000002   if lua_subversion == 0
                                syn match luaFunc /\<string\.gfind\>/
    3              0.000001   else
    3              0.000005     syn match luaFunc /\<string\.gmatch\>/
    3              0.000004     syn match luaFunc /\<string\.match\>/
    3              0.000004     syn match luaFunc /\<string\.reverse\>/
    3              0.000001   endif
    3              0.000002   if lua_subversion >= 3
    3              0.000005     syn match luaFunc /\<string\.pack\>/
    3              0.000005     syn match luaFunc /\<string\.packsize\>/
    3              0.000005     syn match luaFunc /\<string\.unpack\>/
    3              0.000005     syn match luaFunc /\<utf8\.char\>/
    3              0.000005     syn match luaFunc /\<utf8\.charpattern\>/
    3              0.000004     syn match luaFunc /\<utf8\.codes\>/
    3              0.000004     syn match luaFunc /\<utf8\.codepoint\>/
    3              0.000004     syn match luaFunc /\<utf8\.len\>/
    3              0.000005     syn match luaFunc /\<utf8\.offset\>/
    3              0.000001   endif
                            
    3              0.000002   if lua_subversion == 0
                                syn match luaFunc /\<table\.getn\>/
                                syn match luaFunc /\<table\.setn\>/
                                syn match luaFunc /\<table\.foreach\>/
                                syn match luaFunc /\<table\.foreachi\>/
    3              0.000002   elseif lua_subversion == 1
                                syn match luaFunc /\<table\.maxn\>/
    3              0.000002   elseif lua_subversion >= 2
    3              0.000003     syn match luaFunc /\<table\.pack\>/
    3              0.000004     syn match luaFunc /\<table\.unpack\>/
    3              0.000002     if lua_subversion >= 3
    3              0.000005       syn match luaFunc /\<table\.move\>/
    3              0.000001     endif
    3              0.000001   endif
    3              0.000004   syn match   luaFunc /\<table\.concat\>/
    3              0.000004   syn match   luaFunc /\<table\.insert\>/
    3              0.000004   syn match   luaFunc /\<table\.sort\>/
    3              0.000004   syn match   luaFunc /\<table\.remove\>/
                            
    3              0.000002   if lua_subversion == 2
                                syn match   luaFunc /\<bit32\.arshift\>/
                                syn match   luaFunc /\<bit32\.band\>/
                                syn match   luaFunc /\<bit32\.bnot\>/
                                syn match   luaFunc /\<bit32\.bor\>/
                                syn match   luaFunc /\<bit32\.btest\>/
                                syn match   luaFunc /\<bit32\.bxor\>/
                                syn match   luaFunc /\<bit32\.extract\>/
                                syn match   luaFunc /\<bit32\.lrotate\>/
                                syn match   luaFunc /\<bit32\.lshift\>/
                                syn match   luaFunc /\<bit32\.replace\>/
                                syn match   luaFunc /\<bit32\.rrotate\>/
                                syn match   luaFunc /\<bit32\.rshift\>/
    3              0.000001   endif
                            
    3              0.000004   syn match   luaFunc /\<math\.abs\>/
    3              0.000004   syn match   luaFunc /\<math\.acos\>/
    3              0.000004   syn match   luaFunc /\<math\.asin\>/
    3              0.000004   syn match   luaFunc /\<math\.atan\>/
    3              0.000002   if lua_subversion < 3
                                syn match   luaFunc /\<math\.atan2\>/
    3              0.000001   endif
    3              0.000014   syn match   luaFunc /\<math\.ceil\>/
    3              0.000005   syn match   luaFunc /\<math\.sin\>/
    3              0.000004   syn match   luaFunc /\<math\.cos\>/
    3              0.000004   syn match   luaFunc /\<math\.tan\>/
    3              0.000003   syn match   luaFunc /\<math\.deg\>/
    3              0.000004   syn match   luaFunc /\<math\.exp\>/
    3              0.000004   syn match   luaFunc /\<math\.floor\>/
    3              0.000004   syn match   luaFunc /\<math\.log\>/
    3              0.000004   syn match   luaFunc /\<math\.max\>/
    3              0.000004   syn match   luaFunc /\<math\.min\>/
    3              0.000002   if lua_subversion == 0
                                syn match luaFunc /\<math\.mod\>/
                                syn match luaFunc /\<math\.log10\>/
    3              0.000002   elseif lua_subversion == 1
                                syn match luaFunc /\<math\.log10\>/
    3              0.000001   endif
    3              0.000002   if lua_subversion >= 1
    3              0.000004     syn match luaFunc /\<math\.huge\>/
    3              0.000004     syn match luaFunc /\<math\.fmod\>/
    3              0.000004     syn match luaFunc /\<math\.modf\>/
    3              0.000003     if lua_subversion == 1 || lua_subversion == 2
                                  syn match luaFunc /\<math\.cosh\>/
                                  syn match luaFunc /\<math\.sinh\>/
                                  syn match luaFunc /\<math\.tanh\>/
    3              0.000001     endif
    3              0.000001   endif
    3              0.000004   syn match   luaFunc /\<math\.rad\>/
    3              0.000004   syn match   luaFunc /\<math\.sqrt\>/
    3              0.000002   if lua_subversion < 3
                                syn match   luaFunc /\<math\.pow\>/
                                syn match   luaFunc /\<math\.frexp\>/
                                syn match   luaFunc /\<math\.ldexp\>/
    3              0.000001   else
    3              0.000005     syn match   luaFunc /\<math\.maxinteger\>/
    3              0.000005     syn match   luaFunc /\<math\.mininteger\>/
    3              0.000004     syn match   luaFunc /\<math\.tointeger\>/
    3              0.000004     syn match   luaFunc /\<math\.type\>/
    3              0.000004     syn match   luaFunc /\<math\.ult\>/
    3              0.000001   endif
    3              0.000004   syn match   luaFunc /\<math\.random\>/
    3              0.000005   syn match   luaFunc /\<math\.randomseed\>/
    3              0.000004   syn match   luaFunc /\<math\.pi\>/
                            
    3              0.000004   syn match   luaFunc /\<io\.close\>/
    3              0.000004   syn match   luaFunc /\<io\.flush\>/
    3              0.000004   syn match   luaFunc /\<io\.input\>/
    3              0.000004   syn match   luaFunc /\<io\.lines\>/
    3              0.000004   syn match   luaFunc /\<io\.open\>/
    3              0.000005   syn match   luaFunc /\<io\.output\>/
    3              0.000004   syn match   luaFunc /\<io\.popen\>/
    3              0.000004   syn match   luaFunc /\<io\.read\>/
    3              0.000004   syn match   luaFunc /\<io\.stderr\>/
    3              0.000004   syn match   luaFunc /\<io\.stdin\>/
    3              0.000004   syn match   luaFunc /\<io\.stdout\>/
    3              0.000004   syn match   luaFunc /\<io\.tmpfile\>/
    3              0.000004   syn match   luaFunc /\<io\.type\>/
    3              0.000004   syn match   luaFunc /\<io\.write\>/
                            
    3              0.000004   syn match   luaFunc /\<os\.clock\>/
    3              0.000004   syn match   luaFunc /\<os\.date\>/
    3              0.000005   syn match   luaFunc /\<os\.difftime\>/
    3              0.000004   syn match   luaFunc /\<os\.execute\>/
    3              0.000004   syn match   luaFunc /\<os\.exit\>/
    3              0.000004   syn match   luaFunc /\<os\.getenv\>/
    3              0.000004   syn match   luaFunc /\<os\.remove\>/
    3              0.000004   syn match   luaFunc /\<os\.rename\>/
    3              0.000005   syn match   luaFunc /\<os\.setlocale\>/
    3              0.000004   syn match   luaFunc /\<os\.time\>/
    3              0.000004   syn match   luaFunc /\<os\.tmpname\>/
                            
    3              0.000017   syn match   luaFunc /\<debug\.debug\>/
    3              0.000005   syn match   luaFunc /\<debug\.gethook\>/
    3              0.000006   syn match   luaFunc /\<debug\.getinfo\>/
    3              0.000004   syn match   luaFunc /\<debug\.getlocal\>/
    3              0.000004   syn match   luaFunc /\<debug\.getupvalue\>/
    3              0.000004   syn match   luaFunc /\<debug\.setlocal\>/
    3              0.000005   syn match   luaFunc /\<debug\.setupvalue\>/
    3              0.000004   syn match   luaFunc /\<debug\.sethook\>/
    3              0.000005   syn match   luaFunc /\<debug\.traceback\>/
    3              0.000002   if lua_subversion == 1
                                syn match luaFunc /\<debug\.getfenv\>/
                                syn match luaFunc /\<debug\.setfenv\>/
    3              0.000001   endif
    3              0.000002   if lua_subversion >= 1
    3              0.000005     syn match luaFunc /\<debug\.getmetatable\>/
    3              0.000005     syn match luaFunc /\<debug\.setmetatable\>/
    3              0.000005     syn match luaFunc /\<debug\.getregistry\>/
    3              0.000002     if lua_subversion >= 2
    3              0.000005       syn match luaFunc /\<debug\.getuservalue\>/
    3              0.000005       syn match luaFunc /\<debug\.setuservalue\>/
    3              0.000005       syn match luaFunc /\<debug\.upvalueid\>/
    3              0.000006       syn match luaFunc /\<debug\.upvaluejoin\>/
    3              0.000001     endif
    3              0.000002     if lua_subversion >= 4
                                  syn match luaFunc /\<debug.setcstacklimit\>/
    3              0.000001     endif
    3              0.000001   endif
    3              0.000001 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    3              0.000005 hi def link luaStatement        Statement
    3              0.000003 hi def link luaRepeat           Repeat
    3              0.000002 hi def link luaFor              Repeat
    3              0.000002 hi def link luaString           String
    3              0.000002 hi def link luaString2          String
    3              0.000002 hi def link luaStringDelimiter  luaString
    3              0.000002 hi def link luaNumber           Number
    3              0.000002 hi def link luaOperator         Operator
    3              0.000002 hi def link luaSymbolOperator   luaOperator
    3              0.000002 hi def link luaConstant         Constant
    3              0.000002 hi def link luaCond             Conditional
    3              0.000002 hi def link luaCondElse         Conditional
    3              0.000002 hi def link luaFunction         Function
    3              0.000002 hi def link luaMetaMethod       Function
    3              0.000002 hi def link luaComment          Comment
    3              0.000002 hi def link luaCommentDelimiter luaComment
    3              0.000002 hi def link luaTodo             Todo
    3              0.000002 hi def link luaTable            Structure
    3              0.000002 hi def link luaError            Error
    3              0.000002 hi def link luaParenError       Error
    3              0.000002 hi def link luaSpecial          SpecialChar
    3              0.000002 hi def link luaFunc             Identifier
    3              0.000002 hi def link luaLabel            Label
                            
                            
    3              0.000004 let b:current_syntax = "lua"
                            
    3              0.000018 let &cpo = s:cpo_save
    3              0.000003 unlet s:cpo_save
                            " vim: et ts=8 sw=2

SCRIPT  /home/khaneliman/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/quirks.vim
Sourced 1 time
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
                            " vim match-up - even better matching
                            "
                            " Maintainer: Andy Massimino
                            " Email:      a@normed.space
                            "
                            
    1              0.000009 let s:save_cpo = &cpo
    1              0.000011 set cpo&vim
                            
    1              0.000004 function! s:ftcheck(fts) abort " {{{1
                              let l:ft = get(split(&filetype, '\.'), 0, '')
                              return index(a:fts, l:ft) > -1
                            endfunction
                            
                            " }}}1
    1              0.000002 function! matchup#quirks#isclike() abort " {{{1
                              return s:ftcheck(s:clikeft)
                            endfunction
                            
    1              0.000008 let s:clikeft = [
                                  \ 'arduino', 'c', 'cpp', 'cuda', 'ld', 'php', 'go',
                                  \ 'javascript', 'typescript',
                                  \ 'javascriptreact', 'typescriptreact',
                                  \]
                            
                            " }}}1
    1              0.000002 function! matchup#quirks#ishtmllike() abort " {{{1
                              return s:ftcheck(s:htmllikeft)
                            endfunction
                            
    1              0.000012 let s:htmllikeft = [
                                \ 'tidy', 'php', 'liquid', 'haml', 'tt2html',
                                \ 'html', 'xhtml', 'xml', 'jsp', 'htmldjango',
                                \ 'aspvbs', 'rmd', 'markdown', 'eruby', 'vue',
                                \ 'javascriptreact', 'typescriptreact', 'svelte'
                                \]
                            
                            " }}}1
                            
    1              0.000003 function! matchup#quirks#status_adjust(offscreen) abort " {{{1
                              if a:offscreen.match ==# '{' && matchup#quirks#isclike()
                                let [l:a, l:b] = [indent(a:offscreen.lnum),
                                      \ indent(a:offscreen.links.close.lnum)]
                                if strpart(getline(a:offscreen.lnum),
                                      \            0, a:offscreen.cnum-1) =~# '^\s*$'
                                  let l:target = l:a
                                elseif l:a != l:b
                                  let l:target = l:b
                                else
                                  return 0
                                endif
                                " go up to next line with same indent (up to s:adjust_max)
                                for l:adjust in range(-1, -s:adjust_max, -1)
                                  let l:lnum = a:offscreen.lnum + l:adjust
                                  if getline(l:lnum) =~? '^\s*$'
                                    break
                                  endif
                                  if indent(l:lnum) == l:target
                                        \ && getline(l:lnum) !~? '^\s*\%(#\|/\*\|//\)'
                                    return l:adjust
                                  endif
                                endfor
                              endif
                            
                              return 0
                            endfunction
                            
    1              0.000002 let s:adjust_max = 9
                            
                            " }}}1
                            
    1              0.000010 let &cpo = s:save_cpo
                            
                            " vim: fdm=marker sw=2

SCRIPT  /home/khaneliman/.config/nvim/lua/plugins/plugin-manager.lua
Sourced 1 time
Total time:   0.000427
 Self time:   0.000427

count  total (s)   self (s)
                            local utils = require("utils")
                            
                            vim.cmd([[
                              augroup packer_user_config
                                autocmd!
                                autocmd BufWritePost plugin-manager.lua source <afile> | PackerCompile
                              augroup end
                            ]])
                            
                            local fn = vim.fn
                            local install_path = fn.stdpath('data') .. '/site/pack/packer/start/packer.nvim'
                            if fn.empty(fn.glob(install_path)) > 0 then
                              packer_bootstrap = fn.system({ 'git', 'clone', '--depth', '1', 'https://github.com/wbthomason/packer.nvim',
                                install_path })
                              vim.cmd [[packadd packer.nvim]]
                            end
                            
                            function load_plugin_config(name)
                              local status, err = pcall(require, 'plugins.configs.' .. name)
                              if (not status) then
                                print("WARN: Unable to load plugin " .. name .. ".")
                                print(err)
                                return
                              end
                            end
                            
                            return require('packer').startup({
                              function(use)
                                -- Packer can manage itself
                                use { 'wbthomason/packer.nvim' }
                                use { 'folke/which-key.nvim', config = [[load_plugin_config'which-key']] }
                            
                                -- Themes
                                use { 'catppuccin/nvim', as = 'catppuccin', config = [[load_plugin_config'catppuccin']] }
                                use { "kyazdani42/nvim-web-devicons", event = "VimEnter" }
                            
                                -- Components
                                use { 'famiu/bufdelete.nvim' }
                                use { 'akinsho/bufferline.nvim', tag = '*', requires = { 'kyazdani42/nvim-web-devicons' },
                                  config = [[load_plugin_config('bufferline')]] }
                                use { 'kyazdani42/nvim-tree.lua', requires = { 'kyazdani42/nvim-web-devicons' },
                                  config = [[load_plugin_config'nvim-tree']] }
                                use { 'feline-nvim/feline.nvim', config = [[load_plugin_config'feline']] }
                                use { 'nvim-telescope/telescope.nvim', requires = { 'nvim-lua/plenary.nvim' },
                                  config = [[load_plugin_config'telescope']] }
                                use { "nvim-telescope/telescope-symbols.nvim", after = "telescope.nvim" }
                                use { "glepnir/dashboard-nvim", event = "VimEnter",
                                  cond = firenvim_not_active,
                                  config = [[load_plugin_config'dashboard-nvim']]
                                }
                                use { "Yggdroot/LeaderF", cmd = "Leaderf", run = ":LeaderfInstallCExtension" }
                                use { "ahmedkhalf/project.nvim", config = [[load_plugin_config'project_nvim']] }
                                use { "tpope/vim-obsession", cmd = "Obsession" }
                                use { "gelguy/wilder.nvim", config = [[load_plugin_config'wilder']] }
                            
                                if utils.executable("tmux") then
                                  -- .tmux.conf syntax highlighting and setting check
                                  use { "tmux-plugins/vim-tmux", ft = { "tmux" } }
                                end
                            
                                -- Code
                                use { 'nvim-treesitter/nvim-treesitter',
                                  run = function() require('nvim-treesitter.install').update({ with_sync = true }) end,
                                  config = [[load_plugin_config'nvim-treesitter']] }
                                use { 'lukas-reineke/indent-blankline.nvim', config = [[load_plugin_config'indent-blankline']] }
                                use { 'windwp/nvim-autopairs', config = [[load_plugin_config'nvim-autopairs']] }
                                use { 'terrortylor/nvim-comment', config = [[load_plugin_config'nvim-comment']] }
                                use {
                                  "ThePrimeagen/refactoring.nvim",
                                  requires = {
                                    { "nvim-lua/plenary.nvim" },
                                    { "nvim-treesitter/nvim-treesitter" }
                                  }
                                }
                                use { "godlygeek/tabular", cmd = { "Tabularize" } }
                                use { "machakann/vim-sandwich", event = "VimEnter" }
                                use { "andymass/vim-matchup", event = "VimEnter" }
                            
                                -- Snippet
                                use { 'L3MON4D3/LuaSnip', config = [[load_plugin_config'luasnip']] }
                                use { 'rafamadriz/friendly-snippets' }
                            
                                -- Autocomplete
                                use { 'hrsh7th/nvim-cmp', config = [[load_plugin_config'nvim-cmp']] }
                                use { 'hrsh7th/cmp-buffer' }
                                use { 'hrsh7th/cmp-path' }
                                use { 'hrsh7th/cmp-nvim-lsp' }
                                use { "hrsh7th/cmp-omni" }
                                use { 'hrsh7th/cmp-calc' }
                                use { 'saadparwaiz1/cmp_luasnip' }
                                use { 'onsails/lspkind.nvim' }
                                use { 'uga-rosa/cmp-dictionary' }
                                use { 'f3fora/cmp-spell' }
                            
                                -- LSP
                                use { 'neovim/nvim-lspconfig', config = [[load_plugin_config'.lsp']], wants = { "nvim-lsp-installer" },
                                  requires = { 'williamboman/nvim-lsp-installer' } }
                                use { 'williamboman/mason.nvim', config = [[load_plugin_config'mason']] }
                                use { 'williamboman/mason-lspconfig.nvim', config = [[load_plugin_config'mason-lspconfig']] }
                                use { "j-hui/fidget.nvim", after = "nvim-lspconfig", config = [[load_plugin_config'fidget-nvim']] }
                                use { "42wim/vim-shfmt" }
                                use "lukas-reineke/lsp-format.nvim"
                            
                                -- Git
                                use { 'lewis6991/gitsigns.nvim', config = [[load_plugin_config'gitsigns']] }
                                use { 'tpope/vim-fugitive', config = [[load_plugin_config'fugitive']] }
                                use { "rbong/vim-flog", requires = "tpope/vim-fugitive", cmd = { "Flog" } }
                                use { "christoomey/vim-conflicted", requires = "tpope/vim-fugitive", cmd = { "Conflicted" } }
                                use { "ruifm/gitlinker.nvim", requires = "nvim-lua/plenary.nvim", config = [[load_plugin_config('git-linker')]] }
                            
                                -- Usability
                                use { 'Pocco81/auto-save.nvim', config = [[load_plugin_config'auto-save']] }
                                use 'lambdalisue/suda.vim'
                                use { "nvim-zh/better-escape.vim", event = { "InsertEnter" } }
                                use { "kevinhwang91/nvim-bqf", ft = "qf", config = [[load_plugin_config'bqf']] }
                                use { "skywind3000/asyncrun.vim", opt = true, cmd = { "AsyncRun" } }
                                use { "romgrk/fzy-lua-native" }
                            
                                -- Analytics
                                use 'wakatime/vim-wakatime'
                            
                                -- Automatically set up your configuration after cloning packer.nvim
                                if packer_bootstrap then
                                  require('packer').sync()
                                end
                              end,
                            
                              config = {
                                auto_reload_compiled = false, -- Automatically reload the compiled file after creating it.
                                display = {
                                  open_fn = function()
                                    return require('packer.util').float({ border = 'single' })
                                  end
                                }
                              }
                            })
                            
                            -- run bootstrap: nvim --headless -c 'autocmd User PackerComplete quitall' -c 'PackerSync'

SCRIPT  /home/khaneliman/.local/share/nvim/site/pack/packer/opt/better-escape.vim/plugin/better_escape.vim
Sourced 1 time
Total time:   0.002479
 Self time:   0.000241

count  total (s)   self (s)
    1              0.000015 if !has('patch-7.4.1730')
                              call better_escape#log('patch-7.4.1730 must exist for this plugin to work!', 'err')
                              finish
    1              0.000001 endif
                            
    1              0.000006 if &compatible || exists('g:loaded_better_escape')
                              finish
    1              0.000001 endif
                            
    1              0.000005 let g:loaded_better_escape = 1
                            
    1              0.000005 let g:better_escape_interval = get(g:, "better_escape_interval", 150)
                            
    1              0.000005 let g:better_escape_shortcut = get(g:, "better_escape_shortcut", ['jk',])
                            
    1              0.000004 if type(g:better_escape_shortcut) == v:t_string
                              let g:better_escape_shortcut = [g:better_escape_shortcut, ]
    1              0.000003 elseif type(g:better_escape_shortcut) != v:t_list
                              call better_escape#log('Option g:better_escape_shortcut must be a string or list.', 'err')
                              finish
    1              0.000001 endif
                            
                            " We should check the validity of option given by user.
    2              0.000005 for shortcut in g:better_escape_shortcut
    1              0.000003   if strchars(shortcut) != 2
                                call better_escape#log('Only two-character shortcuts are supported! '
                                      \ . 'Make sure that all your shortcuts are made of two characters', 'err')
                                finish
    1              0.000001   endif
    2              0.000002 endfor
                            
    1              0.000004 let g:better_escape_debug = get(g:, "better_escape_debug", 0)
                            
    1              0.000005 function! s:get_initial_char() abort
                              let initial_chars = []
                              for l:shortcut in g:better_escape_shortcut
                                let l:ch = better_escape#CharAtIdx(l:shortcut, 0)
                                let initial_chars += [l:ch]
                              endfor
                            
                              return initial_chars
                            endfunction
                            
                            " The first character in each shortcut
    1   0.002204   0.000012 let g:better_escape_shortcut_initials = s:get_initial_char()
                            
                            " The time when the first char is pressed in each shortcut
    1              0.000004 let g:better_escape_initial_press_time = {}
    2              0.000003 for ch in g:better_escape_shortcut_initials
    1              0.000004   let g:better_escape_initial_press_time[ch] = []
    2              0.000002 endfor
                            
    1              0.000005 augroup ins_char
    1              0.000045   autocmd!
    1              0.000006   autocmd InsertCharPre * call better_escape#LogKeyPressTime()
    1              0.000001 augroup END
                            
    1              0.000003 function! s:get_shortcut_keymap() abort
                              let key_map = {}
                              for l:shortcut in g:better_escape_shortcut
                                let l:ch1 = better_escape#CharAtIdx(l:shortcut, 0)
                                let l:ch2 = better_escape#CharAtIdx(l:shortcut, 1)
                                if has_key(key_map, l:ch2)
                                  let key_map[l:ch2] += [l:ch1]
                                else
                                  let key_map[l:ch2] = [l:ch1]
                                endif
                              endfor
                            
                              return key_map
                            endfunction
                            
    1   0.000055   0.000008 let s:shortcut_map = s:get_shortcut_keymap()
                            
    2              0.000005 for k in keys(s:shortcut_map)
    1              0.000003   let first_chars = s:shortcut_map[k]
    1              0.000014   execute printf('inoremap <expr> %s better_escape#EscapeInsertOrNot(%s, "%s")', k, first_chars, k)
    2              0.000003 endfor

SCRIPT  /home/khaneliman/.local/share/nvim/site/pack/packer/opt/better-escape.vim/autoload/better_escape.vim
Sourced 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000006 function! better_escape#EscapeInsertOrNot(prefix, ch2) abort
                              " prefix is a list of chars that corresponds to ch2 in all the shortcuts.
                              let cur_ch_idx = better_escape#CursorCharIdx()
                              let pre_char = better_escape#CharAtIdx(getline('.'), cur_ch_idx-1)
                            
                              " If we can not find pre_char in prefix, we do not want to escape insert.
                              if index(a:prefix, pre_char) == -1
                                return a:ch2
                              endif
                            
                              let l:ret_ch = a:ch2
                            
                              let l:ch1_press_time = g:better_escape_initial_press_time[pre_char]
                              if l:ch1_press_time != []
                                  " time interval in milliseconds between last time you press `ch1` in insert
                                  " mode and the time you press `ch2` now
                                  let l:time_interval = reltimefloat(reltime(l:ch1_press_time)) * 1000
                                  if g:better_escape_debug == 1
                                    call better_escape#log(printf('Time interval between pressing %s and %s: %.2f ms', pre_char, a:ch2, l:time_interval), 'msg')
                                  endif
                            
                                  if l:time_interval < g:better_escape_interval
                                    let l:ret_ch = "\b\e"
                                  endif
                              endif
                            
                              return l:ret_ch
                            endfunction
                            
    1              0.000002 function! better_escape#CursorCharIdx() abort
                              " A more concise way to get character index under cursor.
                              let cursor_byte_idx = col('.')
                              if cursor_byte_idx == 1
                                return 0
                              endif
                            
                              let pre_cursor_text = getline('.')[:col('.')-2]
                              return strchars(pre_cursor_text)
                            endfunction
                            
    1              0.000002 function! better_escape#CharAtIdx(str, idx) abort
                              " Get char at idx from str. Note that this is based on character index
                              " instead of the byte index.
                              return strcharpart(a:str, a:idx, 1)
                            endfunction
                            
    1              0.000002 function! better_escape#log(msg, level) abort
                              if a:level ==# 'err'
                                echohl ErrorMsg
                              endif
                              echomsg '[Better-escape] ' . a:msg
                              if a:level ==# 'err'
                                echohl None
                              endif
                            endfunction
                            
    1              0.000001 function! better_escape#LogKeyPressTime() abort
                              if g:better_escape_debug == 1
                                call better_escape#log(printf('Key %s pressed at %s', v:char, reltime()), 'msg')
                              endif
                              if has_key(g:better_escape_initial_press_time, v:char)
                                let g:better_escape_initial_press_time[v:char] = reltime()
                              endif
                            endfunction

FUNCTION  <SNR>53_empty_message()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/component/popupmenu_empty_message.vim:22
Called 3 times
Total time:   0.000412
 Self time:   0.000131

count  total (s)   self (s)
    3              0.000004   let l:min_width = a:ctx.min_width
    3              0.000003   let l:max_width = a:ctx.max_width
    3              0.000003   let l:min_height = a:ctx.min_height
                            
    3              0.000003   let l:hl = a:ctx.highlights.empty_message
                            
    3   0.000255   0.000011   let l:message = a:state.message(a:ctx, a:result)
    3              0.000004   if type(l:message) is v:t_string
                                let l:chunks = [[l:message, l:hl]]
    3              0.000001   else
    3              0.000002     let l:chunks = l:message
    3              0.000001   endif
                            
    3   0.000051   0.000013   let l:remaining_width = l:min_width - wilder#render#chunks_displaywidth(l:chunks)
                            
    3              0.000002   if l:remaining_width > 0
    3              0.000008     if a:state.horizontal ==# 'middle'
    3              0.000010       let l:chunks = [[repeat(' ', l:remaining_width / 2), l:hl]] + l:chunks
    3              0.000008       let l:chunks += [[repeat(' ', (l:remaining_width + 1) / 2), l:hl]]
                                elseif a:state.horizontal ==# 'left'
                                  let l:chunks += [[repeat(' ', l:remaining_width), l:hl]]
                                else
                                  " right
                                  let l:chunks = [[repeat(' ', l:remaining_width), l:hl]] + l:chunks
    3              0.000001     endif
    3              0.000001   endif
                            
    3              0.000003   let l:rows = [l:chunks]
                            
    3              0.000002   if l:min_height > 1
                                " + 1 for the added space.
                                let l:width = wilder#render#chunks_displaywidth(l:chunks)
                                let l:padding_rows = [[repeat(' ', l:width), l:hl]]
                                let l:min_height_rows = repeat([l:padding_rows], l:min_height - 1)
                            
                                if a:state.vertical ==# 'middle'
                                  let l:rows = repeat([l:padding_rows], (l:min_height - 1) / 2) + l:rows
                                  let l:rows += repeat([l:padding_rows], l:min_height / 2)
                                elseif a:state.vertical ==# 'bottom'
                                  let l:rows = repeat([l:padding_rows], l:min_height - 1) + l:rows
                                else
                                  " bottom
                                  let l:rows += repeat([l:padding_rows], l:min_height - 1)
                                endif
    3              0.000001   endif
                            
    3              0.000002   return l:rows

FUNCTION  better_escape#LogKeyPressTime()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/better-escape.vim/autoload/better_escape.vim:57
Called 124 times
Total time:   0.002148
 Self time:   0.002148

count  total (s)   self (s)
  124              0.000520   if g:better_escape_debug == 1
                                call better_escape#log(printf('Key %s pressed at %s', v:char, reltime()), 'msg')
  124              0.000109   endif
  124              0.000415   if has_key(g:better_escape_initial_press_time, v:char)
    1              0.000009     let g:better_escape_initial_press_time[v:char] = reltime()
  124              0.000052   endif

FUNCTION  matchup#ts_engine#get_option()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/ts_engine.vim:31
Called 3 times
Total time:   0.000084
 Self time:   0.000016

count  total (s)   self (s)
    3   0.000081   0.000014   return s:forward('get_option', a:bufnr, a:opt_name)

FUNCTION  <SNR>104_wordish()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:1212
Called 220 times
Total time:   0.001104
 Self time:   0.001104

count  total (s)   self (s)
  220              0.001048   return a:delim.match !~? '^[[:punct:]]\{1,3\}$'

FUNCTION  1()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:135
Called 384 times
Total time:   0.020089
 Self time:   0.019032

count  total (s)   self (s)
  384              0.000801   if exists('w:matchup_match_id_list')
   75              0.000161     for l:id in w:matchup_match_id_list
                                  silent! call matchdelete(l:id)
   75              0.000060     endfor
   75              0.000122     unlet! w:matchup_match_id_list
  384              0.000148   endif
  384              0.000679   if exists('s:ns_id')
  384              0.004588     call nvim_buf_clear_namespace(0, s:ns_id, 0, -1)
  384              0.000156   endif
                            
  384              0.001535   if !has('nvim') && exists('t:match_popup') && (exists('*win_gettype') ? win_gettype() !=# 'popup' : &buftype !=# 'terminal')
                                call s:do_popup_autocmd_leave(t:match_popup)
                                call popup_hide(t:match_popup)
  384              0.000590   elseif has('nvim')
  384   0.003838   0.002791     call s:close_floating_win()
  384              0.000124   endif
                            
  384              0.000536   if exists('w:matchup_oldstatus')
   19   0.000107   0.000097     let &l:statusline = w:matchup_oldstatus
   19              0.000017     unlet w:matchup_oldstatus
   19              0.000047     if exists('#User#MatchupOffscreenLeave')
                                  doautocmd <nomodeline> User MatchupOffscreenLeave
   19              0.000007     endif
  384              0.000129   endif
  384              0.000500   if exists('w:matchup_statusline')
   19              0.000014     unlet w:matchup_statusline
  384              0.000107   endif
                            
  384              0.000446   let w:matchup_need_clear = 0

FUNCTION  2()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:203
Called 509 times
Total time:   0.023301
 Self time:   0.004210

count  total (s)   self (s)
                              ""
                              " fade feature: remove highlights after a certain time
                              " {level}
                              "   =  0: prepare for possible loss of cursor support
                              "   =  1: new highlights are coming (cancel prior fade)
                              "   =  2: end of new highlights
                              " {pos}     [lnum, column] of current match
                              " {token}   in/out saves state between calls
                              "
                              " returns 1 if highlighting should be canceled
                            
  509              0.000854   if !g:matchup_matchparen_deferred || !exists('w:matchup_fade_timer')
  509              0.000443     if a:level <= 0
  361   0.020025   0.000934       call s:matchparen.clear()
  509              0.000188     endif
  509              0.000289     return 0
                              endif
                            
                              " jumping between windows
                              if a:level == 0 && win_getid() != get(s:, 'save_win')
                                call timer_pause(w:matchup_fade_timer, 1)
                                if exists('w:matchup_fade_pos')
                                  unlet w:matchup_fade_pos
                                endif
                                call s:matchparen.clear()
                                let s:save_win = win_getid()
                              endif
                            
                              " highlighting might be stale
                              if a:level == 0
                                if exists('w:matchup_fade_pos')
                                  let a:token.save_pos = w:matchup_fade_pos
                                  unlet w:matchup_fade_pos
                                endif
                                if !w:matchup_need_clear
                                  call timer_pause(w:matchup_fade_timer, 1)
                                endif
                                return 0
                              endif
                            
                              " prepare for new highlighting
                              if a:level == 1
                                " if token has no save_pos, cursor was previously off of a match
                                if !has_key(a:token, 'save_pos') || a:pos != a:token.save_pos
                                  " clear immediately
                                  call timer_pause(w:matchup_fade_timer, 1)
                                  call s:matchparen.clear()
                                  return 0
                                endif
                                let w:matchup_fade_pos = a:token.save_pos
                                return 1
                              endif
                            
                              " new highlighting is active
                              if a:level == 2 && a:pos != get(w:, 'matchup_fade_pos', [])
                                " init fade request
                                let w:matchup_fade_pos = a:pos
                                let w:matchup_fade_start = reltime()
                                call timer_pause(w:matchup_fade_timer, 0)
                              endif
                            
                              return 0

FUNCTION  3()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:303
Called 469 times
Total time:   0.478708
 Self time:   0.003669

count  total (s)   self (s)
  469              0.001549   if !get(b:, 'matchup_matchparen_deferred', g:matchup_matchparen_deferred)
  469   0.476832   0.001793     return s:matchparen.highlight()
                              endif
                            
                              if !exists('w:matchup_timer')
                                let s:show_delay = g:matchup_matchparen_deferred_show_delay
                                let s:hide_delay = g:matchup_matchparen_deferred_hide_delay
                                let w:matchup_timer = timer_start(s:show_delay, function('s:timer_callback', [ win_getid() ]), {'repeat': -1})
                                if !exists('w:matchup_need_clear')
                                  let w:matchup_need_clear = 0
                                endif
                                let s:fade_time = g:matchup_matchparen_deferred_fade_time
                                if s:fade_time > 0
                                  let w:matchup_fade_timer = timer_start(s:fade_time, function('s:fade_timer_callback', [ win_getid() ]), {'repeat': -1})
                                  call timer_pause(w:matchup_fade_timer, 1)
                                endif
                              endif
                            
                              " keep the timer alive with a heartbeat
                              let w:matchup_pulse_time = reltime()
                            
                              " if the timer is paused, some time has passed
                              if timer_info(w:matchup_timer)[0].paused
                                " unpause the timer
                                call timer_pause(w:matchup_timer, 0)
                            
                                " set the hi time to the pulse time
                                let w:matchup_hi_time = w:matchup_pulse_time
                              endif

FUNCTION  4()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:342
Called 492 times
Total time:   0.492973
 Self time:   0.062910

count  total (s)   self (s)
  492              0.001112   if !g:matchup_matchparen_enabled | return | endif
                            
  492              0.001858   if has('vim_starting') | return | endif
                            
  492              0.000996   if !g:matchup_matchparen_pumvisible && pumvisible() | return | endif
                            
                              " try to avoid interfering with some auto-complete plugins
  492              0.001447   if has('*state') && state('a') !=# '' | return | endif
                            
  492              0.001657   if !get(b:, 'matchup_matchparen_enabled', 1) && get(b:, 'matchup_matchparen_fallback', 1) && s:pi_paren_sid()
                                return call(s:pi_paren_fcn, [])
  492              0.000190   endif
                            
  492              0.000997   if !get(b:, 'matchup_matchparen_enabled', 1) | return | endif
                            
  492              0.001078   let l:force_update    = a:0 >= 1 ? a:1 : 0
  492              0.000694   let l:changing_insert = a:0 >= 2 ? a:2 : 0
  492              0.001294   let l:real_mode = l:changing_insert ? v:insertmode : mode()
                            
  492   0.044562   0.016040   if !l:force_update && exists('w:last_changedtick') && exists('w:last_cursor') && matchup#pos#equal(w:last_cursor, matchup#pos#get_cursor()) && w:last_changedtick == b:changedtick
  131              0.000069     return
  361              0.000125   endif
  361              0.000507   let w:last_changedtick = b:changedtick
  361   0.002874   0.002257   let w:last_cursor = matchup#pos#get_cursor()
                            
  361   0.002870   0.001416   call matchup#perf#tic('matchparen.highlight')
                            
                              " request eventual clearing of stale matches
  361              0.000447   let l:token = {}
  361   0.023599   0.001248   call self.fade(0, [], l:token)
                            
  361              0.000519   let l:modes = g:matchup_matchparen_nomode
  361              0.000695   if get(g:, 'matchup_matchparen_novisual', 0)  " deprecated option name
                                let l:modes .= "vV\<c-v>"
  361              0.000113   endif
  361              0.000731   if stridx(l:modes, l:real_mode) >= 0
                                return
  361              0.000099   endif
                            
                              " prevent problems in visual block mode at the end of a line
  361   0.002536   0.001941   if get(matchup#pos#get_cursor(), 4, 0) == 2147483647 && "v\<c-v>" =~? mode()
                                return
  361              0.000102   endif
                            
                              " don't get matches when inside a closed fold
  361              0.000782   if foldclosed(line('.')) > -1
                                return
  361              0.000095   endif
                            
                              " give up when cursor is far into a very long line
  361              0.001069   if &synmaxcol && col('.') > &synmaxcol
                                return
  361              0.000095   endif
                            
                              " in insert mode, cursor is treated as being one behind
  361              0.000553   let l:insertmode = l:real_mode ==# 'i'
                            
                              " start the timeout period
  361              0.001594   let l:timeout = l:insertmode ? get(b:, 'matchup_matchparen_insert_timeout',           g:matchup_matchparen_insert_timeout) : get(b:, 'matchup_matchparen_timeout',           g:matchup_matchparen_timeout)
  361   0.003750   0.001611   call matchup#perf#timeout_start(l:timeout)
                            
  361   0.210513   0.003107   let l:current = matchup#delim#get_current('all', 'both_all', { 'insertmode': l:insertmode,   'stopline': g:matchup_matchparen_stopline,   'highlighting': 1, })
  361   0.007480   0.001812   call matchup#perf#toc('matchparen.highlight', 'get_current')
                            
  361              0.000753   if get(b:, 'matchup_matchparen_deferred', g:matchup_matchparen_deferred)
                                let l:hsa = get(b:, 'matchup_matchparen_hi_surround_always', g:matchup_matchparen_hi_surround_always)
                                if l:hsa > 0 && empty(l:current) || l:hsa > 1
                                  call s:highlight_surrounding(l:insertmode, !empty(l:current))
                                endif
  361              0.000107   endif
                            
  361              0.000365   if empty(l:current)
  287              0.000147     return
   74              0.000019   endif
                            
   74   0.104695   0.000631   let l:corrlist = matchup#delim#get_matching(l:current, { 'stopline': g:matchup_matchparen_stopline,   'highlighting': 1, })
   74   0.001589   0.000339   call matchup#perf#toc('matchparen.highlight', 'get_matching')
   74              0.000145   if empty(l:corrlist) | return | endif
                            
   74              0.000069   if g:matchup_transmute_enabled
                                if !exists('w:matchup_matchparen_context')
                                  let w:matchup_matchparen_context = { 'normal': {   'current':   {},   'corrlist':  [],  }, 'prior': {}, 'counter': 0,}
                                endif
                            
                                let w:matchup_matchparen_context.counter += 1
                            
                                if !l:insertmode
                                  let w:matchup_matchparen_context.prior = copy(w:matchup_matchparen_context.normal)
                            
                                  let w:matchup_matchparen_context.normal.current = l:current
                                  let w:matchup_matchparen_context.normal.corrlist = l:corrlist
                                endif
                            
                                " if transmuted, highlight again (will reset timeout)
                                if matchup#transmute#tick(l:insertmode)
                                  " no force_update here because it would screw up prior
                                  return s:matchparen.highlight(0, l:changing_insert)
                                endif
   74              0.000022   endif
                            
   74              0.000275   if !has_key(l:current, 'match_index') || len(l:corrlist) <= (l:current.side ==# 'mid' ? 2 : 1) && !g:matchup_matchparen_singleton
                                " TODO this doesn't catch every case, needs refactor
                                " TODO singleton doesn't work right for mids
                                return
   74              0.000021   endif
                            
                              " prepare for (possibly) new highlights
   74              0.000112   let l:pos = [l:current.lnum, l:current.cnum]
   74   0.000726   0.000244   if self.fade(1, l:pos, l:token)
                                return
   74              0.000018   endif
                            
                              " store flag meaning highlighting is active
   74              0.000076   let w:matchup_need_clear = 1
                            
                              " disable off-screen when scrolling with j/k
   74              0.000449   let l:scrolling = get(g:matchup_matchparen_offscreen, 'scrolloff', 0) && winheight(0) > 2*&scrolloff && (line('.') == line('w$')-&scrolloff     && line('$') != line('w$')     || line('.') == line('w0')+&scrolloff)
                            
                              " show off-screen matches
   74              0.000145   let l:method = get(g:matchup_matchparen_offscreen, 'method', '')
   74              0.000259   if !empty(l:method) && l:method !=# 'none' && !l:current.skip && !l:scrolling && winheight(0) > 0
   71   0.045277   0.000332     call s:do_offscreen(l:current, l:method)
   74              0.000024   endif
                            
                              " add highlighting matches
   74   0.009156   0.000352   call s:add_matches(l:corrlist, l:current)
                            
                              " highlight the background between parentheses
   74              0.000085   if g:matchup_matchparen_hi_background >= 1
                                call s:highlight_background(l:corrlist)
   74              0.000030   endif
                            
                              " new highlights done, request fade away
   74   0.000741   0.000273   call self.fade(2, l:pos, l:token)
                            
   74   0.001558   0.000260   call matchup#perf#toc('matchparen.highlight', 'end')

FUNCTION  5()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:512
Called 3 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    3              0.000004   if g:matchup_transmute_enabled
                                call matchup#transmute#reset()
    3              0.000001   endif

FUNCTION  <SNR>48_on_finish()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/branch.vim:26
Called 368 times
Total time:   0.152017
 Self time:   0.003247

count  total (s)   self (s)
  368              0.000360   if a:x isnot v:false
  138   0.001863   0.000457     call s:resolve(a:state, a:ctx, a:x)
  138              0.000069     return
  230              0.000072   endif
                            
  230              0.000238   let a:state.index += 1
                            
  230              0.000354   if a:state.index >= len(a:state.pipelines)
                                call s:resolve(a:state, a:ctx, v:false)
                                return
  230              0.000061   endif
                            
  230   0.082843   0.018091   call wilder#pipeline#run( a:state.pipelines[a:state.index], {ctx, x -> s:on_finish(a:state, ctx, x)}, {ctx, x -> s:on_error(a:state, ctx, x)}, copy(a:state.original_ctx), copy(a:state.original_x), )

FUNCTION  matchup#perf#timeout_check()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/perf.vim:91
Called 258 times
Total time:   0.002812
 Self time:   0.002812

count  total (s)   self (s)
  258              0.000538   if !s:timeout_enabled | return 0 | endif
  258              0.001003   let l:elapsed = 1000.0 * s:Reltimefloat(reltime(s:timeout_pulse_time))
  258              0.000345   let s:timeout -= l:elapsed
  258              0.000437   let s:timeout_pulse_time = reltime()
  258              0.000315   return s:timeout <= 0.0

FUNCTION  <SNR>39_sort_buffers_lastused()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1398
Called 46 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
   46              0.000088   if get(a:data, 'cmdline.expand', '') !=# 'buffer'
   46              0.000033     return a:xs
                              endif
                            
                              let l:bufinfos = getbufinfo()
                              let l:bufnr_to_x = {}
                            
                              for l:x in a:xs
                                let l:bufname = fnamemodify(l:x, ':~')
                                let l:bufnr = bufnr('^' . l:x . '$')
                            
                                let l:bufnr_to_x[l:bufnr] = l:x
                              endfor
                            
                              let l:x_to_info = {}
                              let l:seen = {}
                            
                              for l:info in l:bufinfos
                                let l:bufnr = l:info.bufnr
                            
                                if !has_key(l:bufnr_to_x, l:bufnr)
                                  continue
                                endif
                            
                                let l:x = l:bufnr_to_x[l:bufnr]
                                let l:x_to_info[l:x] = l:info
                                let l:seen[l:bufnr] = 1
                              endfor
                            
                              let l:xs = copy(a:xs)
                              let l:match_arg = get(a:data, 'cmdline.match_arg', '')
                            
                              " add matching bufnr
                              if l:match_arg =~# '\d\+'
                                for l:info in l:bufinfos
                                  let l:bufnr = l:info.bufnr
                                  let l:bufname = l:info.name
                            
                                  if !l:info.listed || empty(l:bufname) || has_key(l:seen, l:bufnr)
                                    continue
                                  endif
                            
                                  if stridx(l:bufnr, l:match_arg) == 0
                                    let l:bufname = fnamemodify(l:bufname, ':~:.')
                                    let l:x_to_info[l:bufname] = l:info
                                    call add(l:xs, l:bufname)
                                  endif
                                endfor
                              endif
                            
                              let l:current_bufnr = bufnr('%')
                            
                              return sort(l:xs, {x1, x2 -> s:sort_buffers_lastused_func(x1, x2, l:x_to_info, l:current_bufnr)})

FUNCTION  <lambda>83()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 46 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  <lambda>86()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder.vim:198
Called 46 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>89()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder.vim:198
Called 46 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
                            return x

FUNCTION  <SNR>84_AppendHeartbeat()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:459
Called 30 times
Total time:   0.004351
 Self time:   0.001169

count  total (s)   self (s)
   30              0.000046         let file = a:file
   30              0.000035         if empty(file)
                                        let file = a:last.file
   30              0.000010         endif
   30              0.000026         if !empty(file)
   30              0.000039             let heartbeat = {}
   30              0.000038             let heartbeat.entity = file
   30   0.000612   0.000129             let heartbeat.time = s:CurrentTimeStr()
   30              0.000036             let heartbeat.is_write = a:is_write
   30              0.000082             if !empty(&syntax) && &syntax != 'ON'
    4              0.000005                 let heartbeat.language = &syntax
   26              0.000013             else
   26              0.000034                 if !empty(&filetype)
   23              0.000025                     let heartbeat.language = &filetype
   26              0.000010                 endif
   30              0.000009             endif
   30              0.000133             let s:heartbeats_buffer = s:heartbeats_buffer + [heartbeat]
   30   0.002918   0.000220             call s:SetLastHeartbeat(a:now, a:now, file)
                            
   30              0.000059             if !s:buffering_heartbeats_enabled
                                            call s:SendHeartbeats()
   30              0.000014             endif
   30              0.000010         endif

FUNCTION  <SNR>63_set_line()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:247
Called 943 times
Total time:   0.004013
 Self time:   0.004013

count  total (s)   self (s)
  943              0.003817   call nvim_buf_set_lines(self.state.buf, a:line, a:line, v:true, [a:str])

FUNCTION  <SNR>84_JoinArgs()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:437
Called 8 times
Total time:   0.001002
 Self time:   0.000555

count  total (s)   self (s)
    8              0.000013         let safeArgs = []
   88              0.000059         for arg in a:args
   80   0.000837   0.000390             let safeArgs = safeArgs + [s:SanitizeArg(arg)]
   88              0.000036         endfor
    8              0.000033         return join(safeArgs, ' ')

FUNCTION  <lambda>90()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 46 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
                            return getcmdtype() ==# ':'

FUNCTION  <lambda>94()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder.vim:198
Called 46 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>96()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 46 times
Total time:   0.000628
 Self time:   0.000203

count  total (s)   self (s)
                            return wilder#cmdline#prepare_user_completion(ctx, res)

FUNCTION  <lambda>99()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 46 times
Total time:   0.000548
 Self time:   0.000153

count  total (s)   self (s)
                            return s:set_query(data)

FUNCTION  <SNR>107_forward()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/ts_engine.vim:10
Called 11 times
Total time:   0.000579
 Self time:   0.000579

count  total (s)   self (s)
   11              0.000558   let l:ret = luaeval( 'require"treesitter-matchup.internal".' . a:fn . '(unpack(_A))', a:000)
   11              0.000014   return l:ret

FUNCTION  <SNR>40_set()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cache.vim:15
Called 302 times
Total time:   0.000632
 Self time:   0.000632

count  total (s)   self (s)
  302              0.000564   let self['_cache'][a:key] = a:value

FUNCTION  <SNR>35_wrap_function()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/lua.vim:32
Called 92 times
Total time:   0.001114
 Self time:   0.001114

count  total (s)   self (s)
   92              0.000134   let l:index = s:index
   92              0.000094   let s:index += 1
                            
   92              0.000388   let s:functions[l:index] = a:f
   92              0.000421   return { 'index': l:index, 'name': get(a:f, 'name'), '__wilder_wrapped__': s:token, }

FUNCTION  <SNR>40_mru_get()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cache.vim:41
Called 242 times
Total time:   0.000414
 Self time:   0.000414

count  total (s)   self (s)
  242              0.000356   return self['_cache'][a:key]

FUNCTION  matchup#perf#timeout_start()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/perf.vim:84
Called 361 times
Total time:   0.002138
 Self time:   0.002138

count  total (s)   self (s)
  361              0.000480   let s:timeout = a:timeout
  361              0.000582   let s:timeout_enabled = (a:timeout == 0) ? 0 : 1
  361              0.000864   let s:timeout_pulse_time = reltime()

FUNCTION  wilder#cmdline#parse()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:3
Called 242 times
Total time:   0.018511
 Self time:   0.004332

count  total (s)   self (s)
  242   0.001723   0.001025   if !s:cmdline_cache.has_key(a:cmdline)
   25              0.000085     let l:ctx = {'cmdline': a:cmdline, 'pos': 0, 'cmd': '', 'expand': ''}
   25   0.012384   0.000140     call wilder#cmdline#main#do(l:ctx)
                            
   25              0.000064     let l:ctx['arg'] = l:ctx['cmdline'][l:ctx.pos :]
   25              0.000034     let l:ctx['pos'] = l:ctx.pos
   25   0.000951   0.000128     call s:cmdline_cache.set(a:cmdline, l:ctx)
  242              0.000085   endif
                            
  242   0.001617   0.001204   return copy(s:cmdline_cache.get(a:cmdline))

FUNCTION  wilder#highlight#init_hl()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlight.vim:16
Called 4 times
Total time:   0.010216
 Self time:   0.000161

count  total (s)   self (s)
   20              0.000041   for [l:name, l:x, l:xs] in s:hl_list
   16   0.010157   0.000103     call s:make_hl(l:name, l:x, l:xs)
   20              0.000008   endfor

FUNCTION  <SNR>84_SanitizeArg()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:427
Called 80 times
Total time:   0.000447
 Self time:   0.000447

count  total (s)   self (s)
   80              0.000165         let sanitized = shellescape(a:arg)
   80              0.000198         let sanitized = substitute(sanitized, '!', '\\!', 'g')
   80              0.000054         return sanitized

FUNCTION  <SNR>63_show()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:67
Called 89 times
Total time:   0.005747
 Self time:   0.000327

count  total (s)   self (s)
   89              0.000192   if self.state.win != -1 || self.state.window_state !=# 'hidden'
   85              0.000044     return
    4              0.000001   endif
                            
    4              0.000005   let self.state.window_state = 'pending'
                            
    4              0.000002   try
    4   0.005441   0.000021     call self._open_win()
                              catch
                                call timer_start(0, {-> self._open_win()})
    4              0.000003   endtry

FUNCTION  matchup#loader#get_capture_groups()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/loader.vim:652
Called 27 times
Total time:   0.002445
 Self time:   0.002016

count  total (s)   self (s)
   27              0.000044   let l:allow_percent = a:0 ? a:1 : 0
   27              0.000042   let l:pat = g:matchup#re#not_bslash . '\(\\%(\|\\(\|\\)\)'
                            
   27              0.000024   let l:start = 0
                            
   27              0.000024   let l:brefs = {}
   27              0.000021   let l:stack = []
   27              0.000021   let l:counter = 0
   63              0.000037   while 1
   63   0.000718   0.000288     let l:match = s:matchstrpos(a:str, l:pat, l:start)
   99              0.000095     if l:match[1] < 0 | break | endif
   36              0.000036     let l:start = l:match[2]
                            
   36              0.000071     if l:match[0] ==# '\(' || (l:match[0] ==# '\%(' && l:allow_percent)
   12              0.000013       let l:counter += 1
   12              0.000019       call add(l:stack, l:counter)
   12              0.000038       let l:cgstack = filter(copy(l:stack), 'v:val > 0')
   12              0.000076       let l:brefs[l:counter] = { 'str': '', 'depth': len(l:cgstack), 'parent': (len(l:cgstack) > 1 ? l:cgstack[-2] : 0), 'pos': [l:match[1], 0],}
   24              0.000023     elseif l:match[0] ==# '\%('
    6              0.000010       call add(l:stack, 0)
   18              0.000006     else
   36              0.000022       if empty(l:stack) | break | endif
   18              0.000029       let l:i = remove(l:stack, -1)
   36              0.000019       if l:i < 1 | continue | endif
   12              0.000019       let l:j = l:brefs[l:i].pos[0]
   12              0.000033       let l:brefs[l:i].str = strpart(a:str, l:j, l:match[2]-l:j)
   12              0.000019       let l:brefs[l:i].pos[1] = l:match[2]
   30              0.000010     endif
   57              0.000035   endwhile
                            
   27              0.000061   call filter(l:brefs, 'has_key(v:val, "str")')
                            
   27              0.000020   return l:brefs

FUNCTION  <SNR>63_need_timer()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:263
Called 95 times
Total time:   0.000463
 Self time:   0.000463

count  total (s)   self (s)
   95              0.000315   if has('nvim-0.7')
                                " See https://github.com/neovim/neovim/issues/17810.
                                " Avoid calling nvim_buf_set_lines(), so assume timer is always needed.
   95              0.000053     return 1
                              endif
                            
                              try
                                call nvim_buf_set_lines(self.state.dummy_buf, 0, -1, v:true, [])
                              catch
                                return 1
                              endtry
                            
                              return 0

FUNCTION  <SNR>84_GetLastHeartbeat()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:646
Called 378 times
Total time:   0.006502
 Self time:   0.006502

count  total (s)   self (s)
  378              0.001596         if !s:last_heartbeat.last_activity_at || localtime() - s:last_heartbeat.last_activity_at > s:local_cache_expire
   12              0.000105             if !filereadable(s:shared_state_file)
                                            return {'last_activity_at': 0, 'last_heartbeat_at': 0, 'file': ''}
   12              0.000009             endif
   12              0.000235             let last = readfile(s:shared_state_file, '', 3)
   12              0.000024             if len(last) == 3
   12              0.000032                 let s:last_heartbeat.last_heartbeat_at = last[1]
   12              0.000018                 let s:last_heartbeat.file = last[2]
   12              0.000005             endif
  378              0.000154         endif
  378              0.000345         return s:last_heartbeat

FUNCTION  <SNR>117_push_completion_stack()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:757
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
                              " double-check that the last added entry is not the same value
                              " this can happen when the argument exactly matches the completion
    1              0.000003   if !empty(s:completion_stack) && s:completion_stack[0] ==# a:cmdline
                                return
    1              0.000000   endif
                            
    1              0.000003   let s:completion_stack = [a:cmdline] + s:completion_stack

FUNCTION  <SNR>61_make_message()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:738
Called 3 times
Total time:   0.001876
 Self time:   0.000196

count  total (s)   self (s)
    3              0.000005   let l:Message = a:func
    3              0.000004   if type(l:Message) is v:t_dict
                                let l:Message = l:Message.value
    3              0.000001   endif
                            
    3   0.000042   0.000011   let l:min_width = a:state.get_min_width(a:ctx, a:result)
    3   0.000034   0.000010   let l:max_width = a:state.get_max_width(a:ctx, a:result)
    3   0.000020   0.000009   let l:min_height = a:state.get_min_height(a:ctx, a:result)
    3   0.000034   0.000009   let l:max_height = a:state.get_max_height(a:ctx, a:result)
                            
    3              0.000007   let l:height_used = len(a:state.top) + len(a:state.bottom)
    3              0.000003   let l:max_height -= l:height_used
    3              0.000003   let l:min_height -= l:height_used
                            
    3              0.000003   if l:max_width < l:min_width
                                let l:max_width = l:min_width
    3              0.000001   endif
    3              0.000002   if l:max_height < l:min_height
                                let l:max_height = l:min_height
    3              0.000001   endif
                            
    3              0.000003   if type(l:Message) is v:t_func
    3              0.000007     let l:ctx = copy(a:ctx)
                            
    3              0.000003     let l:ctx.min_width = l:min_width
    3              0.000003     let l:ctx.max_width = l:max_width
    3              0.000003     let l:ctx.min_height = l:min_height
    3              0.000002     let l:ctx.max_height = l:max_height
                            
    3   0.001664   0.000077     let l:Message = l:Message(l:ctx, a:arg)
    3              0.000001   endif
                            
    3              0.000003   if type(l:Message) is v:t_string
                                let l:hl = a:ctx.highlights[a:hl_key]
                                let l:Message = s:make_message_from_string(l:Message, l:min_width, l:max_width, l:min_height, l:hl)
    3              0.000001   endif
                            
    3              0.000002   return l:Message

FUNCTION  wilder#resolve()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder.vim:37
Called 184 times
Total time:   0.000644
 Self time:   0.000644

count  total (s)   self (s)
  184              0.000591   call timer_start(0, {-> wilder#pipeline#resolve(a:ctx, a:x)})

FUNCTION  matchup#perf#timeout()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/perf.vim:79
Called 471 times
Total time:   0.001001
 Self time:   0.001001

count  total (s)   self (s)
  471              0.000834   return float2nr(s:timeout)

FUNCTION  <SNR>59_wrap_message()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:196
Called 3 times
Total time:   0.001073
 Self time:   0.000252

count  total (s)   self (s)
    3              0.000005   let l:left = a:border_chars[3]
    3              0.000004   let l:right = a:border_chars[4]
    3              0.000007   let l:left_width = strdisplaywidth(l:left)
    3              0.000005   let l:right_width = strdisplaywidth(l:right)
                            
    3              0.000005   let l:min_width = a:ctx.min_width - l:left_width - l:right_width
    3              0.000004   let l:max_width = a:ctx.max_width - l:left_width - l:right_width
                              " min_height and max_height have already accounted for the top and bottom
                              " lines, so we don't have to adjust them.
    3              0.000003   let l:max_height = a:ctx.max_height
    3              0.000003   let l:min_height = a:ctx.min_height
                            
    3              0.000004   let l:Message = a:message
    3              0.000004   if type(l:Message) is v:t_func
    3              0.000008     let l:ctx = copy(a:ctx)
    3              0.000003     let l:ctx.min_width = l:min_width
    3              0.000002     let l:ctx.max_width = l:max_width
    3              0.000002     let l:ctx.min_height = l:min_height
    3              0.000002     let l:ctx.max_height = l:max_height
                            
    3   0.000876   0.000064     let l:Message = copy(a:message(l:ctx, a:result))
    3              0.000001   endif
                            
    3              0.000003   if type(l:Message) is v:t_string
                                let l:message = l:Message
                                let l:message = wilder#render#truncate(l:max_width, l:message)
                                let l:message .= repeat(' ', l:min_width - strdisplaywidth(l:message))
                            
                                let l:hl = get(a:ctx.highlights, a:hl_key)
                                let l:Message = [[[l:message, l:hl]]]
                            
                                if l:min_height > 1
                                  let l:width = strdisplaywidth(l:message)
                                  let l:Message += repeat([[[repeat(' ', l:width)]]], l:min_height - 1)
                                endif
    3              0.000001   endif
                            
    3              0.000003   let l:border_hl = a:ctx.highlights.border
    3              0.000002   if l:left_width && l:right_width
    3   0.000090   0.000081     return map(l:Message, {_, row -> [[l:left, l:border_hl]] + row + [[l:right, l:border_hl]]})
                              endif
                            
                              if l:left_width
                                return map(l:Message, {_, row -> [[l:left, l:border_hl]] + row})
                              endif
                            
                              if l:right_width
                                return map(l:Message, {_, row -> row + [[l:right, l:border_hl]]})
                              endif
                            
                              return l:Message

FUNCTION  <SNR>127_get_shortcut_keymap()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/better-escape.vim/plugin/better_escape.vim:58
Called 1 time
Total time:   0.000046
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000002   let key_map = {}
    2              0.000003   for l:shortcut in g:better_escape_shortcut
    1   0.000012   0.000007     let l:ch1 = better_escape#CharAtIdx(l:shortcut, 0)
    1   0.000008   0.000005     let l:ch2 = better_escape#CharAtIdx(l:shortcut, 1)
    1              0.000003     if has_key(key_map, l:ch2)
                                  let key_map[l:ch2] += [l:ch1]
    1              0.000001     else
    1              0.000002       let key_map[l:ch2] = [l:ch1]
    1              0.000001     endif
    2              0.000001   endfor
                            
    1              0.000001   return key_map

FUNCTION  wilder#highlighter#lua_fzy_highlight()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlighter.vim:216
Called 302 times
Total time:   0.005891
 Self time:   0.005891

count  total (s)   self (s)
  302              0.000441   if !has_key(a:data, 'query')
                                return 0
  302              0.000096   endif
                            
  302              0.004976   return luaeval( 'require("wilder.internal").fzy_highlight(_A[1], _A[2])', [a:data.query, a:x])

FUNCTION  <SNR>84_SetupDebugMode()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:307
Called 12 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
   12              0.000020         if !s:debug_mode_already_setup
                                        if s:GetIniSetting('settings', 'debug') == 'true'
                                            let s:is_debug_on = s:true
                                        else
                                            let s:is_debug_on = s:false
                                        endif
                                        let s:debug_mode_already_setup = s:true
   12              0.000004         endif

FUNCTION  matchup#matchparen#scroll_callback()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:1115
Called 1 time
Total time:   0.002532
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000008   call timer_pause(a:tid, 1)
    1   0.002523   0.000008   call s:matchparen.highlight(1)

FUNCTION  wilder#main#step()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:496
Called 1 time
Total time:   0.000753
 Self time:   0.000106

count  total (s)   self (s)
    1              0.000001   if !s:enabled
                                " returning '' seems to prevent async completions from finishing
                                " or prevent redrawing
                                return "\<Insert>\<Insert>"
    1              0.000001   endif
                            
    1              0.000001   if !s:active
                                call s:start()
                                return "\<Insert>\<Insert>"
    1              0.000000   endif
                            
    1              0.000001   if s:hidden
                                return "\<Insert>\<Insert>"
    1              0.000000   endif
                            
                              " If replaced_cmdline is null, this is the first wilder#next() call for the
                              " current result
    1              0.000002   if s:replaced_cmdline is v:null
                                " Original cmdline
    1   0.000011   0.000006     let s:replaced_cmdline = s:getcmdline()
    1              0.000001   endif
                            
    1              0.000002   let l:previous_selected = s:selected
                            
    1              0.000003   let l:len = len(s:result.value)
                            
    1              0.000002   if s:selected == -1 && !s:opts.noselect && !s:selection_was_made
                                let s:selected = 0
    1              0.000000   endif
                            
    1              0.000001   let s:selection_was_made = 1
                            
    1              0.000001   if a:num_steps == 0
                                " pass
    1              0.000001   elseif l:len == 0
                                let s:selected = -1
    1              0.000000   else
    1              0.000001     if s:selected < 0
    1              0.000001       if a:num_steps > 0
    1              0.000002         let l:selected = a:num_steps - 1
                                  else
                                    let l:selected = a:num_steps
    1              0.000000       endif
                            
    1              0.000001       while l:selected < 0
                                    let l:selected += l:len
    1              0.000001       endwhile
                                else
                                  let l:selected = s:selected + a:num_steps
                            
                                  while l:selected < -1
                                    let l:selected += l:len
                                  endwhile
    1              0.000000     endif
                            
    1              0.000001     while l:selected > l:len
                                  let l:selected -= l:len
    1              0.000000     endwhile
                            
    1              0.000002     let s:selected = l:selected == l:len ? -1 : l:selected
    1              0.000000   endif
                            
    1              0.000001   if s:selected >= -1
    1              0.000001     if s:selected >= 0
                                  " add the entry to the completion stack if there was no previous selection
    1              0.000001       if l:previous_selected == -1
    1   0.000023   0.000014         call s:push_completion_stack(s:replaced_cmdline)
    1              0.000000       endif
                            
    1   0.000099   0.000008       let l:new_cmdline = s:get_cmdline_from_candidate(s:selected)
                                else
                                  " selected == -1 here
                                  " Go back to original cmdline
                                  let l:new_cmdline = s:replaced_cmdline
                            
                                  " if previous_selected != -1, an entry was added to completion_stack
                                  " remove it here
                                  if l:previous_selected != -1
                                    call s:pop_completion_stack()
                                  endif
    1              0.000000     endif
                            
    1              0.000001     let s:completion = l:new_cmdline
    1   0.000061   0.000008     call s:feedkeys_cmdline(l:new_cmdline)
                              else
                                " No completion
                                let s:completion = v:null
                            
                                " if previous_selected != -1, an entry was added to completion_stack
                                " remove it here
                                if l:previous_selected != -1
                                  call s:pop_completion_stack()
                                endif
    1              0.000000   endif
                            
    1   0.000494   0.000006   call s:draw(a:num_steps)
                            
    1              0.000002   return "\<Insert>\<Insert>"

FUNCTION  <SNR>103_init_delim_regexes()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/loader.vim:577
Called 4 times
Total time:   0.003621
 Self time:   0.000492

count  total (s)   self (s)
    4              0.000005   let l:re = {}
    4              0.000004   let l:re.delim_all = {}
    4              0.000003   let l:re.all = {}
                            
    4   0.003155   0.000026   let l:re.delim_tex = s:init_delim_regexes_generator('delim_tex')
    4              0.000008   let l:re.delim_tex._engine_info = { 'has_zs': {} }
                            
                              " use a flag for b:match_ignorecase
    4              0.000008   let l:ic = get(b:, 'match_ignorecase', 0) ? '\c' : '\C'
                            
                              " if a particular engine is specified, use that for the patterns
                              " (currently only applied to delim_re TODO)
    4              0.000012   let l:eng = string(get(b:, 'matchup_regexpengine', 0))
    4              0.000006   let l:eng = l:eng > 0 ? '\%#='.l:eng : ''
                            
   28              0.000020   for l:k in keys(s:sidedict)
   24              0.000166     let l:re.delim_tex._engine_info.has_zs[l:k] = l:re.delim_tex[l:k] =~# g:matchup#re#zs
                            
   24              0.000025     if l:re.delim_tex[l:k] ==# '\%(\)'
    1              0.000002       let l:re.delim_tex[l:k] = ''
   23              0.000006     else
                                  " since these patterns are used in searchpos(),
                                  " be explicit about regex mode (set magic mode and ignorecase)
   23              0.000048       let l:re.delim_tex[l:k] = l:eng . '\m' . l:ic . l:re.delim_tex[l:k]
   24              0.000007     endif
                            
   24              0.000029     let l:re.delim_all[l:k] = l:re.delim_tex[l:k]
   24              0.000027     let l:re.all[l:k] = l:re.delim_all[l:k]
   28              0.000010   endfor
                            
    4              0.000005   let l:re.delim_all._engine_info = l:re.delim_tex._engine_info
    4              0.000004   let l:re.all._engine_info = l:re.delim_all._engine_info
                            
    4              0.000003   return l:re

FUNCTION  <SNR>39_convert_result_to_data()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:753
Called 46 times
Total time:   0.000679
 Self time:   0.000679

count  total (s)   self (s)
   46              0.000183   let l:data = { 'pos': a:res.pos, 'cmdline.command': a:res.cmd, 'cmdline.expand': a:res.expand, 'cmdline.arg': a:res.arg, }
                            
   46              0.000072   if has_key(a:res, 'path_prefix')
                                let l:data['cmdline.path_prefix'] = a:res.path_prefix
   46              0.000017   endif
                            
   46              0.000049   if has_key(a:res, 'match_arg')
   46              0.000073     let l:data['cmdline.match_arg'] = a:res.match_arg
   46              0.000016   endif
                            
   46              0.000055   if has_key(a:res, 'has_wildcard')
                                let l:data['cmdline.has_wildcard'] = a:res.has_wildcard
   46              0.000013   endif
                            
   46              0.000033   return l:data

FUNCTION  <SNR>62_truncate_and_maybe_pad()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/render.vim:160
Called 3 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    3              0.000002   if a:len <= 0
                                return ''
    3              0.000001   endif
                            
    3              0.000004   let l:width = strdisplaywidth(a:x)
    3              0.000002   if l:width > a:len
                                let l:chars = split(a:x, '\zs')
                            
                                if a:direction
                                  let l:index = 0
                                  while l:width > a:len && l:index < len(l:chars)
                                    let l:width -= strdisplaywidth(l:chars[l:index])
                            
                                    let l:index += 1
                                  endwhile
                            
                                  let l:str = join(l:chars[l:index :], '')
                                else
                                  let l:index = len(l:chars) - 1
                                  while l:width > a:len && l:index >= 0
                                    let l:width -= strdisplaywidth(l:chars[l:index])
                            
                                    let l:index -= 1
                                  endwhile
                            
                                  let l:str = join(l:chars[:l:index], '')
                                endif
    3              0.000001   else
    3              0.000002     let l:str = a:x
    3              0.000001   endif
                            
    3              0.000002   if a:should_pad
                                let l:str .= repeat(' ', a:len - l:width)
    3              0.000001   endif
                            
    3              0.000002   return l:str

FUNCTION  <SNR>117_feedkeys_cmdline()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:654
Called 1 time
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    1              0.000012   let l:chars = split(a:cmdline, '\zs')
                            
    1              0.000001   if s:opts.use_cmdlinechanged || !s:opts.before_cursor
    1              0.000002     let l:keys = "\<C-E>\<C-U>"
                              else
                                let l:keys = "\<C-U>"
    1              0.000000   endif
                            
    8              0.000005   for l:char in l:chars
                                " control characters
    7              0.000005     if l:char <# ' '
                                  let l:keys .= "\<C-Q>"
    7              0.000002     endif
                            
    7              0.000008     let l:keys .= l:char
    8              0.000003   endfor
                            
    1              0.000003   call feedkeys(l:keys, 'n')

FUNCTION  wilder#highlight#get_hl()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlight.vim:229
Called 16 times
Total time:   0.000267
 Self time:   0.000102

count  total (s)   self (s)
   16              0.000027   if has('nvim')
   16   0.000233   0.000067     return wilder#highlight#get_hl_nvim(a:group)
                              else
                                return wilder#highlight#get_hl_vim(a:group)
                              endif

FUNCTION  <SNR>61_make_lines()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:446
Called 86 times
Total time:   0.288739
 Self time:   0.041480

count  total (s)   self (s)
   86              0.000241   let l:Highlighter = get(a:state, 'highlighter', [])
                            
   86              0.000095   let l:height = a:ctx.height
                            
   86              0.000066   if l:height > 0
   86   0.001234   0.001167     let l:left_column_chunks = map(repeat([0], l:height), {-> []})
   86   0.034900   0.000465     call s:draw_columns(l:left_column_chunks, a:state.left, a:ctx, a:result)
                            
   86   0.001539   0.001464     let l:right_column_chunks = map(repeat([0], l:height), {-> []})
   86   0.066630   0.000498     call s:draw_columns(l:right_column_chunks, a:state.right, a:ctx, a:result)
                              else
                                let l:left_column_chunks = []
                                let l:right_column_chunks = []
   86              0.000027   endif
                            
                              " [[left_column, chunks, right_column]]
   86              0.000167   let l:raw_lines = repeat([0], l:height)
                              " [[chunks_width, total_width]]
   86              0.000141   let l:widths = repeat([0], l:height)
                            
                              " Draw each line and calculate the width taken by the chunks.
   86              0.000135   let [l:start, l:end] = a:state.page
   86              0.000065   let l:i = 0
  670              0.000486   while l:i < l:height
  584              0.000582     let l:index = l:start + l:i
  584              0.000422     if l:index <= l:end
  584   0.124249   0.003176       let l:chunks = s:draw_candidates_chunks(a:state, a:ctx, a:result, l:index)
                                else
                                  let l:chunks = []
  584              0.000157     endif
  584              0.000761     let l:left_column = l:left_column_chunks[l:i]
  584              0.000687     let l:right_column = l:right_column_chunks[l:i]
                            
  584   0.010448   0.002674     let l:left_width = wilder#render#chunks_displaywidth(l:left_column)
  584   0.010175   0.002497     let l:chunks_width = wilder#render#chunks_displaywidth(l:chunks)
  584   0.010686   0.002437     let l:right_width = wilder#render#chunks_displaywidth(l:right_column)
                            
  584              0.000839     let l:total_width = l:left_width + l:chunks_width + l:right_width
                            
                                " Store the longest line width seen so far.
  584              0.000580     if l:total_width > a:state.longest_line_width
  104              0.000118       let a:state.longest_line_width = l:total_width
  584              0.000165     endif
                            
  584              0.000552     let l:index = l:i - l:start
  584              0.001045     let l:raw_lines[l:i] = [l:left_column, l:chunks, l:right_column]
  584              0.000838     let l:widths[l:i] = [l:chunks_width, l:total_width]
                            
  584              0.000417     let l:i += 1
  670              0.000296   endwhile
                            
   86   0.001364   0.000363   let l:max_width = a:state.get_max_width(a:ctx, a:result)
   86   0.001080   0.000306   let l:min_width = a:state.get_min_width(a:ctx, a:result)
                            
                              " Try to fit the longest line seen so far, if possible.
   86              0.000231   let l:expected_width = min([ l:max_width, a:state.longest_line_width, ])
   86              0.000093   if l:expected_width < l:min_width
   86              0.000088     let l:expected_width = l:min_width
   86              0.000030   endif
                            
                              " lines is the list of list of chunks which will be drawn.
                              " Each element represents one line of the popupmenu.
   86              0.000192   let l:lines = repeat([0], l:height)
                            
   86              0.000061   let l:i = 0
  670              0.000661   while l:i < len(l:raw_lines)
  584              0.000900     let [l:left_column, l:chunks, l:right_column] = l:raw_lines[l:i]
  584              0.000728     let [l:chunks_width, l:total_width] = l:widths[l:i]
                            
                                " Truncate or pad if necessary
  584              0.000452     if l:total_width > l:expected_width
                                  let l:ellipsis = a:state.ellipsis
                                  let l:ellipsis_width = strdisplaywidth(l:ellipsis)
                            
                                  let l:left_right_width = l:total_width - l:chunks_width
                                  let l:truncated_width = l:expected_width - l:left_right_width - l:ellipsis_width
                                  let l:chunks = wilder#render#truncate_chunks(l:truncated_width, l:chunks)
                            
                                  call add(l:chunks, [l:ellipsis])
                                  call add(l:chunks, [repeat(' ', l:truncated_width - wilder#render#chunks_displaywidth(l:chunks))])
  584              0.000451     elseif l:total_width < l:expected_width
  584              0.000577       let l:to_pad = l:expected_width - l:total_width
  584              0.001178       let l:chunks += [[repeat(' ', l:to_pad)]]
  584              0.000169     endif
                            
  584              0.001236     let l:lines[l:i] = l:left_column + l:chunks + l:right_column
                            
  584              0.000399     let l:i += 1
  670              0.000248   endwhile
                            
   86              0.000100   return [l:lines, l:expected_width]

FUNCTION  wilder#lua#unref_wrapped_function()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/lua.vim:50
Called 134 times
Total time:   0.000373
 Self time:   0.000373

count  total (s)   self (s)
  134              0.000353   unlet s:functions[a:index]

FUNCTION  <SNR>63_delete_all_lines()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:243
Called 89 times
Total time:   0.000991
 Self time:   0.000991

count  total (s)   self (s)
   89              0.000969   call nvim_buf_set_lines(self.state.buf, 0, -1, v:true, [])

FUNCTION  <SNR>117_pre_hook()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:224
Called 4 times
Total time:   0.011616
 Self time:   0.000097

count  total (s)   self (s)
    4   0.010234   0.000018   call wilder#highlight#init_hl()
                            
    4              0.000006   if has_key(s:opts, 'pre_hook')
                                call s:opts.pre_hook({})
    4              0.000001   endif
                            
    4              0.000006   if has_key(s:opts.renderer, 'pre_hook')
    4   0.001356   0.000054     call s:opts.renderer.pre_hook({})
    4              0.000001   endif

FUNCTION  <SNR>39_set_query()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1473
Called 46 times
Total time:   0.000395
 Self time:   0.000395

count  total (s)   self (s)
   46              0.000081   let l:data = a:data is v:null ? {} : a:data
   46              0.000093   let l:match_arg = get(l:data, 'cmdline.match_arg', '')
                            
   46              0.000187   return extend(l:data, {'query': l:match_arg})

FUNCTION  wilder#next()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder.vim:29
Called 1 time
Total time:   0.000767
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000767   0.000008   return wilder#main#next()

FUNCTION  <SNR>40_get()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cache.vim:11
Called 282 times
Total time:   0.000402
 Self time:   0.000402

count  total (s)   self (s)
  282              0.000338   return self['_cache'][a:key]

FUNCTION  <SNR>84_EnoughTimePassed()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:676
Called 364 times
Total time:   0.002247
 Self time:   0.002247

count  total (s)   self (s)
  364              0.000607         let prev = a:last.last_heartbeat_at
  364              0.000711         if a:now - prev > g:wakatime_HeartbeatFrequency * 60
                                        return s:true
  364              0.000137         endif
  364              0.000282         return s:false

FUNCTION  <SNR>84_SetLastHeartbeatInMemory()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:660
Called 38 times
Total time:   0.000200
 Self time:   0.000200

count  total (s)   self (s)
   38              0.000175         let s:last_heartbeat = {'last_activity_at': a:last_activity_at, 'last_heartbeat_at': a:last_heartbeat_at, 'file': a:file}

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /usr/share/nvim/runtime/ftplugin.vim:14
Called 4 times
Total time:   0.006845
 Self time:   0.006462

count  total (s)   self (s)
    4              0.000012     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    4              0.000002     endif
                            
    4              0.000010     let s = expand("<amatch>")
    4              0.000004     if s != ""
    4              0.000020       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    4              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    8              0.000018       for name in split(s, '\.')
    4   0.003730   0.003409         exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                    " Load lua ftplugins
    4   0.003002   0.002941         exe printf('runtime! ftplugin/%s.lua ftplugin/%s_*.lua ftplugin/%s/*.lua', name, name, name)
    8              0.000006       endfor
    4              0.000002     endif

FUNCTION  <SNR>84_NeovimAsyncExitHandler()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:860
Called 8 times
Total time:   0.000280
 Self time:   0.000168

count  total (s)   self (s)
    8   0.000195   0.000083         let output = s:StripWhitespace(join(s:nvim_async_output, "\n"))
    8              0.000016         if a:exit_code == s:exit_code_api_key_error
                                        let output .= 'Invalid API Key'
    8              0.000006         endif
    8              0.000026         if (s:is_debug_on || a:exit_code == s:exit_code_config_parse_error || a:exit_code == s:exit_code_api_key_error) && !empty(output)
                                        echoerr printf('[WakaTime] Error %d: %s', a:exit_code, output)
    8              0.000003         endif

FUNCTION  <SNR>61_render_lines()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:285
Called 89 times
Total time:   0.694766
 Self time:   0.121389

count  total (s)   self (s)
   89              0.000140   if !has_key(a:ctx, 'error')
                                " +1 to account for the cmdline prompt.
   89              0.000193     let l:pos = get(a:result, 'pos', 0) + 1
   89              0.000120     let l:pos -= a:state.left_offset
   89              0.000071     if l:pos < 0
                                  let l:pos = 0
   89              0.000031     endif
                              else
                                let l:cmdline = getcmdline()
                                let l:parsed = wilder#cmdline#parse(l:cmdline)
                                let l:pos = l:parsed.pos
   89              0.000029   endif
                            
   89              0.000106   let l:selected = a:ctx.selected
   89              0.000093   let l:reverse = a:state.reverse
                            
   89              0.000151   let [l:page_start, l:page_end] = a:state.page
                            
   89              0.000136   if a:state.page != [-1, -1]
                                " draw candidates
   86   0.289651   0.000912     let [l:lines, l:width] = s:make_lines(a:state, a:ctx, a:result)
   86              0.000159     let l:lines = l:reverse ? reverse(l:lines) : l:lines
    3              0.000001   else
    3              0.000003     if has_key(a:ctx, 'error')
                                  " draw error
                                  let l:lines = s:make_message(a:state, a:ctx, a:state.error_message, s:empty_result, a:ctx.error, 'error')
    3              0.000001     else
                                  " draw empty message
    3   0.001895   0.000019       let l:lines = s:make_message(a:state, a:ctx, a:state.empty_message, a:result, a:result, 'empty_message')
    3              0.000001     endif
                            
    3   0.000092   0.000022     let l:width = empty(l:lines) ? a:state.get_min_width(a:ctx, a:result) : wilder#render#chunks_displaywidth(l:lines[0])
   89              0.000031   endif
                            
   89              0.000465   let l:ctx = extend({'width': l:width}, a:ctx)
                            
                              " height excluding top and bottom
   89              0.000150   let l:lines_height = len(l:lines)
                            
   89              0.000090   let l:top_lines = []
   89              0.000080   let l:top_height = 0
  178              0.000207   for l:Top in a:state.top
   89   0.020726   0.000766     let l:line = s:draw_top_or_bottom_line(l:Top, l:ctx, a:result)
                            
   89              0.000102     if empty(l:line)
                                  continue
   89              0.000026     endif
                            
   89              0.000165     call add(l:top_lines, l:line)
   89              0.000103     let l:top_height += 1
  178              0.000087   endfor
   89              0.000170   let l:lines = l:top_lines + l:lines
                            
   89              0.000086   let l:bottom_height = 0
  356              0.000707   for l:Bottom in a:state.bottom
  267   0.093731   0.002047     let l:line = s:draw_top_or_bottom_line(l:Bottom, l:ctx, a:result)
                            
  267              0.000275     if empty(l:line)
                                  continue
  267              0.000079     endif
                            
  267              0.000364     call add(l:lines, l:line)
  267              0.000284     let l:bottom_height += 1
  356              0.000161   endfor
                            
   89              0.000081   if empty(l:lines)
                                call a:state.api.hide()
                                return
   89              0.000024   endif
                            
   89   0.006338   0.000591   call a:state.api.show()
                            
   89              0.000130   let l:height = len(l:lines)
   89   0.001323   0.000338   let l:max_height = a:state.get_max_height(a:ctx, a:result)
   89              0.000078   if l:max_height > &lines
                                let l:max_height = &lines
   89              0.000023   endif
   89   0.006556   0.001987   let [l:row, l:col] = a:state.position(a:ctx, l:pos, {'height': l:height, 'width': l:width, 'max_height': l:max_height})
                            
   89   0.002785   0.000434   call a:state.api.move(l:row, l:col, l:height, l:width)
   89   0.001522   0.000351   call a:state.api.set_option('wrap', v:false)
   89   0.001214   0.000318   call a:state.api.clear_all_highlights()
   89   0.001267   0.000276   call a:state.api.delete_all_lines()
                            
   89              0.000177   let l:default_hl = a:state.highlights['default']
   89              0.000119   let l:selected_hl = a:state.highlights['selected']
                            
   89              0.000069   let l:i = 0
 1032              0.001034   while l:i < len(l:lines)
  943              0.000946     let l:chunks = l:lines[l:i]
                            
  943              0.000596     let l:text = ''
 7140              0.003134     for l:chunk in l:chunks
 6197              0.005991       let l:text .= l:chunk[0]
 7140              0.002046     endfor
                            
  943   0.006762   0.002749     call a:state.api.set_line(l:i, l:text)
                            
                                " Don't apply selected for top lines or error or empty message.
  943              0.001969     if l:page_start == -1 || (!l:reverse && l:i < l:top_height) || (l:reverse && l:i >= l:top_height + l:lines_height)
  101              0.000099       let l:is_selected = 0
  842              0.000238     else
  842              0.001912       let l:is_selected = l:reverse ?  l:page_start + (l:height - l:i - l:bottom_height - 1) == l:selected : l:page_start + l:i - l:top_height == l:selected
  943              0.000281     endif
                            
  943              0.000585     let l:start = 0
 7140              0.003160     for l:chunk in l:chunks
 6197              0.007702       let l:end = l:start + len(l:chunk[0])
                            
 6197              0.003163       if l:is_selected
    7              0.000007         if len(l:chunk) == 1
    3              0.000003           let l:hl = l:selected_hl
    4              0.000004         elseif len(l:chunk) == 2
    4              0.000004           let l:hl = l:chunk[1]
                                    else
                                      let l:hl = l:chunk[2]
    7              0.000002         endif
 6190              0.001339       else
 6190              0.007421         let l:hl = get(l:chunk, 1, l:default_hl)
 6197              0.001649       endif
                            
 6197              0.004036       if l:hl !=# l:default_hl
 1066   0.006476   0.003376         call a:state.api.add_highlight(l:hl, l:i, l:start, l:end)
 6197              0.001575       endif
                            
 6197              0.003966       let l:start = l:end
 7140              0.002035     endfor
                            
  943              0.000633     let l:i += 1
 1032              0.000398   endwhile
                            
   89   0.001163   0.000343   call a:state.api.set_firstline(1)
   89   0.146758   0.000354   call wilder#renderer#redraw(a:state.apply_incsearch_fix)

FUNCTION  <SNR>121_wait_call()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipeline.vim:186
Called 46 times
Total time:   0.002045
 Self time:   0.000808

count  total (s)   self (s)
   46              0.000027   try
   46              0.000070     if type(a:state.f) is v:t_func
                                  let l:ctx = copy(a:ctx)
                            
                                  let s:id_index += 1
                                  let l:id_index = s:id_index
                                  let s:handler_registry[s:id_index] = a:state.handler
                            
                                  call timer_start(0, {_ -> s:call(a:state.f, l:ctx, l:id_index)})
   46              0.000021     else
   46              0.000058       let a:ctx.handler_id = a:state.wait_handler_id
   46   0.001394   0.000157       call a:state.on_finish(a:ctx, a:state.f)
   46              0.000019     endif
                              catch
                                let a:ctx.handler_id = a:state.wait_handler_id
                                call s:wait_on_error(a:state, a:ctx, v:exception)
   46              0.000023   endtry

FUNCTION  <SNR>59_wrap_string_or_func_with_border()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:121
Called 89 times
Total time:   0.029074
 Self time:   0.002801

count  total (s)   self (s)
   89              0.000109   let l:width = a:ctx.width
   89              0.000163   let l:width -= strdisplaywidth(a:left)
   89              0.000125   let l:width -= strdisplaywidth(a:right)
   89              0.000069   if l:width < 0
                                let l:width = 0
   89              0.000026   endif
                            
   89              0.000099   if type(a:line) is v:t_func
   89              0.000218     let l:ctx = copy(a:ctx)
   89              0.000091     let l:ctx.width = l:width
   89   0.026577   0.000304     let l:result = a:line(l:ctx, a:result)
                            
   89              0.000099     if empty(l:result)
                                  return l:result
   89              0.000030     endif
                            
   89              0.000110     if type(l:result) is v:t_string
                                  let l:chunks = [[wilder#render#truncate_and_pad(l:width, l:result)]]
   89              0.000031     else
   89              0.000076       let l:chunks = l:result
   89              0.000027     endif
                              else
                                if empty(a:line)
                                  return a:line
                                endif
                            
                                let l:chunks = [[wilder#render#truncate_and_pad(l:width, a:line)]]
   89              0.000028   endif
                            
   89              0.000107   let l:border_hl = a:ctx.highlights.border
   89              0.000321   return [[a:left, l:border_hl]] + l:chunks + [[a:right, l:border_hl]]

FUNCTION  <lambda>291()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/mux.vim:46
Called 4 times
Total time:   0.001244
 Self time:   0.000019

count  total (s)   self (s)
                            return s:pre_hook(l:state, ctx)

FUNCTION  <SNR>39_getcompletion()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:777
Called 46 times
Total time:   0.019312
 Self time:   0.001857

count  total (s)   self (s)
                              " For python file completions, use wilder#cmdline#python_get_file_completion()
                              " For help tags, use _wilder_python_get_help_tags()
                              " Else use wilder#cmdline#getcompletion()
   46   0.000349   0.000212   if a:use_python && wilder#cmdline#is_file_expansion(a:res.expand)
                                let l:Completion_func = funcref('wilder#cmdline#python_get_file_completion')
   46              0.000060   elseif a:use_python && a:res.expand ==# 'help' && a:fuzzy
                                let l:Completion_func = {-> {ctx -> _wilder_python_get_help_tags(ctx, &rtp, &helplang)}}
   46              0.000016   else
   46              0.000149     let l:Completion_func = funcref('wilder#cmdline#getcompletion')
   46              0.000017   endif
                            
                              " For tag-regexp, don't do fuzzy completion
                              " If fuzzy, wrap the completion func in wilder#cmdline#get_fuzzy_completion()
   46              0.000062   if a:res.expand ==# 'tags' && a:res.expand_arg[0] ==# '/'
                                let l:Getcompletion = l:Completion_func
   46              0.000028   elseif a:fuzzy
   46              0.000204     let l:Getcompletion = {ctx, x -> wilder#cmdline#get_fuzzy_completion( ctx, x, l:Completion_func, a:fuzzy, a:use_python)}
                              else
                                let l:Getcompletion = l:Completion_func
   46              0.000014   endif
                            
   46   0.018046   0.000728   return wilder#wait(l:Getcompletion(a:ctx, a:res), {ctx, xs -> wilder#resolve(ctx, { 'value': xs, 'pos': a:res.pos, 'data': s:convert_result_to_data(a:res), })})

FUNCTION  <SNR>104_do_offscreen()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:537
Called 71 times
Total time:   0.044945
 Self time:   0.001203

count  total (s)   self (s)
   71              0.000098   let l:offscreen = {}
                            
   71              0.000150   if !has_key(a:current, 'links') | return | endif
                            
                              " prefer to show close
   71              0.000128   if a:current.links.open.lnum < line('w0')
   10              0.000013     let l:offscreen = a:current.links.open
   71              0.000021   endif
   71              0.000116   if a:current.links.close.lnum > line('w$')
    9              0.000012     let l:offscreen = a:current.links.close
   71              0.000020   endif
                            
   71              0.000105   if empty(l:offscreen) | return | endif
                            
   19              0.000018   if a:method ==# 'status'
   19   0.043844   0.000102     call s:do_offscreen_statusline(l:offscreen, 0)
                              elseif a:method ==# 'status_manual'
                                call s:do_offscreen_statusline(l:offscreen, 1)
                              elseif a:method ==# 'popup' && winheight(0) > 1
                                if has('nvim')
                                  call s:do_offscreen_popup_nvim(l:offscreen)
                                elseif exists('*popup_create')
                                  call s:ensure_match_popup()
                                  call s:do_offscreen_popup(l:offscreen)
                                endif
   19              0.000005   endif

FUNCTION  <SNR>58_get_middle_position()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:460
Called 89 times
Total time:   0.000882
 Self time:   0.000882

count  total (s)   self (s)
                              " Use max_height so the prompt does not move around the screen when height
                              " of the candidates changes
   89              0.000067   if a:is_top
                                let l:row = (&lines - 1 - a:dimensions.max_height) / 2
   89              0.000036   else
   89              0.000239     let l:row = (&lines - 1 - a:dimensions.max_height) / 2 + a:dimensions.max_height - a:dimensions.height
   89              0.000032   endif
                            
   89              0.000137   let l:col = (&columns - a:dimensions.width) / 2
                            
   89              0.000099   return [l:row, l:col]

FUNCTION  wilder#render#chunks_displaywidth()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/render.vim:250
Called 1758 times
Total time:   0.023808
 Self time:   0.023808

count  total (s)   self (s)
 1758              0.001466   let l:width = 0
                            
 5953              0.003521   for l:chunk in a:chunks
 4195              0.003504     if !empty(l:chunk)
 4195              0.006108       let l:width += strdisplaywidth(l:chunk[0])
 4195              0.001259     endif
 5953              0.001794   endfor
                            
 1758              0.001035   return l:width

FUNCTION  <lambda>95()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder.vim:198
Called 46 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
                            return x

FUNCTION  <SNR>84_SetLastHeartbeat()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:668
Called 30 times
Total time:   0.002698
 Self time:   0.002341

count  total (s)   self (s)
   30   0.000352   0.000206         call s:SetLastHeartbeatInMemory(a:last_activity_at, a:last_heartbeat_at, a:file)
   30              0.000125         if !isdirectory(s:shared_state_parent_dir)
                                        call mkdir(s:shared_state_parent_dir, "p", "0o700")
   30              0.000012         endif
   30   0.002135   0.001923         call writefile([s:n2s(a:last_activity_at), s:n2s(a:last_heartbeat_at), a:file], s:shared_state_file)

FUNCTION  <SNR>2_LoadIndent()
    Defined: /usr/share/nvim/runtime/indent.vim:13
Called 4 times
Total time:   0.001313
 Self time:   0.001231

count  total (s)   self (s)
    4              0.000008     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    4              0.000001     endif
    4              0.000007     let s = expand("<amatch>")
    4              0.000003     if s != ""
    4              0.000004       if exists("b:did_indent")
                            	unlet b:did_indent
    4              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    8              0.000014       for name in split(s, '\.')
    4   0.000715   0.000633         exe 'runtime! indent/' . name . '.vim'
    4              0.000535         exe 'runtime! indent/' . name . '.lua'
    8              0.000004       endfor
    4              0.000001     endif

FUNCTION  <SNR>117_get_cmdline_from_candidate()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:603
Called 1 time
Total time:   0.000092
 Self time:   0.000050

count  total (s)   self (s)
    1   0.000010   0.000007   let l:candidate = wilder#main#get_candidate({}, s:result, a:index)
                            
    1              0.000001   let l:output = l:candidate
                            
    1              0.000002   if has_key(s:result, 'output')
                                for l:F in s:result.output
                                  if type(l:F) isnot v:t_func
                                    let l:F = function(l:F)
                                  endif
                            
                                  let l:output = l:F({}, l:output, s:result.data)
                                endfor
    1              0.000000   endif
                            
    1              0.000001   let l:cmdline = l:output
    1              0.000002   if has_key(s:result, 'replace')
    2              0.000003     for l:F in s:result.replace
    1              0.000003       if type(l:F) isnot v:t_func
    1              0.000003         let l:F = function(l:F)
    1              0.000000       endif
                            
    1   0.000048   0.000010       let l:cmdline = l:F({ 'cmdline': s:replaced_cmdline, }, l:cmdline, s:result.data)
    2              0.000001     endfor
    1              0.000000   endif
                            
    1              0.000001   return l:cmdline

FUNCTION  <SNR>120_pre_draw()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer.vim:62
Called 979 times
Total time:   0.008566
 Self time:   0.006376

count  total (s)   self (s)
  979              0.001362   if type(a:component) isnot v:t_dict
  890              0.000636     return a:ctx.done
   89              0.000028   endif
                            
   89              0.000124   if has_key(a:component, 'pre_draw')
   89   0.006038   0.003848     return a:component.pre_draw(a:ctx, a:result)
                              endif
                            
                              return a:ctx.done || get(a:component, 'dynamic', 0)

FUNCTION  <SNR>57_scrollbar()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/component/popupmenu_scrollbar.vim:17
Called 86 times
Total time:   0.001548
 Self time:   0.001548

count  total (s)   self (s)
   86              0.000159   let [l:start, l:end] = a:ctx.page
   86              0.000144   let l:num_candidates = len(a:result.value)
   86              0.000086   let l:height = a:ctx.height
                            
   86              0.000085   if l:num_candidates <= l:height
   61              0.000044     if a:state.collapse
   61              0.000042       return []
                                else
                                  return repeat([[a:state.scrollbar_chunk]], l:height)
                                endif
   25              0.000007   endif
                            
   25              0.000092   let l:thumb_start = float2nr(1.0 * l:start * l:height / l:num_candidates)
   25              0.000056   let l:thumb_size = float2nr(1.0 * l:height * l:height / l:num_candidates) + 1
   25              0.000035   let l:thumb_end = l:thumb_start + l:thumb_size
                            
                              " Due to floating point rounding, thumb can exceed height.
                              " Adjust the thumb back 1 row so that visually the thumb size remains fixed.
                              " The position of the thumb will be wrong but the fixed thumb size is more
                              " important.
   25              0.000021   if l:thumb_end > l:height
                                let l:thumb_start -= 1
                                let l:thumb_end -= 1
   25              0.000007   endif
                            
                              " Adjust case where rounding causes l:thumb_size to equal l:height.
   25              0.000019   if l:thumb_size == l:height
                                let l:thumb_size -= 1
                            
                                if l:end < l:num_candidates - 1
                                  let l:thumb_end -= 1
                                else
                                  let l:thumb_start += 1
                                endif
   25              0.000007   endif
                            
   25              0.000032   let l:thumb_chunk = a:state.thumb_chunk
   25              0.000031   let l:scrollbar_chunk = a:state.scrollbar_chunk
                            
   25              0.000077   let l:before_thumb_chunks = repeat([[l:scrollbar_chunk]], l:thumb_start)
   25              0.000061   let l:thumb_chunks = repeat([[l:thumb_chunk]], l:thumb_size)
   25              0.000072   let l:after_thumb_chunks = repeat([[l:scrollbar_chunk]], l:height - l:thumb_end)
                            
   25              0.000071   return l:before_thumb_chunks + l:thumb_chunks + l:after_thumb_chunks

FUNCTION  <SNR>39_is_prefix()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1480
Called 126 times
Total time:   0.000246
 Self time:   0.000246

count  total (s)   self (s)
  126              0.000148   if empty(a:q)
  126              0.000066     return 1
                              endif
                            
                              if len(a:q) > len(a:str)
                                return 0
                              endif
                            
                              return a:str[0 : len(a:q) - 1] ==# a:q

FUNCTION  <SNR>104_close_floating_win()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:899
Called 384 times
Total time:   0.001047
 Self time:   0.001047

count  total (s)   self (s)
  384              0.000584   if !exists('s:float_id')
  384              0.000232     return
                              endif
                              if win_id2win(s:float_id) > 0
                                call s:do_popup_autocmd_leave(s:float_id)
                                call nvim_win_close(s:float_id, 0)
                              endif
                              let s:float_id = 0

FUNCTION  wilder#main#start()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:79
Called 4 times
Total time:   0.000134
 Self time:   0.000077

count  total (s)   self (s)
                              " Workaround for https://github.com/neovim/neovim/issues/15403
    4   0.000088   0.000031   if wilder#main#in_mode() && s:enabled
                                " use timer_start so statusline does not flicker
                                " when using mappings which performs a command
    4              0.000028     call timer_start(0, {-> s:start()})
    4              0.000005   endif

FUNCTION  matchup#loader#bufwinenter()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/loader.vim:99
Called 7 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    7              0.000022   if get(b:, 'matchup_delim_enabled', 0)
    7              0.000004     return
                              endif
                              call matchup#loader#init_buffer()

FUNCTION  matchup#delim#set_invert_skip()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/delim.vim:918
Called 441 times
Total time:   0.000763
 Self time:   0.000763

count  total (s)   self (s)
  441              0.000561   let s:invert_skip = a:val

FUNCTION  wilder#cmdline#getcompletion()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:345
Called 46 times
Total time:   0.014897
 Self time:   0.014286

count  total (s)   self (s)
   46              0.000068   if has_key(a:res, 'completions')
                                return a:res['completions']
   46              0.000013   endif
                            
   46              0.000053   let l:expand_arg = a:res.expand_arg
                            
                              " getting all shellcmds takes a significant amount of time
   46              0.000064   if a:res.expand ==# 'shellcmd' && empty(l:expand_arg)
                                return []
   46              0.000011   endif
                            
   46              0.000096   if a:res.expand ==# 'dir' || a:res.expand ==# 'file' || a:res.expand ==# 'file_in_path' || a:res.expand ==# 'shellcmd'
                            
                                if get(a:res, 'has_wildcard', 0)
                                  let l:xs = expand(l:expand_arg, 0, 1)
                            
                                  if len(l:xs) == 1 && l:xs[0] ==# l:expand_arg
                                    return []
                                  endif
                            
                                  return l:xs
                                endif
                            
                                return getcompletion(l:expand_arg, a:res.expand, 1)
   46              0.000012   endif
                            
   46              0.000066   if a:res.expand ==# 'nothing' || a:res.expand ==# 'unsuccessful'
    2              0.000001     return []
   44              0.000035   elseif a:res.expand ==# 'augroup'
                                return getcompletion(l:expand_arg, 'augroup')
   44              0.000030   elseif a:res.expand ==# 'arglist'
                                return getcompletion(l:expand_arg, 'arglist')
   44              0.000029   elseif a:res.expand ==# 'behave'
                                return getcompletion(l:expand_arg, 'behave')
   44              0.000028   elseif a:res.expand ==# 'buffer'
                                let l:buffers = getcompletion(l:expand_arg, 'buffer')
                                return map(l:buffers, {_, x -> fnamemodify(x, ':~:.')})
   44              0.000034   elseif a:res.expand ==# 'checkhealth'
                                return has('nvim') ? getcompletion(l:expand_arg, 'checkhealth') : []
   44              0.000031   elseif a:res.expand ==# 'color'
                                return getcompletion(l:expand_arg, 'color')
   44              0.000033   elseif a:res.expand ==# 'command'
   23              0.010427     return getcompletion(l:expand_arg, 'command')
   21              0.000015   elseif a:res.expand ==# 'compiler'
                                return getcompletion(l:expand_arg, 'compiler')
   21              0.000014   elseif a:res.expand ==# 'cscope'
                                return getcompletion(a:res.cmdline[a:res.subcommand_start :], 'cscope')
   21              0.000014   elseif a:res.expand ==# 'event'
                                return getcompletion(l:expand_arg, 'event')
   21              0.000018   elseif a:res.expand ==# 'event_and_augroup'
                                return getcompletion(l:expand_arg, 'event') + getcompletion(l:expand_arg, 'augroup')
   21              0.000015   elseif a:res.expand ==# 'expression'
                                return getcompletion(l:expand_arg, 'expression')
   21              0.000015   elseif a:res.expand ==# 'environment'
                                return getcompletion(l:expand_arg, 'environment')
   21              0.000014   elseif a:res.expand ==# 'file_opt'
                                let l:opts = ['bad', 'bin', 'enc', 'ff', 'nobin']
                                if a:res.cmd ==# 'read'
                                  call insert(l:opts, 'edit', 2)
                                endif
                            
                                return filter(l:opts, {_, x -> s:is_prefix(x, l:expand_arg)})
   21              0.000017   elseif a:res.expand ==# 'function'
                                return getcompletion(l:expand_arg, 'function')
   21              0.000014   elseif a:res.expand ==# 'help'
                                return getcompletion(l:expand_arg, 'help')
   21              0.000015   elseif a:res.expand ==# 'highlight'
                                return getcompletion(l:expand_arg, 'highlight')
   21              0.000014   elseif a:res.expand ==# 'history'
                                return getcompletion(l:expand_arg, 'history')
   21              0.000014   elseif a:res.expand ==# 'language'
                                return getcompletion(l:expand_arg, 'locale') + filter(['ctype', 'messages', 'time'], {_, x -> s:is_prefix(x, l:expand_arg)})
   21              0.000017   elseif a:res.expand ==# 'locale'
                                return getcompletion(l:expand_arg, 'locale')
   21              0.000015   elseif a:res.expand ==# 'lua'
                                " Lua completion handled by s:get_lua_completion()
                                return []
   21              0.000014   elseif a:res.expand ==# 'mapping'
                                let l:map_args = get(a:res, 'map_args', {})
                            
                                let l:result = []
                            
                                if l:expand_arg ==# '' || l:expand_arg[0] ==# '<'
                                  for l:map_arg in ['<buffer>', '<unique>', '<nowait>', '<silent>', '<special>', '<script>', '<expr>']
                                    if !has_key(l:map_args, l:map_arg)
                                      call add(l:result, l:map_arg)
                                    endif
                                  endfor
                            
                                  if l:expand_arg[0] ==# '<'
                                    call filter(l:result, {_, x -> s:is_prefix(x, l:expand_arg)})
                                  endif
                                endif
                            
                                if a:res.cmd[-5 :] ==# 'unmap'
                                  let l:mode = a:res.cmd ==# 'unmap' ? '' : a:res.cmd[0]
                                  let l:cmd = 'map'
                                elseif a:res.cmd[-3 :] ==# 'map'
                                  let l:mode = a:res.cmd ==# 'map' || a:res.cmd ==# 'noremap' ? '' : a:res.cmd[0]
                                  let l:cmd = 'map'
                                elseif a:res.cmd[-12 :] ==# 'unabbreviate'
                                  let l:mode = a:res.cmd ==# 'unabbreviate' ? '' : a:res.cmd[0]
                                  let l:cmd = 'abbrev'
                                elseif a:res.cmd ==# 'abbreviate'
                                  let l:mode = ''
                                  let l:cmd = 'abbrev'
                                elseif a:res.cmd[-6 :] ==# 'abbrev'
                                  let l:mode = a:res.cmd ==# 'noreabbrev' ? '' : a:res.cmd[0]
                                  let l:cmd = 'abbrev'
                                else
                                  let l:mode = ''
                                  let l:cmd = 'map'
                                endif
                            
                                let l:lines = split(execute(l:mode . l:cmd . ' ' . join(keys(l:map_args), ' ') . ' ' . l:expand_arg), "\n")
                            
                                if len(l:lines) != 1 || (l:lines[0] !=# 'No mapping found' && l:lines[0] !=# 'No abbreviation found')
                                  for l:line in l:lines
                                    let l:words = split(l:line,'\s\+')
                                    if l:line[0] ==# ' '
                                      let l:map_lhs = l:words[0]
                                    else
                                      let l:map_lhs = l:words[1]
                                    endif
                            
                                    call add(l:result, l:map_lhs)
                                  endfor
                                endif
                            
                                return wilder#uniq_filt(0, 0, l:result)
   21              0.000019   elseif a:res.expand ==# 'mapclear'
                                return s:is_prefix('<buffer>', l:expand_arg) ? ['<buffer>'] : []
   21              0.000016   elseif a:res.expand ==# 'menu'
                                if !has_key(a:res, 'menu_arg')
                                  return []
                                endif
                                return getcompletion(a:res.menu_arg, 'menu')
   21              0.000015   elseif a:res.expand ==# 'messages'
                                return getcompletion(l:expand_arg, 'messages')
   21              0.000014   elseif a:res.expand ==# 'option'
                                return getcompletion(l:expand_arg, 'option')
   21              0.000015   elseif a:res.expand ==# 'option_bool'
                                return filter(wilder#cmdline#set#get_bool_options(), {_, x -> s:is_prefix(x, l:expand_arg)})
   21              0.000017   elseif a:res.expand ==# 'option_old'
                                let l:old_option = eval('&' . a:res.option)
                                return [type(l:old_option) is v:t_string ? l:old_option : string(l:old_option)]
   21              0.000016   elseif a:res.expand ==# 'packadd'
                                return getcompletion(l:expand_arg, 'packadd')
   21              0.000016   elseif a:res.expand ==# 'profile'
   21   0.001162   0.000551     return filter(['continue', 'dump', 'file', 'func', 'pause', 'start'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'ownsyntax'
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'shellcmd'
                                return getcompletion(l:expand_arg, 'shellcmd')
                              elseif a:res.expand ==# 'sign'
                                return getcompletion(a:res.cmdline[a:res.subcommand_start :], 'sign')
                              elseif a:res.expand ==# 'syntax'
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'syntax_subcommand'
                                return filter(['case', 'clear', 'cluster', 'conceal', 'enable', 'foldlevel', 'include', 'iskeyword', 'keyword', 'list', 'manual', 'match', 'off', 'on', 'region', 'reset', 'spell', 'sync'], {_, x -> s:is_prefix(x, l:expand_arg)})
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'syntime'
                                return getcompletion(l:expand_arg, 'syntime')
                              elseif a:res.expand ==# 'user'
                                return getcompletion(l:expand_arg, 'user')
                              elseif a:res.expand ==# 'user_func'
                                let l:functions = getcompletion(l:expand_arg, 'function')
                                let l:functions = filter(l:functions, {_, x -> !(x[0] >= 'a' && x[0] <= 'z')})
                                return map(l:functions, {_, x -> x[-1 :] ==# ')' ? x[: -3] : x[: -2]})
                              elseif a:res.expand ==# 'user_addr_type'
                                return filter(['arguments', 'buffers', 'lines', 'loaded_buffers', 'quickfix', 'tabs', 'windows'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_cmd_flags'
                                return filter(['addr', 'bar', 'buffer', 'complete', 'count', 'nargs', 'range', 'register'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_complete'
                                return filter(['arglist', 'augroup', 'behave', 'buffer', 'checkhealth', 'color', 'command', 'compiler', 'cscope', 'custom', 'customlist', 'dir', 'environment', 'event', 'expression', 'file', 'file_in_path', 'filetype', 'function', 'help', 'highlight', 'history', 'locale', 'mapclear', 'mapping', 'menu', 'messages', 'option', 'packadd', 'shellcmd', 'sign', 'syntax', 'syntime', 'tag', 'tag_listfiles', 'user', 'var'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_nargs'
                                if empty(l:expand_arg)
                                  return ['*', '+', '0', '1', '?']
                                endif
                            
                                if l:expand_arg ==# '*' || l:expand_arg ==# '+' || l:expand_arg ==# '0' || l:expand_arg ==# '1' || l:expand_arg ==# '?'
                                  return [l:expand_arg]
                                endif
                            
                                return []
                              elseif a:res.expand ==# 'user_commands'
                                return filter(getcompletion(l:expand_arg, 'command'), {_, x -> x[0] >=# 'A' && x[0] <=# 'Z'})
                              elseif a:res.expand ==# 'tags'
                                if a:ctx.session_id > s:cached_tags_session_id
                                  let s:cached_tags_session_id = a:ctx.session_id
                                  let s:cached_tags = {}
                                endif
                            
                                let l:arg = a:res.expand_arg
                                if l:arg[0] ==# '/'
                                  let l:taglist_arg = l:arg[1:]
                                else
                                  let l:taglist_arg = l:arg
                                endif
                            
                                if empty(l:taglist_arg)
                                  let l:taglist_arg = '.'
                                endif
                            
                                if !has_key(s:cached_tags, l:taglist_arg)
                                  let s:cached_tags[l:taglist_arg] = map(taglist(l:taglist_arg), {_, x -> x.name})
                                endif
                            
                                return copy(s:cached_tags[l:taglist_arg])
                              elseif a:res.expand ==# 'var'
                                return getcompletion(l:expand_arg, 'var')
                              endif
                            
                              if !exists('s:has_get_completion_cmdline')
                                try
                                  " cmdline completion only available in Vim 8.2+
                                  call getcompletion('foo', 'cmdline')
                                  let s:has_getcompletion_cmdline = 1
                                catch
                                  let s:has_getcompletion_cmdline = 0
                                endtry
                              endif
                            
                              " fallback to cmdline getcompletion
                              if s:has_getcompletion_cmdline
                                return getcompletion(a:res.cmdline, 'cmdline')
                              endif
                            
                              return []

FUNCTION  <SNR>59_make_top_or_bottom_border()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:155
Called 267 times
Total time:   0.011475
 Self time:   0.011475

count  total (s)   self (s)
  267              0.000569   let l:left = a:is_top ? a:border_chars[0] : a:border_chars[5]
  267              0.000463   let l:middle = a:is_top ? a:border_chars[1] : a:border_chars[6]
  267              0.000397   let l:right = a:is_top ? a:border_chars[2] : a:border_chars[7]
                            
  267              0.000508   let l:left_width = strdisplaywidth(l:left)
  267              0.000436   let l:middle_width = strdisplaywidth(l:middle)
  267              0.000396   let l:right_width = strdisplaywidth(l:right)
                            
  267              0.000508   let l:expected_middle_width = a:ctx.width - l:left_width - l:right_width
  267              0.000410   let l:middle_repeat =  l:expected_middle_width / l:middle_width
  267              0.000221   if l:middle_repeat < 0
                                let l:middle_repeat = 0
  267              0.000081   endif
                            
  267              0.000606   let l:middle_str = repeat(l:middle, l:middle_repeat)
  267              0.001585   let l:actual_middle_width = strdisplaywidth(l:middle_str)
  267              0.000282   if l:actual_middle_width < l:expected_middle_width
                                let l:middle_chars = split(l:middle, '\zs')
                            
                                let l:i = 0
                                for l:char in l:middle_chars
                                  let l:new_middle_width = l:actual_middle_width + strdisplaywidth(l:char)
                            
                                  if l:new_middle_width > l:expected_middle_width
                                    break
                                  endif
                            
                                  let l:middle_str .= l:char
                                  let l:actual_middle_width = l:new_middle_width
                                endfor
                            
                                let l:middle_str .= repeat(' ', l:expected_middle_width - l:actual_middle_width)
  267              0.000084   endif
                            
  267              0.000329   let l:border_hl = a:ctx.highlights.border
  267              0.000437   let l:middle_hl = a:is_top ? l:border_hl : a:ctx.highlights.bottom_border
                            
  267              0.000816   return [[l:left, l:border_hl], [l:middle_str, l:middle_hl], [l:right, l:border_hl]]

FUNCTION  <lambda>91()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 46 times
Total time:   0.000801
 Self time:   0.000198

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  wilder#pipeline#wait()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipeline.vim:166
Called 46 times
Total time:   0.000258
 Self time:   0.000258

count  total (s)   self (s)
   46              0.000119   let l:state = { 'f': a:f, 'on_finish': a:on_finish, }
                            
   46              0.000111   return {ctx -> s:wait_start(l:state, ctx)}

FUNCTION  <lambda>92()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 46 times
Total time:   0.001022
 Self time:   0.000137

count  total (s)   self (s)
                            return wilder#cmdline#parse(x)

FUNCTION  matchup#delim#get_matching()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/delim.vim:65
Called 74 times
Total time:   0.104063
 Self time:   0.010864

count  total (s)   self (s)
   74              0.000248   if empty(a:delim) || !has_key(a:delim, 'lnum') | return {} | endif
                            
   74              0.000211   let l:opts = a:0 && type(a:1) == type({}) ? a:1 : {}
   74              0.000145   let l:stopline = get(l:opts, 'stopline', s:stopline)
                            
                              " get all the matching position(s)
                              " *important*: in the case of mid, we search up before searching down
                              " this gives us a context object which we use for the other side
                              " TODO: what if no open is found here?
   74              0.000067   let l:matches = []
   74   0.000379   0.000265   let l:save_pos = matchup#pos#get_cursor()
  154              0.000384   for l:down in {'open': [1], 'close': [0], 'mid': [0,1]}[a:delim.side]
   80   0.001611   0.000313     call matchup#pos#set_cursor(a:delim)
                            
                                " second iteration: [] refers to the current match
   80              0.000090     if !empty(l:matches)
    6              0.000009       call add(l:matches, [])
   80              0.000027     endif
                            
   80   0.090957   0.000601     let l:res = a:delim.get_matching(l:down, l:stopline)
   80              0.000089     if empty(l:res)
   80              0.000136     elseif l:res[0][1] > 0
   80              0.000145       call extend(l:matches, l:res)
                                elseif l:down
                                  let l:matches = []
   80              0.000025     endif
  154              0.000093   endfor
   74   0.001815   0.000383   call matchup#pos#set_cursor(l:save_pos)
                            
   74              0.000087   if a:delim.side ==# 'open'
   22              0.000039     call insert(l:matches, [])
   74              0.000027   endif
   74              0.000058   if a:delim.side ==# 'close'
   46              0.000063     call add(l:matches, [])
   74              0.000024   endif
                            
                              " create the match result(s)
   74              0.000079   let l:matching_list = []
  230              0.000266   for l:i in range(len(l:matches))
  156              0.000213     if empty(l:matches[l:i])
   74              0.000114       let a:delim.match_index = l:i
   74              0.000102       call add(l:matching_list, a:delim)
   74              0.000042       continue
   82              0.000028     end
                            
   82              0.000163     let [l:match, l:lnum, l:cnum] = l:matches[l:i]
                            
   82              0.000304     let l:matching = copy(a:delim)
   82              0.000166     let l:matching.class = copy(a:delim.class)
                            
   82              0.000076     let l:matching.lnum = l:lnum
   82              0.000061     let l:matching.cnum = l:cnum
   82              0.000076     let l:matching.match = l:match
   82              0.000200     let l:matching.side = l:i == 0 ? 'open' : l:i == len(l:matches)-1 ? 'close' : 'mid'
   82              0.000098     let l:matching.class[1] = '__mid__'
   82              0.000116     let l:matching.match_index = l:i
                            
   82              0.000121     call add(l:matching_list, l:matching)
  156              0.000111   endfor
                            
                              " set up links between matches
  230              0.000209   for l:i in range(len(l:matching_list))
  156              0.000168     let l:c = l:matching_list[l:i]
  156              0.000171     let l:c.links = {}
  156              0.000330     let l:c.links.next = l:matching_list[(l:i+1) % len(l:matching_list)]
  156              0.000193     let l:c.links.prev = l:matching_list[l:i-1]
  156              0.000149     let l:c.links.open = l:matching_list[0]
  156              0.000166     let l:c.links.close = l:matching_list[-1]
  230              0.000095   endfor
                            
                              " allow empty marker ending
                              " TODO: use a sentinel value instead of empty
   74              0.000169   if len(l:matching_list) >= 2 && empty(l:matching_list[-1].match)
                                if get(l:opts, 'highlighting', 0) && len(l:matching_list) <= 2
                                  return []
                                endif
                                let l:matching_list[0].links.prev = l:matching_list[-2]
                                let l:matching_list[-2].links.next = l:matching_list[0]
   74              0.000022   endif
                            
   74              0.000060   return l:matching_list

FUNCTION  <lambda>97()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 46 times
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  <lambda>98()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 46 times
Total time:   0.000388
 Self time:   0.000242

count  total (s)   self (s)
                            return l:sort_buffers_lastused ? s:sort_buffers_lastused(ctx, xs, data) : xs

FUNCTION  wilder#cmdline#get_fuzzy_completion()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:261
Called 46 times
Total time:   0.016443
 Self time:   0.001442

count  total (s)   self (s)
                              " Use tag-regexp to get fuzzy completions from taglist()
   46              0.000051   if a:res.expand ==# 'tags'
                                let l:fuzzy_char = get(a:res, 'fuzzy_char', '')
                            
                                if empty(l:fuzzy_char)
                                  let a:res.expand_arg = '.'
                                else
                                  let a:res.expand_arg = '/'
                                  if toupper(l:fuzzy_char) !=# l:fuzzy_char
                                    let a:res.expand_arg .= '\c'
                                  endif
                            
                                  if a:fuzzy_mode == 1
                                    let a:res.expand_arg .= '^'
                                  endif
                            
                                  let a:res.expand_arg .= l:fuzzy_char
                                endif
                            
                                return a:getcompletion(a:ctx, a:res)
   46              0.000014   endif
                            
                              " If argument is empty, use normal completions
                              " Don't fuzzy complete for vim help since a maximum of 300 help tags are returned
   46              0.000111   if a:res.pos == len(a:res.cmdline) || (a:res.expand ==# 'help' && !a:use_python)
    7   0.002722   0.000030     return a:getcompletion(a:ctx, a:res)
   39              0.000011   endif
                            
   39              0.000080   let l:fuzzy_char = get(a:res, 'fuzzy_char', '')
                            
                              " Keep leading . in file expansion to search hidden directories
   39   0.000314   0.000211   if a:fuzzy_mode == 2 && !(wilder#cmdline#is_file_expansion(a:res.expand) && l:fuzzy_char ==# '.')
   39              0.000033     let l:fuzzy_char = ''
   39              0.000012   endif
                            
   39              0.000064   if toupper(l:fuzzy_char) ==# l:fuzzy_char
   39              0.000061     let a:res.expand_arg = a:res.expand_arg . l:fuzzy_char
   39   0.012360   0.000154     return a:getcompletion(a:ctx, a:res)
                              endif
                            
                              let l:lower_res = copy(a:res)
                              let l:lower_res.expand_arg = a:res.expand_arg . l:fuzzy_char
                            
                              let l:upper_res = copy(a:res)
                              let l:upper_res.expand_arg = a:res.expand_arg . toupper(l:fuzzy_char)
                            
                              return wilder#wait(a:getcompletion(a:ctx, l:upper_res), {ctx, upper_xs -> wilder#resolve(ctx, wilder#wait(a:getcompletion(ctx, l:lower_res), {ctx, lower_xs -> wilder#resolve(ctx, wilder#uniq_filt(0, 0, lower_xs + upper_xs))}))})

FUNCTION  <SNR>63_set_option()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:230
Called 97 times
Total time:   0.001306
 Self time:   0.001141

count  total (s)   self (s)
   97              0.000106   if self.state.window_state ==# 'hidden'
                                return
   97              0.000027   endif
                            
   97              0.000077   if self.state.window_state ==# 'pending'
                                let self.state.options[a:option] = a:value
                                return
   97              0.000024   endif
                            
   97   0.000830   0.000666   call nvim_win_set_option(self.state.win, a:option, a:value)

FUNCTION  <SNR>84_OrderTime()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:633
Called 25 times
Total time:   0.000204
 Self time:   0.000204

count  total (s)   self (s)
                                    " Add a milisecond to a:time.
                                    " Time prevision doesn't matter, but order of heartbeats does.
   25              0.000048         if !(a:time_str =~ "\.")
                                        let millisecond = s:n2s(a:loop_count)
                                        while strlen(millisecond) < 6
                                            let millisecond = '0' . millisecond
                                        endwhile
                                        return a:time_str . '.' . millisecond
   25              0.000008         endif
   25              0.000016         return a:time_str

FUNCTION  <SNR>84_IsWindows()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:445
Called 24 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
   24              0.000058         if has('win32')
                                        return s:true
   24              0.000009         endif
   24              0.000017         return s:false

FUNCTION  <SNR>84_SetupConfigFile()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:277
Called 12 times
Total time:   0.000241
 Self time:   0.000241

count  total (s)   self (s)
   12              0.000017         if !s:config_file_already_setup
                            
                                        " Create config file if does not exist
                                        if !filereadable(s:config_file)
                                            call writefile(s:default_configs, s:config_file)
                                        endif
                            
                                        " Make sure config file has api_key
                                        let found_api_key = s:false
                                        if !empty(s:GetIniSetting('settings', 'api_key')) || !empty(s:GetIniSetting('settings', 'apikey'))
                                            let found_api_key = s:true
                                        endif
                            
                                        if !found_api_key
                                            let vault_cmd = s:GetIniSetting('settings', 'api_key_vault_cmd')
                                            if !empty(vault_cmd) && !empty(s:Chomp(system(vault_cmd)))
                                                let found_api_key = s:true
                                            endif
                                        endif
                            
                                        if !found_api_key
                                            call s:PromptForApiKey()
                                            echo "[WakaTime] Setup complete! Visit https://wakatime.com to view your coding activity."
                                        endif
                            
                                        let s:config_file_already_setup = s:true
   12              0.000006         endif

FUNCTION  wilder#cmdline#main#is_whitespace()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline/main.vim:678
Called 103 times
Total time:   0.000431
 Self time:   0.000431

count  total (s)   self (s)
  103              0.000202   let l:nr = char2nr(a:char)
  103              0.000190   return a:char ==# ' ' || l:nr >= 9 && l:nr <= 13

FUNCTION  <SNR>61_make_page()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:195
Called 99 times
Total time:   0.003929
 Self time:   0.003221

count  total (s)   self (s)
   99              0.000152   if empty(a:result.value)
   10              0.000011     return [-1, -1]
   89              0.000032   endif
                            
   89              0.000103   let l:page = a:state.page
   89              0.000100   let l:selected = a:ctx.selected
                              " Adjust -1 (unselected) to show the top of the list.
   89              0.000141   let l:selected = l:selected == -1 ? 0 : l:selected
                            
                              " Adjust previous page.
   89              0.000141   if l:page != [-1, -1]
   45              0.000092     if l:page[0] > len(a:result.value)
                                  let l:page = [-1, -1]
   45              0.000078     elseif l:page[1] > len(a:result.value)
                                  let l:page[1] = len(a:result.value) - 1
   45              0.000019     endif
   89              0.000028   endif
                            
   89              0.000101   if l:page != [-1, -1]
                                " Selected is within current page, reuse the page.
   45              0.000110     if l:selected != -1 && l:selected >= l:page[0] && l:selected <= l:page[1]
   45              0.000038       return l:page
                                endif
                            
                                " Scroll the page forward.
                                if a:ctx.direction >= 0 && l:page[1] < l:selected
                                  " calculate distance moved.
                                  let l:moved = l:selected - l:page[1]
                                  return [l:page[0] + l:moved, l:selected]
                                endif
                            
                                " Scroll the page backward.
                                if a:ctx.direction < 0 && l:page[0] > l:selected
                                  " calculate distance moved.
                                  let l:moved = l:page[0] - l:selected
                                  return [l:selected, l:page[1] - l:moved]
                                endif
   44              0.000012   endif
                            
                              " Otherwise make a new page.
                            
   44   0.000707   0.000182   let l:max_height = a:state.get_max_height(a:ctx, a:result)
   44   0.000329   0.000147   let l:min_height = a:state.get_min_height(a:ctx, a:result)
   44              0.000040   if l:max_height < l:min_height
                                let l:max_height = l:min_height
   44              0.000012   endif
   44              0.000073   let l:max_height -= len(a:state.top)
   44              0.000057   let l:max_height -= len(a:state.bottom)
                              " Assume the worst case scenario that the cursor is on the top row of the
                              " cmdline.
   44              0.000112   let l:max_height = min([l:max_height, &lines - &cmdheight - 1])
                            
                              " Page starts at selected.
   44              0.000036   if a:ctx.direction >= 0
   44              0.000043     let l:start = l:selected
                            
                                " Try to include all candidates after selected.
   44              0.000072     let l:height = len(a:result.value) - l:selected
                            
   44              0.000039     if l:height > l:max_height
   13              0.000010       let l:height = l:max_height
   44              0.000013     endif
                            
   44              0.000057     return [l:start, l:start + l:height - 1]
                              endif
                            
                              " Page ends at selected.
                              let l:end = l:selected
                            
                              " Try to include all candidates before selected.
                              let l:height = l:selected
                            
                              if l:height > l:max_height
                                let l:height = l:max_height
                              endif
                            
                              return [l:end - l:height + 1, l:end]

FUNCTION  <SNR>110_anchor_regex()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/delim.vim:959
Called 718 times
Total time:   0.003527
 Self time:   0.003527

count  total (s)   self (s)
  718              0.000480   if a:method
                                " trick to re-match at a particular column
                                " handles the case where pattern contains \ze, \zs, and assertions
                                " but doesn't work with overlapping matches and is possibly slower
                                return '\%<'.(a:cnum+1).'c\%('.a:re.'\)\%>'.(a:cnum).'c'
  718              0.000226   else
                                " fails to match with \zs
  718              0.001196     return '\%'.(a:cnum).'c\%('.a:re.'\)'
                              endif

FUNCTION  wilder#render#draw_candidate()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/render.vim:10
Called 584 times
Total time:   0.014516
 Self time:   0.009969

count  total (s)   self (s)
  584   0.003244   0.002408   let l:x = wilder#main#get_candidate(a:ctx, a:result, a:i)
                            
  584              0.000712   if has_key(a:result, 'draw')
                                let l:ctx = { 'i': a:i, 'selected': a:ctx.selected == a:i, }
                            
                                for l:F in a:result.draw
                                  if type(l:F) isnot v:t_func
                                    let l:F = function(l:F)
                                  endif
                            
                                  let l:x = l:F(l:ctx, l:x, get(a:result, 'data', {}))
                                endfor
  584              0.000165   endif
                            
  584   0.005873   0.002162   return wilder#render#to_printable(l:x)

FUNCTION  wilder#lua#call_wrapped_function()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/lua.vim:44
Called 3314 times
Total time:   0.571518
 Self time:   0.028506

count  total (s)   self (s)
 3314              0.006959   let l:F = s:functions[a:index]
 3314   0.155781   0.073176   let l:Result = call(l:F, a:000)
 3314   0.225840   0.011931   return wilder#lua#wrap(l:Result)

FUNCTION  <SNR>52_spin()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/component/spinner.vim:15
Called 3 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                              " Result has finished.
    3              0.000002   if a:done
    2              0.000002     let a:state.was_done = 1
    2              0.000001     let a:state.index = -1
    2              0.000002     return [a:state.index, -1]
    1              0.000000   endif
                            
                              " Previous result was finished. Start spinner again.
    1              0.000001   if a:state.was_done
    1              0.000001     let a:state.was_done = 0
    1              0.000001     let a:state.index = 0
    1              0.000002     let a:state.start_time = reltime()
    1              0.000000   endif
                            
    1              0.000003   let l:elapsed = reltimefloat(reltime(a:state.start_time)) * 1000
                            
                              " Calculate time to next frame. Either wait for delay to be over or wait for
                              " next frame.
    1              0.000001   if l:elapsed < a:state.delay
    1              0.000002     let l:wait_time = a:state.delay - l:elapsed + 1
                              else
                                let l:elapsed_minus_delay = l:elapsed - a:state.delay
                                let l:wait_time = a:state.interval - fmod(l:elapsed_minus_delay, a:state.interval) + 1
    1              0.000000   endif
                            
    1              0.000002   let l:wait_time = float2nr(l:wait_time)
                            
    1              0.000002   if a:state.delay > 0 && l:elapsed < a:state.delay
    1              0.000001     let a:state.index = -1
    1              0.000001     return [a:state.index, l:wait_time]
                              endif
                            
                              let l:elapsed_minus_delay = l:elapsed - a:state.delay
                              let a:state.index = l:elapsed_minus_delay / a:state.interval
                            
                              let a:state.index = float2nr(fmod(a:state.index, a:state.num_frames))
                              return [a:state.index, l:wait_time]

FUNCTION  <SNR>63__open_win()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:82
Called 4 times
Total time:   0.005420
 Self time:   0.000505

count  total (s)   self (s)
                              " window might have been open or closed already.
    4              0.000004   if self.state.window_state !=# 'pending'
                                return
    4              0.000001   endif
                            
                              " Fix E5555 when re-showing wilder when inccommand is cancelled.
    4              0.000018   let l:buf = has('nvim-0.6') && !has('nvim-0.7') ? 0 : self.state.buf
                            
    4              0.000019   let l:win_opts = { 'relative': 'editor', 'height': 1, 'width': 1, 'row': &lines - 1, 'col': 0, 'focusable': 0, }
                            
    4              0.000006   if has('nvim-0.5.1')
    4              0.000006     let l:win_opts.zindex = self.state.zindex
    4              0.000001   endif
                            
    4   0.004959   0.000179   let self.state.win = nvim_open_win(l:buf, 0, l:win_opts)
                            
    4              0.000007   let self.state.window_state = 'showing'
                            
    4              0.000016   if has('nvim-0.6') && !has('nvim-0.7')
                                try
                                  call self._set_buf()
                                catch
                                  call timer_start(0, {-> self._set_buf()})
                                endtry
    4              0.000002   else
    4              0.000067     call nvim_win_set_config(self.state.win, { 'style': 'minimal', })
    4              0.000002   endif
                            
    4   0.000114   0.000026   call self.set_option('winhighlight', 'Search:None,IncSearch:None,Normal:' . self.state.normal_highlight)
    4              0.000006   if self.state.pumblend != -1
                                call self.set_option('winblend', self.state.pumblend)
    4              0.000001   else
    4   0.000064   0.000017     call self.set_option('winblend', &pumblend)
    4              0.000002   endif
                            
    4              0.000004   if self.state.firstline isnot -1
                                call nvim_win_set_cursor(self.state.win, [self.state.firstline, 0])
    4              0.000001   endif
                            
    4              0.000003   if self.state.dimensions isnot -1
                                let [l:row, l:col, l:height, l:width] = self.state.dimensions
                                call nvim_win_set_config(self.state.win, { 'relative': 'editor', 'row': l:row, 'col': l:col, 'height': l:height, 'width': l:width, })
    4              0.000001   endif
                            
    4              0.000010   for l:option in keys(self.state.options)
                                let l:value = self.state.options[l:option]
                                call nvim_win_set_option(self.state.win, l:option, l:value)
    4              0.000002   endfor
                            
    4              0.000005   let self.state.firstline = -1
    4              0.000003   let self.state.dimensions = -1
    4              0.000005   let self.state.options = {}

FUNCTION  <SNR>55_devicons()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/component/popupmenu_devicons.vim:24
Called 86 times
Total time:   0.000836
 Self time:   0.000836

count  total (s)   self (s)
   86              0.000146   if !has_key(a:result, 'data')
                                return ''
   86              0.000029   endif
                            
   86              0.000186   let l:expand = get(a:result.data, 'cmdline.expand', '')
                            
   86              0.000255   if l:expand !=# 'file' && l:expand !=# 'file_in_path' && l:expand !=# 'dir' && l:expand !=# 'shellcmd' && l:expand !=# 'buffer'
   86              0.000051     return ''
                              endif
                            
                              let l:session_id = a:ctx.session_id
                              if a:state.session_id != l:session_id
                                call a:state.cache.clear()
                                let a:state.created_hls = {}
                                let a:state.session_id = l:session_id
                              endif
                            
                              let l:slash = !has('win32') && !has('win64') ? '/' : &shellslash ? '/' : '\'
                            
                              let [l:start, l:end] = a:ctx.page
                            
                              let l:rows = repeat([0], l:end - l:start + 1)
                            
                              if !has_key(a:state, 'get_icon')
                                let a:state.get_icon = s:get_icon_func()
                              endif
                            
                              if a:state.get_icon is v:null
                                return []
                              endif
                            
                              if !has_key(a:state, 'get_hl')
                                let a:state.get_hl = s:get_hl_func()
                              endif
                            
                              let l:i = l:start
                              while l:i <= l:end
                                let l:index = l:i - l:start
                            
                                let l:x = wilder#main#get_candidate(a:ctx, a:result, l:i)
                            
                                if a:state.cache.has_key(l:x)
                                  let l:rows[l:index] = a:state.cache.get(l:x)
                            
                                  let l:i += 1
                                  continue
                                endif
                            
                                let l:is_dir = l:x[-1:] ==# l:slash || l:x[-1:] ==# '/'
                            
                                let l:icon = a:state.get_icon(a:ctx, l:x, l:is_dir)
                                let l:icon_width = strdisplaywidth(l:icon)
                                if l:icon_width < a:state.min_width
                                  let l:icon .= repeat(' ', a:state.min_width - l:icon_width)
                                endif
                            
                                if a:state.get_hl is v:null
                                  let l:chunks = [[a:state.left_padding . l:icon . a:state.right_padding]]
                                else
                                  let l:hl = a:state.get_hl(a:ctx, l:x, l:is_dir, l:icon)
                            
                                  if !has_key(a:state.created_hls, l:hl)
                                    let l:guifg = s:get_guifg(l:hl)
                                    let l:default_hl = s:make_temp_hl(l:hl, a:ctx.highlights['default'], l:guifg)
                            
                                    if a:state.combine_selected_hl
                                      let l:selected_hl = s:make_temp_hl(l:hl . '_Selected', a:ctx.highlights['selected'], l:guifg)
                                    else
                                      let l:selected_hl = a:ctx.highlights['selected']
                                    endif
                            
                                    let a:state.created_hls[l:hl] = [l:default_hl, l:selected_hl]
                                  endif
                            
                                  let [l:default_hl, l:selected_hl] = a:state.created_hls[l:hl]
                                  let l:chunks = [[a:state.left_padding], [l:icon, l:default_hl, l:selected_hl], [a:state.right_padding]]
                                endif
                            
                                call a:state.cache.set(l:x, l:chunks)
                            
                                let l:rows[l:index] = l:chunks
                            
                                let l:i += 1
                              endwhile
                            
                              let l:height = a:ctx.height
                              let l:width = empty(l:rows) ? 0 : wilder#render#chunks_displaywidth(l:rows[0])
                              let l:empty_row = [[repeat(' ', l:width)]]
                              let l:rows += repeat([l:empty_row], l:height - len(l:rows))
                            
                              return l:rows

FUNCTION  better_escape#CharAtIdx()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/better-escape.vim/autoload/better_escape.vim:41
Called 3 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                              " Get char at idx from str. Note that this is based on character index
                              " instead of the byte index.
    3              0.000013   return strcharpart(a:str, a:idx, 1)

FUNCTION  matchup#util#append_match_words()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/util.vim:113
Called 3 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    3              0.000005   if !exists('b:match_words')
                                let b:match_words = ''
    3              0.000001   endif
                            
    3              0.000008   if len(b:match_words) && b:match_words[-1] !=# ',' && a:str[0] !=# ','
    3              0.000003     let b:match_words .= ','
    3              0.000001   endif
    3              0.000003   let b:match_words .= a:str

FUNCTION  wilder#main#stop()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:172
Called 4 times
Total time:   0.001831
 Self time:   0.000443

count  total (s)   self (s)
    4              0.000012   let s:select_next = 0
                            
    4              0.000005   if !s:active
                                return
    4              0.000002   endif
                            
    4              0.000014   if exists('#WilderCmdlineChanged')
    4              0.000007     augroup WilderCmdlineChanged
    4              0.000158       autocmd!
    4              0.000002     augroup END
    4              0.000021     augroup! WilderCmdlineChanged
    4              0.000002   endif
                            
    4              0.000007   if s:timer isnot v:null
                                call timer_stop(s:timer)
                                let s:timer = v:null
    4              0.000002   endif
                            
    4              0.000006   if exists('#WilderCmdlineLeave')
    4              0.000002     augroup WilderCmdlineLeave
    4              0.000020       autocmd!
    4              0.000002     augroup END
    4              0.000013     augroup! WilderCmdlineLeave
    4              0.000001   endif
                            
    4              0.000005   if exists('#WilderVimResized')
    4              0.000002     augroup WilderVimResized
    4              0.000016       autocmd!
    4              0.000001     augroup END
    4              0.000011     augroup! WilderVimResized
    4              0.000001   endif
                            
    4              0.000005   let s:active = 0
    4              0.000016   let s:result = {'value': [], 'data': {}}
    4              0.000004   let s:selected = -1
    4              0.000004   let s:selection_was_made = 0
    4              0.000004   let s:clear_previous_renderer_state = 0
    4              0.000005   let s:completion_stack = []
    4              0.000004   let s:previous_cmdline = v:null
    4              0.000003   let s:completion = v:null
    4              0.000003   let s:error = v:null
    4              0.000003   let s:replaced_cmdline = v:null
    4              0.000005   let s:completion_from_reject_completion = v:null
                            
    4              0.000003   if !s:hidden
    4   0.001409   0.000021     call s:post_hook()
    4              0.000001   endif
                            
    4              0.000004   let s:hidden = 0

FUNCTION  <SNR>63_hide()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:165
Called 4 times
Total time:   0.000282
 Self time:   0.000282

count  total (s)   self (s)
    4              0.000014   if self.state.win == -1 || self.state.window_state ==# 'hidden'
                                return
    4              0.000001   endif
                            
    4              0.000004   if self.state.window_state ==# 'pending'
                                let self.state.win = -1
                                let self.state.window_state = 'hidden'
                                return
    4              0.000001   endif
                            
    4              0.000007   if getcmdwintype() ==# ''
    4              0.000003     try
    4              0.000169       call nvim_win_close(self.state.win, 1)
                                catch
                                  let l:win = self.state.win
                                  call timer_start(0, {-> nvim_win_close(l:win, 1)})
    4              0.000003     endtry
                              else
                                " cannot call nvim_win_close() while cmdline-window is open
                                " make the window as small as possible and hide it with winblend = 100
                                let l:win = self.state.win
                                call self.delete_all_lines()
                                call self.move(&lines, &columns, 1, 1)
                                call self.set_option('winblend', 100)
                                execute 'autocmd CmdWinLeave * ++once call timer_start(0, {-> nvim_win_close(' . l:win . ', 0)})'
    4              0.000002   endif
                            
    4              0.000005   let self.state.win = -1
    4              0.000005   let self.state.window_state = 'hidden'

FUNCTION  <lambda>236()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:843
Called 136 times
Total time:   0.001535
 Self time:   0.000690

count  total (s)   self (s)
                            return s:clamp(float2nr(l:percent * (&lines - 1)), a:is_height)

FUNCTION  <lambda>237()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:832
Called 146 times
Total time:   0.000728
 Self time:   0.000461

count  total (s)   self (s)
                            return s:clamp(a:opt, a:is_height)

FUNCTION  <lambda>238()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:845
Called 89 times
Total time:   0.001025
 Self time:   0.000446

count  total (s)   self (s)
                            return s:clamp(float2nr(l:percent * &columns), a:is_height)

FUNCTION  <lambda>239()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:845
Called 89 times
Total time:   0.000806
 Self time:   0.000312

count  total (s)   self (s)
                            return s:clamp(float2nr(l:percent * &columns), a:is_height)

FUNCTION  <SNR>40_has_key()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cache.vim:19
Called 826 times
Total time:   0.001784
 Self time:   0.001784

count  total (s)   self (s)
  826              0.001584   return has_key(self['_cache'], a:key)

FUNCTION  <SNR>56_buffer_status()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/component/popupmenu_buffer_flags.vim:51
Called 86 times
Total time:   0.000712
 Self time:   0.000712

count  total (s)   self (s)
   86              0.000138   if !has_key(a:result, 'data')
                                return ''
   86              0.000027   endif
                            
   86              0.000171   let l:expand = get(a:result.data, 'cmdline.expand', '')
                            
   86              0.000170   if l:expand !=# 'buffer' && l:expand !=# 'file' && l:expand !=# 'file_in_path'
   86              0.000050     return ''
                              endif
                            
                              let l:flags = a:state.flags
                            
                              let l:session_id = a:ctx.session_id
                              if a:state.session_id != l:session_id
                                call a:state.cache.clear()
                                let a:state.session_id = l:session_id
                              endif
                            
                              let [l:start, l:end] = a:ctx.page
                              let l:rows = repeat([0], l:end - l:start + 1)
                            
                              let l:hl = get(a:state, 'hl', a:ctx.highlights['default'])
                              let l:selected_hl = get(a:state, 'selected_hl', a:ctx.highlights['selected'])
                            
                              let l:width = s:get_strdisplaywidth(l:flags, a:state.icon_width)
                              let l:empty_chunks = [[repeat(' ', l:width), l:hl, l:selected_hl]]
                            
                              let l:i = l:start
                              while l:i <= l:end
                                let l:index = l:i - l:start
                            
                                let l:key = wilder#main#get_candidate(a:ctx, a:result, l:i)
                            
                                if a:state.cache.has_key(l:key)
                                  let l:rows[l:index] = a:state.cache.get(l:key)
                                  let l:i += 1
                                  continue
                                endif
                            
                                let l:x = fnamemodify(l:key, ':~')
                            
                                let l:bufnr = bufnr('^' . l:x . '$')
                            
                                if l:bufnr == -1
                                  call a:state.cache.set(l:key, l:empty_chunks)
                                  let l:rows[l:index] = l:empty_chunks
                                  let l:i += 1
                                  continue
                                endif
                            
                                let l:status = ''
                            
                                let l:j = 0
                                while l:j < len(l:flags)
                                  let l:flag = l:flags[l:j]
                            
                                  if l:flag ==# '1'
                                    let l:status .= repeat(' ', a:state.icon_width['1'] - strdisplaywidth(l:bufnr))
                                  endif
                            
                                  let l:status .= s:get_str(l:flag, l:bufnr, a:state.icons, a:state.spacing)
                            
                                  let l:chunks = [[l:status, l:hl, l:selected_hl]]
                                  let l:rows[l:index] = l:chunks
                            
                                  let l:j += 1
                                endwhile
                            
                                call a:state.cache.set(l:key, l:chunks)
                            
                                let l:i += 1
                              endwhile
                            
                              let l:height = a:ctx.height
                              let l:width = empty(l:rows) ? 0 : wilder#render#chunks_displaywidth(l:rows[0])
                              let l:empty_row = [[repeat(' ', l:width)]]
                              let l:rows += repeat([l:empty_row], l:height - len(l:rows))
                            
                              return l:rows

FUNCTION  <lambda>37()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 46 times
Total time:   0.000805
 Self time:   0.000196

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  <lambda>241()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlighter.vim:1
Called 302 times
Total time:   0.066796
 Self time:   0.001170

count  total (s)   self (s)
                            return s:apply_first(a:highlighters, ctx, x, data)

FUNCTION  <lambda>242()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 99 times
Total time:   0.028325
 Self time:   0.000440

count  total (s)   self (s)
                            return s:render(l:state, ctx, result)

FUNCTION  <lambda>243()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 4 times
Total time:   0.000825
 Self time:   0.000019

count  total (s)   self (s)
                            return s:pre_hook(l:state, ctx)

FUNCTION  <lambda>244()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 4 times
Total time:   0.001049
 Self time:   0.000023

count  total (s)   self (s)
                            return s:post_hook(l:state, ctx)

FUNCTION  <SNR>48_branch()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/branch.vim:9
Called 138 times
Total time:   0.125651
 Self time:   0.003786

count  total (s)   self (s)
  138              0.000798   let l:state = { 'index': 0, 'pipelines': a:pipelines, 'original_ctx': copy(a:ctx), 'original_x': copy(a:x), }
                            
  138   0.124740   0.002875   call wilder#pipeline#run( l:state.pipelines[0], {ctx, x -> s:on_finish(l:state, ctx, x)}, {ctx, x -> s:on_error(l:state, ctx, x)}, copy(a:ctx), copy(a:x), )

FUNCTION  wilder#main#in_mode()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:53
Called 59 times
Total time:   0.000439
 Self time:   0.000439

count  total (s)   self (s)
   59              0.000395   return mode(1) ==# 'c' && index(s:opts.modes, getcmdtype()) >= 0

FUNCTION  <SNR>41_check()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/check.vim:5
Called 322 times
Total time:   0.004026
 Self time:   0.003054

count  total (s)   self (s)
  322              0.000324   let l:i = 0
                            
  460              0.000626   for l:Check in a:checks
  322   0.001991   0.001019     if !l:Check(a:ctx, a:x)
  184              0.000138       return v:false
  138              0.000045     endif
  276              0.000124   endfor
                            
  138              0.000105   return a:x

FUNCTION  <SNR>68_render()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/mux.vim:83
Called 99 times
Total time:   0.053607
 Self time:   0.004809

count  total (s)   self (s)
   99              0.000107   if !a:state.active
                                return
   99              0.000036   endif
                            
   99   0.019549   0.000512   let l:renderer = s:get_renderer(a:state.renderers)
                            
   99              0.000127   if l:renderer isnot a:state.current
                                if a:state.current isnot 0 && has_key(a:state.current, 'post_hook')
                                  call a:state.current.post_hook({})
                                endif
                            
                                if l:renderer isnot 0 && has_key(l:renderer, 'pre_hook')
                                  call l:renderer.pre_hook({})
                                endif
                            
                                let a:state.current = l:renderer
   99              0.000034   endif
                            
   99              0.000078   if l:renderer is 0
                                return
   99              0.000029   endif
                            
   99   0.032624   0.002863   call l:renderer.render(a:ctx, a:result)

FUNCTION  <SNR>15_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim:26
Called 7 times
Total time:   0.004851
 Self time:   0.003272

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    7              0.000095   syn clear
    7              0.000016   if exists("b:current_syntax")
                                unlet b:current_syntax
    7              0.000003   endif
                            
    7              0.000017   0verbose let s = expand("<amatch>")
    7              0.000006   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    7              0.000005   elseif s == "OFF"
                                let s = ""
    7              0.000002   endif
                            
    7              0.000004   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    8              0.000014     for name in split(s, '\.')
    4              0.000004       if !empty(name)
    4   0.003131   0.001552         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    4              0.001458         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
    4              0.000002       endif
    8              0.000004     endfor
    7              0.000002   endif

FUNCTION  wilder#pipeline#run()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipeline.vim:87
Called 414 times
Total time:   0.272268
 Self time:   0.001498

count  total (s)   self (s)
  414              0.001154   let l:pipeline = type(a:pipeline) isnot v:t_list ? [a:pipeline] : a:pipeline
                            
  414   0.124449   0.054204   return s:run(l:pipeline, a:on_finish, a:on_error, a:ctx, a:x, 0)

FUNCTION  <SNR>123_forward()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/ts_syntax.vim:10
Called 1271 times
Total time:   0.104248
 Self time:   0.104248

count  total (s)   self (s)
 1271              0.102165   let l:ret = luaeval( 'require"treesitter-matchup.syntax".' . a:fn . '(unpack(_A))', a:000)
 1271              0.001479   return l:ret

FUNCTION  <SNR>54_make_hl()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlight.vim:34
Called 16 times
Total time:   0.010055
 Self time:   0.000406

count  total (s)   self (s)
   16   0.003337   0.000074   let l:x = s:to_hl_list(a:x)
                            
   32              0.000029   for l:elem in a:xs
   16   0.003031   0.000062     let l:y = s:to_hl_list(l:elem)
   16   0.000799   0.000091     let l:x = s:combine_hl_list(l:x, l:y)
   32              0.000013   endfor
                            
   16   0.002793   0.000085   call s:make_hl_from_list(a:name, l:x)

FUNCTION  wilder#renderer#call_component_post_hook()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer.vim:81
Called 52 times
Total time:   0.000308
 Self time:   0.000203

count  total (s)   self (s)
   52              0.000101   if type(a:component) is v:t_dict && has_key(a:component, 'post_hook')
    4   0.000134   0.000029     call a:component['post_hook'](a:ctx)
   52              0.000017   endif

FUNCTION  <SNR>39_prepare_fuzzy_completion()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:46
Called 46 times
Total time:   0.001158
 Self time:   0.001158

count  total (s)   self (s)
                              " For non-python completion, a maximum of 300 help tags are returned, so
                              " getting all the candidates and filtering will miss out on a lot of matches
                              " If argument is empty, don't fuzzy match except for expanding 'help', where
                              " the default argument is 'help'
   46              0.000133   if (a:res.expand ==# 'help' && !a:use_python) || a:res.pos == len(a:res.cmdline)
    7              0.000005     return a:res
   39              0.000011   endif
                            
                              " Remove the starting s: and g: so the fuzzy filter does not match against
                              " that them.
   39              0.000125   if (a:res.expand ==# 'expression' || a:res.expand ==# 'var') && a:res.expand_arg[1] ==# ':' && (a:res.expand_arg[0] ==# 'g' || a:res.expand_arg[0] ==# 's')
                                let a:res.fuzzy_char = a:res.expand_arg[2]
                                let a:res.match_arg = a:res.expand_arg[2 :]
                                let a:res.expand_arg = a:res.expand_arg[0: 1]
                            
                              " For tag-regexp, keep the argument and don't do fuzzy matching
   39              0.000053   elseif a:res.expand ==# 'tags' && a:res.expand_arg[0] ==# '/'
                                let a:res.fuzzy_char = ''
                                let a:res.match_arg = ''
                            
                              " Return all candidates and let the fuzzy filter remove the non-matching
                              " candidates for the following cases:
                              "
                              " mapping: special keys such as <Space> cannot be fuzzy completed since
                              " < will not get completions for <Space>.
                              "
                              " buffer: getcompletion() for buffers checks against the file name, but
                              " we want to check against the full path.
                              "
                              " help: help tag matching does not have to start from beginning of word.
   39              0.000071   elseif a:res.expand ==# 'mapping' || a:res.expand ==# 'buffer' || a:res.expand ==# 'help'
                                " Default argument for help completion is 'help'
                                if a:res.expand ==# 'help' && empty(a:res.expand_arg)
                                  let a:res.match_arg = 'help'
                                else
                                  let a:res.match_arg = a:res.expand_arg
                                endif
                            
                                let a:res.expand_arg = ''
                                let a:res.fuzzy_char = ''
   39              0.000014   else
                                " Default case, expand with the fuzzy_char
   39              0.000089     let a:res.fuzzy_char = strcharpart(a:res.expand_arg, 0, 1)
   39              0.000035     let a:res.expand_arg = ''
   39              0.000015   endif
                            
   39              0.000025   return a:res

FUNCTION  <SNR>84_CurrentTimeStr()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:452
Called 30 times
Total time:   0.000483
 Self time:   0.000282

count  total (s)   self (s)
   30              0.000034         if s:has_reltime
                                        return split(reltimestr(reltime()))[0]
   30              0.000010         endif
   30   0.000337   0.000135         return s:n2s(localtime())

FUNCTION  <SNR>61_clamp()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:818
Called 460 times
Total time:   0.002185
 Self time:   0.002185

count  total (s)   self (s)
  460              0.000391   if a:value < 1
  146              0.000080     return 1
  314              0.000090   endif
                            
  314              0.000488   let l:max = a:is_height ? (&lines - 1) : &columns
  314              0.000230   if a:value > l:max
                                return l:max
  314              0.000082   endif
                            
  314              0.000183   return a:value

FUNCTION  wilder#render#truncate()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/render.vim:150
Called 3 times
Total time:   0.000079
 Self time:   0.000020

count  total (s)   self (s)
    3   0.000079   0.000020   return s:truncate_and_maybe_pad(a:len, a:x, get(a:, 1, 0), 0)

FUNCTION  matchup#loader#init_buffer()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/loader.vim:21
Called 4 times
Total time:   0.017364
 Self time:   0.000800

count  total (s)   self (s)
    4   0.000445   0.000422   call matchup#perf#tic('loader_init_buffer')
                            
    4              0.000006   let l:has_ts = 0
    4              0.000010   let [l:no_words, l:filt_words] = [0, 0]
    4   0.001057   0.000027   if s:ts_may_be_supported && matchup#ts_engine#is_enabled(bufnr('%'))
                                let l:has_ts = 1
                                if matchup#ts_engine#get_option(bufnr('%'), 'include_match_words')
                                  let l:filt_words = 1
                                else
                                  let l:no_words = 1
                                endif
    4              0.000001   endif
                            
    4              0.000004   let l:has_ts_hl = 0
    4   0.000382   0.000030   if s:ts_may_be_supported && matchup#ts_engine#is_hl_enabled(bufnr('%'))
    3              0.000004     let l:has_ts_hl = 1
                            
    3   0.000102   0.000018     if matchup#ts_engine#get_option( bufnr('%'), 'additional_vim_regex_highlighting')
                                  if empty(&syntax)
                                    set syntax=ON
                                  else
                                    augroup matchup_syntax
                                      au!
                                      autocmd VimEnter * if empty(&syntax) | set syntax=ON | endif
                                    augroup END
                                  endif
    3              0.000001     endif
    4              0.000001   endif
                            
                              " initialize lists of delimiter pairs and regular expressions
                              " this is the data obtained from parsing b:match_words
    4   0.011427   0.000047   let b:matchup_delim_lists = s:init_delim_lists(l:no_words, l:filt_words)
                            
                              " this is the combined set of regular expressions used for matching
                              " its structure is matchup_delim_re[type][open,close,both,mid,both_all]
    4   0.003652   0.000031   let b:matchup_delim_re = s:init_delim_regexes()
                            
                              " process b:match_skip
    4              0.000003   if l:has_ts_hl
    3              0.000006     let b:matchup_delim_skip = "matchup#ts_syntax#skip_expr(s:effline('.'),s:effcol('.'))"
    1              0.000001   else
    1   0.000013   0.000007     let b:matchup_delim_skip = s:init_delim_skip()
    4              0.000001   endif
                            
                              " enable matching engines
    4              0.000005   let b:matchup_active_engines = {}
                            
    4              0.000002   if l:has_ts
                                for l:t in ['all', 'delim_all', 'delim_py']
                                  let b:matchup_active_engines[l:t] = get(b:matchup_active_engines, l:t, []) + ['tree_sitter']
                                endfor
    4              0.000001   endif
                            
    4              0.000006   if !empty(b:matchup_delim_lists.all.regex)
   16              0.000011     for l:t in ['all', 'delim_all', 'delim_tex']
   12              0.000029       let b:matchup_active_engines[l:t] = get(b:matchup_active_engines, l:t, []) + ['classic']
   16              0.000006     endfor
    4              0.000001   endif
                            
                              " enable/disable for this buffer
    4              0.000006   let b:matchup_delim_enabled = !empty(b:matchup_active_engines)
                            
    4   0.000084   0.000016   call matchup#perf#toc('loader_init_buffer', 'done')

FUNCTION  wilder#highlight#get_hl_nvim()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlight.vim:237
Called 16 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
   16              0.000008   try
   16              0.000055     let l:cterm_hl = nvim_get_hl_by_name(a:group, 0)
   16              0.000034     let l:gui_hl = nvim_get_hl_by_name(a:group, 1)
                            
   16              0.000026     return [{}, l:cterm_hl, l:gui_hl]
                              catch
                                return [{}, {}, {}]
   16              0.000008   endtry

FUNCTION  wilder#pipeline#resolve()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipeline.vim:12
Called 184 times
Total time:   0.130833
 Self time:   0.000716

count  total (s)   self (s)
  184   0.130783   0.000667   call s:handle(a:ctx, a:x, 'resolve')

FUNCTION  <SNR>61_draw_candidate()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:656
Called 584 times
Total time:   0.021445
 Self time:   0.006922

count  total (s)   self (s)
  584              0.000746   let l:use_cache = a:ctx.selected == a:i
  584   0.000786   0.000784   if l:use_cache && a:state.draw_cache.has_key(a:i)
                                return a:state.draw_cache.get(a:i)
  584              0.000180   endif
                            
  584   0.016990   0.002473   let l:x = wilder#render#draw_candidate(a:ctx, a:result, a:i)
                            
  584              0.000367   if l:use_cache
    1   0.000007   0.000004     call a:state.draw_cache.set(a:i, l:x)
  584              0.000172   endif
                            
  584              0.000335   return l:x

FUNCTION  matchup#perf#tic()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/perf.vim:15
Called 806 times
Total time:   0.002874
 Self time:   0.002874

count  total (s)   self (s)
  806              0.002602   let s:time_start[a:context] = reltime()

FUNCTION  <SNR>68_is_substitute_command()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/mux.vim:58
Called 103 times
Total time:   0.017397
 Self time:   0.001460

count  total (s)   self (s)
  103              0.000172   if getcmdtype() !=# ':'
                                return 0
  103              0.000034   endif
                            
  103   0.016231   0.000513   let l:res = wilder#cmdline#parse(getcmdline())
                            
  103   0.000777   0.000558   return wilder#cmdline#is_substitute_command(l:res.cmd)

FUNCTION  <SNR>110_get_matching_delims()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/delim.vim:681
Called 80 times
Total time:   0.090355
 Self time:   0.022165

count  total (s)   self (s)
                              " called as:   a:delim.get_matching(...)
                              " called from: matchup#delim#get_matching <- matchparen, motion
                              "   from: matchup#delim#get_surrounding <- matchparen, motion, text_obj
                            
   80   0.000499   0.000256   call matchup#perf#tic('get_matching_delims')
                            
                              " first, we figure out what the furthest match is, which will be
                              " either the open or close depending on the direction
   80              0.000543   let [l:re, l:flags, l:stopline] = a:down ? [self.regextwo.close, 'W', line('.') + a:stopline] : [self.regextwo.open, 'bW', max([line('.') - a:stopline, 1])]
                            
                              " these are the anchors for searchpairpos
                              " default to the backref '\1' patterns which will be filled in
   80              0.000104   let l:open = self.regexone.open
   80              0.000083   let l:close = self.regexone.close
                            
                              " if we're searching up, we anchor by the augment string, if it exists
   80              0.000109   if !a:down && !empty(self.augment)
   52              0.000050     let l:open = self.augment.str
   80              0.000027   endif
                            
                              " if going down from mid, we might not have all the groups yet
                              " TODO this could be improved via close augment strings
   80              0.000157   if a:down && self.side ==# 'mid' && !empty(self.augment.unresolved)
                                let l:open = self.regextwo.open
                                let l:close = self.regextwo.close
   80              0.000022   endif
                            
                              " turn \(\) into \%(\) for searchpairpos
   80   0.001128   0.000424   let l:open  = matchup#loader#remove_capture_groups(l:open)
   80   0.000797   0.000395   let l:close = matchup#loader#remove_capture_groups(l:close)
                            
                              " fill in necessary back-references
   80   0.000862   0.000389   let l:open = matchup#delim#fill_backrefs(l:open, self.groups, 0)
   80   0.000655   0.000331   let l:close = matchup#delim#fill_backrefs(l:close, self.groups, 0)
                            
   80   0.000423   0.000312   call matchup#delim#set_invert_skip(self.skip)
   80              0.000103   if empty(b:matchup_delim_skip)
                                let l:skip = 'matchup#delim#skip_default()'
   80              0.000029   else
   80              0.000073     let l:skip = 'matchup#delim#skip0()'
   80              0.000024   endif
                            
                              " disambiguate matches for languages like julia, matlab, ruby, etc
   80              0.000082   if !empty(self.midmap)
   80              0.000098     let l:midmap = self.midmap.elements
   80              0.000070     if self.side ==# 'mid'
   12              0.000086       let l:idx = filter(range(len(l:midmap)), 'self.match =~# l:midmap[v:val][1]')
   68              0.000026     else
   68              0.000335       let l:syn = synIDattr(synID(self.lnum, self.cnum, 0), 'name')
   68              0.000478       let l:idx = filter(range(len(l:midmap)), 'l:syn =~# l:midmap[v:val][0]')
   80              0.000034     endif
   80              0.000083     if len(l:idx)
                                  let l:valid = l:midmap[l:idx[0]]
                                  let l:skip = printf('matchup#delim#skip1(%s, %s)', string(l:midmap[l:idx[0]]), string(l:skip))
   80              0.000028     else
   80              0.000364       let l:skip = printf('matchup#delim#skip2(%s, %s)', string(self.midmap.strike), string(l:skip))
   80              0.000027     endif
   80              0.000023   endif
                            
   80   0.001195   0.000409   if matchup#perf#timeout_check() | return [['', 0, 0]] | endif
                            
                              " improves perceptual performance in insert mode
   80              0.000142   if mode() ==# 'i' || mode() ==# 'R'
    5              0.000013     if !g:matchup_matchparen_deferred && exists('*state') && state('s') ==# ''
                                  sleep 1m
    5              0.000002     endif
   80              0.000023   endif
                            
                              " use b:match_ignorecase
   80              0.000170   let l:ic = get(b:, 'match_ignorecase', 0) ? '\c' : '\C'
   80              0.000115   let l:open = l:ic . l:open
   80              0.000088   let l:close = l:ic . l:close
                            
                              " handle 'same' matches (TODO refactor to separate parser)
   80              0.000070   if l:open == l:close
                                let [l:lnum_corr, l:cnum_corr] = searchpos(l:open, 'n'.l:flags, l:stopline, matchup#perf#timeout()) " , l:skip)
   80              0.000029   else
   80   0.059174   0.005325     let [l:lnum_corr, l:cnum_corr] = searchpairpos(l:open, '', l:close, 'n'.l:flags, l:skip, l:stopline, matchup#perf#timeout())
   80              0.000044   endif
                            
   80   0.002036   0.000414   call matchup#perf#toc('get_matching_delims', 'initial_pair')
                            
                              " if nothing found, bail immediately
   80              0.000078   if l:lnum_corr == 0
                                return [['', 0, 0]]
   80              0.000025   endif
                            
                              " when highlighting, respect hlend
   80              0.000191   let l:extra_entry = self.regextwo.extra_list[a:down ? -1 : 0]
   80              0.000156   if self.highlighting && has_key(l:extra_entry, 'hlend')
                                let l:re = s:process_hlend(l:re, -1)
   80              0.000024   endif
                            
                              " get the corresponding match and (additional) groups
   80              0.000154   let l:has_zs = self.regextwo.extra_info.has_zs
   80   0.000893   0.000428   let l:re_anchored = l:ic . s:anchor_regex(l:re, l:cnum_corr, l:has_zs)
                            
   80              0.000562   let l:matches = matchlist(getline(l:lnum_corr), l:re_anchored)
   80              0.000116   let l:match_corr = l:matches[0]
                            
                              " store these in these groups
   80              0.000049   if a:down
   28              0.000055     let l:id = len(self.regextwo.mid_list) + 1
   28              0.000118     for [l:from, l:to] in items(get(self.regextwo.grp_renu, l:id, {}))
                                  if !has_key(self.groups, l:to) && !empty(l:matches[l:from])
                                    let self.groups[l:to] = l:matches[l:from]
                                  endif
   28              0.000016     endfor
   52              0.000016   else
   52              0.000109     for l:to in keys(self.regextwo.need_grp)
                                  if !has_key(self.groups, l:to) && !empty(l:matches[l:to])
                                    " TODO mark context
                                    let self.groups[l:to] = l:matches[l:to]
                                  endif
                                  " let self.groups[0] = l:matches[0]
   52              0.000024     endfor
   80              0.000025   endif
                            
   80   0.001676   0.000327   call matchup#perf#toc('get_matching_delims', 'get_matches')
                            
                              " fill in additional groups
   80   0.001028   0.000441   let l:mids = matchup#loader#remove_capture_groups(self.regexone.mid)
   80   0.000858   0.000390   let l:mids = matchup#delim#fill_backrefs(l:mids, self.groups, 1)
                            
                              " if there are no mids, we're done
   80              0.000131   if empty(l:mids) || g:matchup_delim_nomids
   52              0.000088     return [[l:match_corr, l:lnum_corr, l:cnum_corr]]
   28              0.000011   endif
                            
   28              0.000025   let l:re = l:mids
                            
                              " when highlighting, respect hlend
   28              0.000061   if get(self.regextwo.extra_info, 'mid_hlend') && self.highlighting
                                let l:re = s:process_hlend(l:re, -1)
   28              0.000009   endif
                            
                              " use b:match_ignorecase
   28              0.000036   let l:mid = l:ic . l:mids
   28              0.000029   let l:re = l:ic . l:re
                            
   28              0.000027   let l:list = []
   30              0.000022   while 1
   32   0.000463   0.000149     if matchup#perf#timeout_check() | break | endif
                            
   30   0.008508   0.002030     let [l:lnum, l:cnum] = searchpairpos(l:open, l:mids, l:close, l:flags, l:skip, l:lnum_corr, matchup#perf#timeout())
   32              0.000070     if l:lnum <= 0 | break | endif
                            
   30              0.000033     if a:down
    6              0.000018       if l:lnum > l:lnum_corr || l:lnum == l:lnum_corr && l:cnum >= l:cnum_corr | break | endif
   24              0.000012     else
   26              0.000066       if l:lnum < l:lnum_corr || l:lnum == l:lnum_corr && l:cnum <= l:cnum_corr | break | endif
    2              0.000001     endif
                            
    2   0.000027   0.000013     let l:re_anchored = s:anchor_regex(l:re, l:cnum, l:has_zs)
    2              0.000018     let l:matches = matchlist(getline(l:lnum), l:re_anchored)
    2              0.000003     if empty(l:matches)
                                  " this should never happen
                                  continue
    2              0.000001     endif
    2              0.000003     let l:match = l:matches[0]
                            
    2              0.000006     call add(l:list, [l:match, l:lnum, l:cnum])
   30              0.000034   endwhile
                            
   28              0.000085   call add(l:list, [l:match_corr, l:lnum_corr, l:cnum_corr])
                            
   28              0.000023   if !a:down
   22              0.000034     call reverse(l:list)
   28              0.000011   endif
                            
   28              0.000020   return l:list

FUNCTION  <SNR>58_get_cmdline_data()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:127
Called 89 times
Total time:   0.005534
 Self time:   0.005534

count  total (s)   self (s)
   89              0.000135   if a:state.cached_cmdline ==# a:cmdline
   42              0.000036     return a:state.cached_cmdline_data
   47              0.000014   endif
                            
   47              0.000421   let l:cmdline_chars = split(a:cmdline, '\zs')
   47              0.000051   let l:cmdline_data = []
                            
   47              0.000041   let l:byte_pos = 0
   47              0.000045   let l:displaywidth_pos = 0
                            
   47              0.000040   let l:i = 0
  366              0.000424   while l:i < len(l:cmdline_chars)
  319              0.000358     let l:char = l:cmdline_chars[l:i]
                            
                                " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
  319              0.000396     let l:byte_len = len(l:char)
  319              0.000425     let l:displaywidth = strdisplaywidth(l:char)
  319              0.000611     let l:data = [l:char, l:byte_len, l:displaywidth, l:byte_pos, l:displaywidth_pos]
  319              0.000417     call add(l:cmdline_data, l:data)
                            
  319              0.000313     let l:byte_pos += l:byte_len
  319              0.000325     let l:displaywidth_pos += l:displaywidth
                            
  319              0.000232     let l:i += 1
  366              0.000150   endwhile
                            
   47              0.000055   let a:state.cached_cmdline = a:cmdline
   47              0.000152   let a:state.cached_cmdline_data = l:cmdline_data
                            
   47              0.000043   return a:state.cached_cmdline_data

FUNCTION  <SNR>61_draw_top_or_bottom_line()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:795
Called 356 times
Total time:   0.111645
 Self time:   0.020433

count  total (s)   self (s)
  356              0.000443   let l:width = a:ctx.width
                            
  356              0.000429   let l:Line = a:line
  356              0.000473   if type(l:Line) is v:t_dict
   89              0.000124     let l:Line = l:Line.value
  356              0.000111   endif
                            
  356              0.000375   if type(l:Line) is v:t_func
  356   0.106777   0.015565     let l:Line = l:Line(a:ctx, a:result)
  356              0.000141   endif
                            
  356              0.000431   if type(l:Line) is v:t_string
                                if empty(l:Line)
                                  return l:Line
                                endif
                            
                                let l:Line = [[wilder#render#truncate_and_pad(a:ctx.width, l:Line)]]
  356              0.000109   endif
                            
  356              0.000225   return l:Line

FUNCTION  wilder#render#to_printable()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/render.vim:98
Called 584 times
Total time:   0.003710
 Self time:   0.003710

count  total (s)   self (s)
  584              0.000480   if !s:has_strtrans_issue
                                " check if first character is a combining character
  584              0.001220     if strdisplaywidth(' ' . a:x) == strdisplaywidth(a:x)
                                  return strtrans(' ' . a:x)
  584              0.000201     endif
                            
  584              0.000753     return strtrans(a:x)
                              endif
                            
                              let l:transformed = strtrans(a:x)
                              " strtrans is ok
                              if strdisplaywidth(a:x) == strdisplaywidth(l:transformed)
                                " check if first character is a combining character
                                if strdisplaywidth(' ' . a:x) == strdisplaywidth(a:x)
                                  return strtrans(' ' . a:x)
                                endif
                            
                                return strtrans(a:x)
                              endif
                            
                              let l:res = ''
                              let l:first = 1
                            
                              for l:char in split(a:x, '\zs')
                                let l:transformed_char = strtrans(l:char)
                            
                                let l:transformed_width = strdisplaywidth(l:transformed_char)
                                let l:width = strdisplaywidth(l:char)
                            
                                if l:transformed_width == l:width
                                  " strtrans is ok
                                  let l:res .= l:transformed_char
                                elseif l:transformed_width == 0
                                  " strtrans returns empty character, use original char
                                  if l:first && strdisplaywidth(' ' . l:char) == strdisplaywidth(l:char)
                                    " check if first character is combining character
                                    let l:res .= ' ' . l:char
                                  else
                                    let l:res .= l:char
                                  endif
                                else
                                  " fallback to hex representation
                                  let l:res .= '<' . printf('%02x', char2nr(l:char)) . '>'
                                endif
                            
                                let l:first = 0
                              endfor
                            
                              return l:res

FUNCTION  matchup#loader#sidedict()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/loader.vim:766
Called 74 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
   74              0.000091   return s:sidedict

FUNCTION  wilder#cmdline#prepare_user_completion()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:617
Called 92 times
Total time:   0.000881
 Self time:   0.000586

count  total (s)   self (s)
   92   0.000724   0.000429   if !wilder#cmdline#is_user_command(a:res.cmd)
   92              0.000119     return [0, 0, a:res]
                              endif
                            
                              if !has('nvim')
                                return [1, v:true, a:res]
                              endif
                            
                              if a:ctx.session_id > s:cached_commands_session_id
                                let s:cached_commands_session_id = a:ctx.session_id
                                let s:cached_user_commands = extend(nvim_get_commands({}), nvim_buf_get_commands(0, {}))
                                let s:has_completion_error = {}
                              endif
                            
                              " Calling getcompletion() interferes with wildmenu command completion so
                              " we return v:true early
                              if has_key(s:has_completion_error, a:res.cmd)
                                let l:res = copy(a:res)
                                let l:res.pos = 0
                                return [1, v:true, l:res]
                              endif
                            
                              if has_key(s:cached_user_commands, a:res.cmd)
                                let l:command = a:res.cmd
                              else
                                " Command might be a partial name
                                let l:matches = getcompletion(a:res.cmd, 'command')
                            
                                " 2 or more matches indicates command is ambiguous
                                if len(l:matches) >= 2
                                  throw "Ambiguous use of user-defined command, possible matches: " . string(l:matches)
                                elseif len(l:matches) == 0
                                  return [1, [], a:res, 0]
                                endif
                            
                                let l:command = l:matches[0]
                              endif
                            
                              let l:user_command = s:cached_user_commands[l:command]
                            
                              if has_key(l:user_command, 'complete_arg') && l:user_command.complete_arg isnot v:null
                            
                                " Find last argument by looking for the last whitespace character
                                let l:pos = len(a:res.cmdline)
                                while l:pos >= a:res.pos
                                  if a:res.cmdline[l:pos] ==# ' ' || a:res.cmdline[l:pos] ==# "\t"
                                    break
                                  endif
                            
                                  let l:pos -= 1
                                endwhile
                            
                                let l:arg = a:res.cmdline[l:pos+1 :]
                            
                                try
                                  let l:function_name = l:user_command.complete_arg
                                  if l:function_name[:1] ==# 's:'
                                    let l:function_name = '<SNR>' . l:user_command.script_id . '_' . l:function_name[2:]
                                  elseif l:function_name[:4] ==? '<SID>'
                                    let l:function_name = '<SNR>' . l:user_command.script_id . '_' . l:function_name[5:]
                                  endif
                            
                                  let l:Completion_func = function(l:function_name)
                                  let l:result = l:Completion_func(l:arg, a:res.cmdline, len(a:res.cmdline))
                                catch
                                  " Add both the full command and partial command
                                  let s:has_completion_error[l:command] = 1
                                  let s:has_completion_error[a:res.cmd] = 1
                            
                                  let l:res = copy(a:res)
                                  let l:res.pos = 0
                                  return [1, v:true, l:res]
                                endtry
                            
                                let l:is_custom_list = get(l:user_command, 'complete', '') ==# 'customlist'
                                if !l:is_custom_list
                                  let l:result = split(l:result, '\n')
                                endif
                            
                                let l:res = copy(a:res)
                                let l:res.pos = l:pos
                                let l:res.match_arg = l:arg
                                if !l:is_custom_list
                                  let l:res.arg = l:arg
                                endif
                            
                                return [1, l:result, l:res, !l:is_custom_list]
                              endif
                            
                              if has_key(l:user_command, 'complete') && l:user_command['complete'] isnot v:null && l:user_command['complete'] !=# 'custom' && l:user_command['complete'] !=# 'customlist'
                                let l:res = copy(a:res)
                                let l:res['expand'] = l:user_command['complete']
                            
                                return [0, 0, l:res]
                              endif
                            
                              return [1, v:false, a:res]

FUNCTION  <SNR>117_draw()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:429
Called 99 times
Total time:   0.063245
 Self time:   0.007796

count  total (s)   self (s)
   99              0.000084   if s:hidden
                                return
   99              0.000040   endif
                            
   99              0.000044   try
   99              0.000173       let l:direction = a:0 >= 1 ? a:1 : 0
                            
   99              0.000287       if s:selected == -1 && !s:opts.noselect && !s:selection_was_made && !empty(s:result.value)
                                    let l:selected = 0
   99              0.000047       else
   99              0.000104         let l:selected = s:selected
   99              0.000040       endif
                            
   99              0.000695       let l:ctx = { 'clear_previous': get(s:, 'clear_previous_renderer_state', 0), 'selected': l:selected, 'direction': l:direction, 'run_id': s:result_run_id, 'done': s:run_id == s:result_run_id, 'session_id': s:result_session_id, }
   99              0.000116       let s:clear_previous_renderer_state = 0
                            
   99              0.000147       let l:has_error = s:error isnot v:null
                            
   99              0.000071       if l:has_error
                                    let l:ctx.error = s:error
                                    let l:value = {'value': []}
   99              0.000035       else
   99              0.000105         let l:value = s:result
   99              0.000034       endif
                            
   99   0.060060   0.004610       call s:opts.renderer.render(l:ctx, l:value)
                              catch
                                echohl ErrorMsg
                                echomsg 'wilder: draw: ' . v:exception
                                echohl Normal
   99              0.000081   finally
   99              0.000096     let s:draw_done = 1
   99              0.000065   endtry

FUNCTION  <SNR>51_message()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/component/popupmenu_empty_message_with_spinner.vim:39
Called 3 times
Total time:   0.000230
 Self time:   0.000059

count  total (s)   self (s)
    3              0.000005   call timer_stop(a:state.timer)
                            
    3   0.000060   0.000012   let [l:frame_number, l:wait_time] = a:state.spinner(a:ctx.done)
                            
    3              0.000002   if l:wait_time >= 0
    1              0.000004     let a:state.timer = timer_start(l:wait_time, {-> wilder#main#draw()})
    3              0.000001   endif
                            
    3              0.000002   if l:frame_number == -1
    3              0.000003     let l:frame = a:state.done
                              else
                                let l:frame = a:state.frames[l:frame_number]
    3              0.000001   endif
                            
    3              0.000006   let l:spinner_hl = get(a:state, 'spinner_hl', a:ctx.highlights.empty_message)
                            
    3   0.000134   0.000011   return a:state.message(a:ctx, a:result, l:frame, l:spinner_hl)

FUNCTION  <SNR>40_clear()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cache.vim:23
Called 92 times
Total time:   0.000338
 Self time:   0.000338

count  total (s)   self (s)
   92              0.000313   let self['_cache'] = {}

FUNCTION  <lambda>288()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/mux.vim:54
Called 103 times
Total time:   0.000159
 Self time:   0.000159

count  total (s)   self (s)
                            return getcmdtype() ==# a:type

FUNCTION  <SNR>103_init_delim_skip()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/loader.vim:714
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000003   let l:skip = get(b:, 'match_skip', '')
    1              0.000003   if empty(l:skip) | return '' | endif
                            
                              " s:foo becomes (current syntax item) =~ foo
                              " S:foo becomes (current syntax item) !~ foo
                              " r:foo becomes (line before cursor) =~ foo
                              " R:foo becomes (line before cursor) !~ foo
                              let l:cursyn = "synIDattr(synID(s:effline('.'),s:effcol('.'),1),'name')"
                              let l:preline = "strpart(s:geteffline('.'),0,s:effcol('.'))"
                            
                              if l:skip =~# '^[sSrR]:'
                                let l:syn = strpart(l:skip, 2)
                            
                                let l:skip = { 's': l:cursyn."=~?'".l:syn."'", 'S': l:cursyn."!~?'".l:syn."'", 'r': l:preline."=~?'".l:syn."'", 'R': l:preline."!~?'".l:syn."'",}[l:skip[0]]
                              endif
                            
                              for [l:pat, l:str] in [ [ '\<col\ze(', 's:effcol'   ], [ '\<line\ze(', 's:effline' ], [ '\<getline\ze(', 's:geteffline' ],]
                                let l:skip = substitute(l:skip, l:pat, l:str, 'g')
                              endfor
                            
                              return l:skip

FUNCTION  <SNR>61_pre_hook()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:682
Called 4 times
Total time:   0.000806
 Self time:   0.000408

count  total (s)   self (s)
    4   0.000108   0.000038   call a:state.api.new({ 'normal_highlight': a:state.highlights.default, 'zindex': get(a:state, 'zindex', 0), 'pumblend': get(a:state, 'pumblend', -1) })
                            
   56              0.000097   for l:Component in [a:state.empty_message, a:state.error_message] + a:state.left + a:state.right + a:state.top + a:state.bottom
   52   0.000557   0.000228     call wilder#renderer#call_component_pre_hook(a:ctx, l:Component)
   56              0.000018   endfor
                            
    4              0.000004   let a:state.active = 1
    4              0.000005   let a:state.is_first_draw = 1

FUNCTION  <SNR>51_make_empty_message()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/component/popupmenu_empty_message_with_spinner.vim:59
Called 3 times
Total time:   0.000110
 Self time:   0.000030

count  total (s)   self (s)
    3              0.000003   let l:max_width = a:ctx.max_width
    3              0.000006   let l:spinner_width = strdisplaywidth(a:spinner_char)
                            
    3              0.000003   let l:max_width -= l:spinner_width
    3   0.000090   0.000010   let l:message = wilder#render#truncate(l:max_width, a:message)
                            
    3              0.000006   return [[a:spinner_char, a:spinner_hl], [l:message, a:ctx.highlights.empty_message]]

FUNCTION  matchup#pos#set_cursor()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/pos.vim:10
Called 154 times
Total time:   0.002730
 Self time:   0.000838

count  total (s)   self (s)
  154   0.002677   0.000786   call cursor(s:parse_args(a:000))

FUNCTION  <lambda>290()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/mux.vim:46
Called 99 times
Total time:   0.054044
 Self time:   0.000437

count  total (s)   self (s)
                            return s:render(l:state, ctx, result)

FUNCTION  <lambda>292()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/mux.vim:46
Called 4 times
Total time:   0.001197
 Self time:   0.000024

count  total (s)   self (s)
                            return s:post_hook(l:state, ctx)

FUNCTION  <lambda>148()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlighter.vim:157
Called 302 times
Total time:   0.002222
 Self time:   0.001438

count  total (s)   self (s)
                            return wilder#highlighter#python_pcre2_highlight(ctx, l:opts, x, data)

FUNCTION  wilder#main#on_finish()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:315
Called 46 times
Total time:   0.024338
 Self time:   0.002007

count  total (s)   self (s)
   46              0.000062   if !s:active || !s:enabled
                                return
   46              0.000013   endif
                            
   46              0.000044   if a:ctx.run_id != s:run_id
                                return
   46              0.000011   endif
                            
   46              0.000049   let s:result_run_id = a:ctx.run_id
   46              0.000050   let s:result_session_id = a:ctx.session_id
                            
   46              0.000115   let l:result = (a:x is v:false || a:x is v:true) ? {'value': []} : a:x
   46              0.000053   if type(l:result) isnot v:t_dict
                                let s:result = {'value': l:result}
   46              0.000017   else
   46              0.000044     let s:result = l:result
   46              0.000015   endif
                            
   46              0.000055   if !has_key(s:result, 'data')
                                let s:result.data = {}
   46              0.000012   endif
                            
   46              0.000054   if !has_key(s:result.data, 'query')
                                let s:result.data.query = a:ctx.input
   46              0.000012   endif
                            
                              " When a new result arrives, the previous results are cleared. If there is a
                              " selection, treat the current cmdline as being replaced.
   46              0.000036   if s:selected >= 0
                                let s:replaced_cmdline = getcmdline()
   46              0.000012   endif
                            
   46              0.000038   let s:selected = -1
   46              0.000041   let s:selection_was_made = 0
   46              0.000044   let s:clear_previous_renderer_state = 1
                              " keep previous completion
                            
   46              0.000035   let s:error = v:null
                            
   46              0.000031   if a:x is v:true
                                if !s:hidden
                                  let s:hidden = 1
                            
                                  call s:post_hook()
                                endif
                            
                                return
   46              0.000011   endif
                            
   46              0.000025   if s:hidden
                                let s:hidden = 0
                            
                                call s:pre_hook()
   46              0.000012   endif
                            
   46              0.000029   if s:select_next
                                call wilder#main#next()
                            
                                let s:select_next = 0
                                return
   46              0.000012   endif
                            
   46              0.000084   if !empty(s:completion_stack) && get(a:ctx, 'auto_select', 0)
                                " removing previous_cmdline causes this to be treated as a new input
                                let s:previous_cmdline = v:null
                            
                                call wilder#main#next()
                                return
   46              0.000011   endif
                            
   46   0.022484   0.000153   call s:draw()

FUNCTION  <lambda>149()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlighter.vim:212
Called 302 times
Total time:   0.007304
 Self time:   0.001413

count  total (s)   self (s)
                            return wilder#highlighter#lua_fzy_highlight(ctx, {}, x, data)

FUNCTION  matchup#quirks#isclike()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/quirks.vim:16
Called 1 time
Total time:   0.000011
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000010   0.000004   return s:ftcheck(s:clikeft)

FUNCTION  matchup#pos#equal()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/pos.vim:106
Called 469 times
Total time:   0.027277
 Self time:   0.008185

count  total (s)   self (s)
  469   0.015710   0.004867   let l:pos1 = s:parse_args(a:p1)
  469   0.010171   0.001922   let l:pos2 = s:parse_args(a:p2)
  469              0.001121   return l:pos1[:1] == l:pos2[:1]

FUNCTION  <SNR>54_to_hl_list()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlight.vim:45
Called 32 times
Total time:   0.006232
 Self time:   0.000927

count  total (s)   self (s)
   32              0.000045   if type(a:x) is v:t_string
   16   0.000329   0.000062     let l:x = wilder#highlight#get_hl(a:x)
   16              0.000006   else
   16              0.000012     let l:x = a:x
   32              0.000010   endif
                            
   32              0.000072   if type(l:x) is v:t_list && type(l:x[0]) is v:t_list
                                return l:x
   32              0.000009   endif
                            
   32   0.001811   0.000130   let l:term_hl = s:get_attrs_as_list(l:x[0])
                            
   32   0.001906   0.000230   let l:cterm_hl = [ get(l:x[1], 'foreground', 'NONE'), get(l:x[1], 'background', 'NONE') ] + s:get_attrs_as_list(l:x[1])
                            
   32   0.001887   0.000206   let l:gui_hl = [ get(l:x[2], 'foreground', 'NONE'), get(l:x[2], 'background', 'NONE') ] + s:get_attrs_as_list(l:x[2])
                            
   32              0.000039   return [l:term_hl, l:cterm_hl, l:gui_hl]

FUNCTION  <SNR>48_resolve()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/branch.vim:48
Called 138 times
Total time:   0.001405
 Self time:   0.000924

count  total (s)   self (s)
  138              0.000268   let l:ctx = copy(a:ctx)
  138              0.000190   let l:ctx.handler_id = a:state.original_ctx.handler_id
                            
  138   0.000884   0.000402   call wilder#resolve(l:ctx, a:x)

FUNCTION  <SNR>117_do()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:248
Called 54 times
Total time:   0.049003
 Self time:   0.003066

count  total (s)   self (s)
   54              0.000139   if !s:active || !s:enabled
                                return
   54              0.000030   endif
                            
   54   0.000581   0.000237   if a:check && !wilder#main#in_mode()
                                call wilder#main#stop()
                                return
   54              0.000021   endif
                            
   54   0.000477   0.000271   let l:input = s:getcmdline()
                            
   54              0.000108   let l:has_completion = l:input ==# s:completion
   54              0.000121   let l:is_new_input = s:previous_cmdline is v:null
   54              0.000139   let l:input_changed = s:previous_cmdline isnot v:null && s:previous_cmdline !=# l:input
   54              0.000148   let l:should_keep_completion = s:completion_from_reject_completion isnot v:null && s:completion_from_reject_completion ==# l:input
                            
   54              0.000071   if !l:has_completion && !l:should_keep_completion
   46              0.000058     let s:completion = v:null
   46              0.000046     let s:replaced_cmdline = v:null
   46              0.000070     let s:completion_stack = []
   54              0.000023   endif
                            
   54              0.000042   if !l:should_keep_completion
   54              0.000069     let s:completion_from_reject_completion = v:null
   54              0.000019   endif
                            
   54              0.000071   if s:previous_cmdline is v:null || l:input_changed
   47              0.000051     let s:previous_cmdline = l:input
   54              0.000018   endif
                            
   54              0.000055   let s:draw_done = 0
                            
   54              0.000083   if !l:has_completion && (l:input_changed || l:is_new_input)
   46   0.008160   0.000253     call s:run_pipeline(l:input)
                            
   46              0.000047     if !s:draw_done
   46   0.037752   0.000270       call s:draw()
   46              0.000020     endif
   54              0.000017   endif
                            
   54              0.000049   let s:force = 0

FUNCTION  <SNR>54_combine_hl_list()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlight.vim:71
Called 16 times
Total time:   0.000708
 Self time:   0.000708

count  total (s)   self (s)
   16              0.000030   let l:term_hl = copy(a:l[0])
   16              0.000024   let l:cterm_hl = copy(a:l[1])
   16              0.000024   let l:gui_hl = copy(a:l[2])
                            
   16              0.000018   if len(l:term_hl) <= 2
   16              0.000021     let l:term_hl = copy(a:m[0])
                              else
                                let l:term_hl += a:m[0][2:]
   16              0.000005   endif
                            
   16              0.000026   let l:cterm_fg = get(a:m[1], 0, -1)
   16              0.000019   if l:cterm_fg isnot 'NONE' && l:cterm_fg isnot -1
                                if empty(l:cterm_hl)
                                  let l:cterm_hl = [l:cterm_fg]
                                else
                                  let l:cterm_hl[0] = l:cterm_fg
                                endif
   16              0.000004   endif
                            
   16              0.000023   let l:cterm_bg = get(a:m[1], 1, -1)
   16              0.000015   if l:cterm_bg isnot 'NONE' && l:cterm_bg isnot -1
                                if empty(l:cterm_hl)
                                  let l:cterm_hl = ['NONE', l:cterm_bg]
                                else
                                  let l:cterm_hl[1] = l:cterm_bg
                                endif
   16              0.000004   endif
                            
   16              0.000021   if len(a:m[1]) > 2
   12              0.000012     if empty(l:cterm_hl)
                                  let l:cterm_hl = ['NONE', 'NONE'] + a:m[1][2:]
   12              0.000004     else
   12              0.000020       let l:cterm_hl += a:m[1][2:]
   12              0.000004     endif
   16              0.000004   endif
                            
   16              0.000022   let l:gui_fg = get(a:m[2], 0, -1)
   16              0.000016   if l:gui_fg isnot 'NONE' && l:gui_fg isnot -1
    4              0.000005     if empty(l:gui_hl)
                                  let l:gui_hl = [l:gui_fg]
    4              0.000001     else
    4              0.000005       let l:gui_hl[0] = l:gui_fg
    4              0.000001     endif
   16              0.000004   endif
                            
   16              0.000020   let l:gui_bg = get(a:m[2], 1, -1)
   16              0.000013   if l:gui_bg isnot 'NONE' && l:gui_bg isnot -1
                                if empty(l:gui_hl)
                                  let l:gui_hl = ['NONE', l:gui_bg]
                                else
                                  let l:gui_hl[1] = l:gui_bg
                                endif
   16              0.000004   endif
                            
   16              0.000015   if len(a:m[2]) > 2
   12              0.000010     if empty(l:gui_hl)
                                  let l:gui_hl = ['NONE', 'NONE'] + a:m[2][2:]
   12              0.000004     else
   12              0.000017       let l:gui_hl += a:m[2][2:]
   12              0.000004     endif
   16              0.000004   endif
                            
   16              0.000019   return [l:term_hl, l:cterm_hl, l:gui_hl]

FUNCTION  <SNR>103_matchstrpos()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/loader.vim:695
Called 63 times
Total time:   0.000430
 Self time:   0.000430

count  total (s)   self (s)
   63              0.000415     return matchstrpos(a:expr, a:pat, a:start)

FUNCTION  <lambda>46()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1325
Called 46 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
                            return res[0] ? res : v:false

FUNCTION  wilder#render#spans_to_chunks()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/render.vim:31
Called 302 times
Total time:   0.013844
 Self time:   0.013844

count  total (s)   self (s)
  302              0.000298   let l:res = []
                            
  302              0.000275   let l:non_span_start = 0
  302              0.000196   let l:end = 0
                            
  302              0.000588   let l:non_span_hl = a:highlights[a:is_selected ? 'selected' : 'default']
  302              0.000517   let l:default_span_hl = a:highlights[a:is_selected ? 'selected_accent' : 'accent']
                            
  302              0.000213   let l:i = 0
  580              0.000714   while l:i < len(a:spans)
  278              0.000324     let l:span = a:spans[l:i]
  278              0.000275     let l:start = l:span[0]
  278              0.000269     let l:len = l:span[1]
                            
  278              0.000294     if len(l:span) == 2
                                  " [start, length]
  278              0.000294       let l:span_hl = l:default_span_hl
                                elseif len(l:span) == 3
                                  " [start, length, hl]
                                  let l:span_hl = l:span[2]
                                else
                                  " [start, length, hl, selected_hl]
                                  let l:span_hl = a:is_selected ? l:span[3] : l:span[2]
  278              0.000079     endif
                            
  278              0.000167     if l:start > 0
  145              0.000436       call add(l:res, [strpart(a:str, l:non_span_start, l:start - l:non_span_start), l:non_span_hl])
  278              0.000083     endif
                            
  278              0.000780     call add(l:res, [strpart(a:str, l:start, l:len), l:span_hl])
                            
  278              0.000325     let l:non_span_start = l:start + l:len
  278              0.000224     let l:i += 1
  580              0.000357   endwhile
                            
  302              0.000784   call add(l:res, [strpart(a:str, l:non_span_start), l:non_span_hl])
                            
  302              0.000211   return l:res

FUNCTION  wilder#main#next()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:475
Called 1 time
Total time:   0.000759
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000758   0.000006   return wilder#main#step(1)

FUNCTION  <SNR>45_result_start()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/result.vim:6
Called 138 times
Total time:   0.023923
 Self time:   0.002803

count  total (s)   self (s)
  138              0.000145   let l:kvs = []
  322              0.000403   for l:key in keys(a:args)
  184              0.000538     call add(l:kvs, {'key': l:key, 'value': a:args[l:key]})
  322              0.000150   endfor
                            
  138              0.000319   let l:result = type(a:x) isnot v:t_dict ? {'value': a:x} : a:x
                            
  138              0.000139   if empty(l:kvs)
                                return l:result
  138              0.000040   endif
                            
  138   0.021673   0.000553   return s:result(l:kvs, a:ctx, l:result)

FUNCTION  matchup#loader#remove_capture_groups()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/loader.vim:707
Called 288 times
Total time:   0.003187
 Self time:   0.003187

count  total (s)   self (s)
  288              0.000362   let l:sub_grp = '\(\\\@<!\(\\\\\)*\)\@<=\\('
  288              0.002722   return substitute(a:re, l:sub_grp, '\\%(', 'g')

FUNCTION  matchup#delim#skip0()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/delim.vim:891
Called 332 times
Total time:   0.057089
 Self time:   0.004983

count  total (s)   self (s)
  332              0.000917   let s:eff_curpos = [line('.'), col('.')]
  332   0.056049   0.003944   execute 'return' (s:invert_skip ? '!(' : '(') b:matchup_delim_skip ')'

FUNCTION  matchup#delim#skip2()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/delim.vim:912
Called 340 times
Total time:   0.060129
 Self time:   0.003040

count  total (s)   self (s)
  340   0.060025   0.002936   return getline('.')[col('.')-1:] =~# '^' . a:strike || eval(a:def)

FUNCTION  <SNR>32_dopopd()
    Defined: /usr/share/vim/vimfiles/plugin/fzf.vim:598
Called 8 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    8              0.000019   if !exists('w:fzf_pushd')
    8              0.000004     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet! w:fzf_pushd

FUNCTION  <SNR>110_parser_delim_new()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/delim.vim:527
Called 74 times
Total time:   0.050439
 Self time:   0.046814

count  total (s)   self (s)
   74              0.000132   let l:cursorpos = a:opts.cursorpos
   74              0.000069   let l:found = 0
                            
   74   0.000484   0.000359   let l:sides = matchup#loader#sidedict()[a:opts.side]
   74              0.000168   let l:rebrs = b:matchup_delim_lists[a:opts.type].regex_capture
                            
                              " use b:match_ignorecase
   74              0.000178   let l:ic = get(b:, 'match_ignorecase', 0) ? '\c' : '\C'
                            
                              " loop through all (index, side) pairs,
   74              0.000112   let l:ns = len(l:sides)
   74              0.000053   let l:found = 0
  847              0.000677   for l:i in range(len(l:rebrs)*l:ns)
  847              0.000982     let l:side = l:sides[ l:i % l:ns ]
                            
  847              0.000615     if l:side ==# 'mid'
  269              0.000371       let l:res = l:rebrs[l:i / l:ns].mid_list
  538              0.000337       if empty(l:res) | continue | end
  578              0.000174     else
  578              0.001027       let l:res = [ l:rebrs[l:i / l:ns][l:side] ]
 1082              0.000824       if empty(l:res[0]) | continue | end
  636              0.000165     endif
                            
                                " if pattern may contain \zs, extra processing is required
  636              0.000841     let l:extra_info = l:rebrs[l:i / l:ns].extra_info
  636              0.000922     let l:has_zs = get(l:extra_info, 'has_zs', 0)
                            
  636              0.000420     let l:mid_id = 0
 1198              0.000828     for l:re in l:res
  636              0.000483       let l:mid_id += 1
                            
                                  " check whether hlend needs to be handled
  636              0.000991       let l:id = l:side ==# 'mid' ? l:mid_id : l:side ==# 'open' ? 0 : -1
  636              0.001073       let l:extra_entry = l:rebrs[l:i / l:ns].extra_list[l:id]
  636              0.000911       let l:has_hlend = has_key(l:extra_entry, 'hlend')
                            
  636              0.000677       if l:has_hlend && get(a:opts, 'highlighting', 0)
                                    let l:re = s:process_hlend(l:re, l:cursorpos)
  636              0.000221       endif
                            
                                  " prepend the column number and append the cursor column
                                  " to anchor the match; we don't use {start} for matchlist
                                  " because there may be zero-width look behinds
  636   0.005804   0.002757       let l:re_anchored = l:ic . s:anchor_regex(l:re, a:cnum, l:has_zs)
                            
                                  " for current we want the first match which the cursor is inside
  636              0.000563       if a:opts.direction ==# 'current'
  636              0.001001         let l:re_anchored .= '\%>'.(l:cursorpos).'c'
  636              0.000190       endif
                            
  636              0.003097       let l:matches = matchlist(getline(a:lnum), l:re_anchored)
 1198              0.000913       if empty(l:matches) | continue | endif
                            
                                  " reject matches which the cursor is outside of
                                  " this matters only for \ze
   74              0.000239       if !l:has_hlend && a:opts.direction ==# 'current' && a:cnum + strlen(l:matches[0]) <= l:cursorpos
                                    continue
   74              0.000019       endif
                            
                                  " if pattern contains \zs we need to re-check the starting column
   74              0.000130       if l:has_zs && match(getline(a:lnum), l:re_anchored) != a:cnum-1
                                    continue
   74              0.000017       endif
                            
                                  " handle syntax check- currently used for 'same' matches
   74              0.000086       if has_key(l:extra_entry, 'syn')
                                    let [l:pat; l:args] = split(l:extra_entry.syn, ';')
                                    let l:offs = str2nr(get(l:args, 0, 0))
                                    let l:invert = 0
                                    if l:pat[0] ==? '!'
                                      let l:invert = 1
                                      let l:pat = l:pat[1:]
                                    endif
                                    let l:res = matchup#util#in_synstack( l:pat, a:lnum, a:cnum + l:offs)
                                    if l:invert && l:res || !l:invert && !l:res
                                      continue
                                    endif
   74              0.000020       endif
                            
   74              0.000056       let l:found = 1
   74              0.000032       break
  636              0.000204     endfor
                            
 1198              0.000589     if !l:found | continue | endif
                            
   74              0.000024     break
   74              0.000168   endfor
                            
   74              0.000050   if !l:found
                                return {}
   74              0.000026   endif
                            
   74              0.000091   let l:match = l:matches[0]
                            
   74              0.000124   let l:list = b:matchup_delim_lists[a:opts.type]
   74              0.000133   let l:thisregex  = l:list.regex[l:i / l:ns]
   74              0.000101   let l:thisrecap = l:list.regex_capture[l:i / l:ns]
                            
   74              0.000085   let l:augment = {}
                            
                              " these are the capture groups indexed by their 'open' id
   74              0.000070   let l:groups = {}
   74              0.000052   let l:id = 0
                            
   74              0.000064   if l:side ==# 'open'
   22              0.000045     for l:br in keys(l:thisrecap.need_grp)
                                  if empty(l:matches[l:br]) | continue | endif
                                  let l:groups[l:br] = l:matches[l:br]
   22              0.000011     endfor
   52              0.000016   else
   52              0.000132     let l:id = (l:side ==# 'close') ? len(l:thisrecap.mid_list)+1 : l:mid_id
                            
                                " groups here must be renumbered to match the open pattern
   52              0.000088     if has_key(l:thisrecap.grp_renu, l:id)
   52              0.000124       for [l:br, l:to] in items(l:thisrecap.grp_renu[l:id])
                                    let l:groups[l:to] = l:matches[l:br]
   52              0.000024       endfor
                                  " let l:groups[0] = l:matches[0]
   52              0.000018     endif
                            
                                " fill in augment pattern
                                " TODO all the augment patterns should match,
                                " but checking might be too slow
   52              0.000070     if has_key(l:thisrecap.aug_comp, l:id)
   52              0.000093       let l:aug = l:thisrecap.aug_comp[l:id][0]
   52   0.000830   0.000376       let l:augment.str = matchup#delim#fill_backrefs( l:aug.str, l:groups, 0)
   52              0.000140       let l:augment.unresolved = deepcopy(l:aug.outputmap)
   52              0.000018     endif
   74              0.000023   endif
                            
   74              0.000875   let l:result = { 'type'         : 'delim_tex', 'match'        : l:match, 'augment'      : l:augment, 'groups'       : l:groups, 'side'         : l:side, 'class'        : [(l:i / l:ns), l:id], 'get_matching' : s:engines.classic.get_matching, 'regexone'     : l:thisregex, 'regextwo'     : l:thisrecap, 'midmap'       : get(l:list, 'midmap', {}), 'highlighting' : get(a:opts, 'highlighting', 0),}
                            
   74              0.000060   return l:result

FUNCTION  <SNR>104_do_offscreen_statusline()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:567
Called 19 times
Total time:   0.043741
 Self time:   0.000680

count  total (s)   self (s)
   19              0.000021   let l:opts = {}
   19              0.000012   if a:manual
                                let l:opts.compact = 1
   19              0.000005   endif
   19   0.042975   0.000138   let [l:sl, l:lnum] = matchup#matchparen#status_str(a:offscreen, l:opts)
   19   0.000325   0.000101   if s:ensure_scroll_timer() && !a:manual
   19              0.000044     let l:sl .= '%{matchup#matchparen#scroll_update('.l:lnum.')}'
   19              0.000006   endif
                            
   19              0.000027   let w:matchup_statusline = l:sl
   19              0.000028   if !exists('w:matchup_oldstatus')
   19              0.000036     let w:matchup_oldstatus = &l:statusline
   19              0.000006   endif
   19              0.000011   if !a:manual
   19              0.000108     let &l:statusline = w:matchup_statusline
   19              0.000008   endif
                            
   19              0.000053   if exists('#User#MatchupOffscreenEnter')
                                doautocmd <nomodeline> User MatchupOffscreenEnter
   19              0.000007   endif

FUNCTION  <SNR>54_normalise_attrs()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlight.vim:137
Called 48 times
Total time:   0.001808
 Self time:   0.001808

count  total (s)   self (s)
   48              0.000096   let l:attr_map = copy(s:attr_map)
                            
  104              0.000082   for l:attr in a:hl[2:]
   56              0.000061     if has_key(l:attr_map, l:attr)
   56              0.000056       let l:attr_map[l:attr] = 1
                                elseif l:attr[:1] ==# 'no' && has_key(l:attr_map, l:attr[2:])
                                  let l:attr_map[l:attr[2:]] = 0
   56              0.000014     endif
  104              0.000032   endfor
                            
   48              0.000036   let l:result = []
  384              0.000236   for l:attr in keys(l:attr_map)
  336              0.000240     if l:attr_map[l:attr]
   48              0.000057       call add(l:result, l:attr)
  336              0.000083     endif
  384              0.000103   endfor
                            
   48              0.000066   return a:hl[:1] + l:result

FUNCTION  <SNR>84_NeovimAsyncOutputHandler()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:855
Called 16 times
Total time:   0.000185
 Self time:   0.000185

count  total (s)   self (s)
   16              0.000107         let s:nvim_async_output[-1] .= a:output[0]
   16              0.000061         call extend(s:nvim_async_output, a:output[1:])

FUNCTION  <SNR>110_effline()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/delim.vim:925
Called 480 times
Total time:   0.001261
 Self time:   0.001261

count  total (s)   self (s)
  480              0.001108   return a:expr ==# '.' ? s:eff_curpos[0] : line(a:expr)

FUNCTION  <SNR>68_pre_hook()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/mux.vim:109
Called 4 times
Total time:   0.001225
 Self time:   0.000078

count  total (s)   self (s)
    4              0.000008   let a:state.active = 1
                            
    4   0.000287   0.000021   let l:renderer = s:get_renderer(a:state.renderers)
                            
    4              0.000005   let a:state.current = l:renderer
                            
    4              0.000003   if l:renderer is 0
                                return
    4              0.000001   endif
                            
    4              0.000006   if has_key(l:renderer, 'pre_hook')
    4   0.000902   0.000021     call l:renderer.pre_hook(a:ctx)
    4              0.000001   endif

FUNCTION  <SNR>84_JsonEscape()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:433
Called 47 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
   47              0.000127         return substitute(a:str, '"', '\\"', 'g')

FUNCTION  <SNR>45_result()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/result.vim:23
Called 138 times
Total time:   0.021120
 Self time:   0.007560

count  total (s)   self (s)
  138              0.000143   if empty(a:kvs)
                                return a:result
  138              0.000038   endif
                            
  138              0.000115   let l:kvs = a:kvs
                            
  322              0.000341   while !empty(l:kvs)
  184              0.000192     let l:kv = l:kvs[0]
  184              0.000205     let l:kvs = l:kvs[1:]
  184              0.000168     let l:key = l:kv.key
  184              0.000195     let l:Value = l:kv.value
                            
  184              0.000218     if type(l:Value) is v:t_func
  138   0.014306   0.000747       let l:R = l:Value(a:ctx, get(a:result, l:key, v:null), get(a:result, 'data', {}))
                            
  138              0.000191       if type(l:R) is v:t_func
                                    return wilder#wait(l:R, {ctx, value -> wilder#resolve(ctx, s:result(l:kvs, ctx, s:add_key(a:result, l:key, value)))})
  138              0.000050       endif
                            
  138              0.000185       let a:result[l:key] = l:R
   46              0.000058     elseif type(l:Value) is v:t_list
   46              0.000138       let a:result[l:key] = get(a:result, l:key, []) + l:Value
                                elseif type(l:Value) is v:t_dict
                                  let a:result[l:key] = extend(get(a:result, l:key, {}), l:Value)
                                else
                                  let a:result[l:key] = l:Value
  184              0.000079     endif
  322              0.000181   endwhile
                            
  138              0.000099   return a:result

FUNCTION  <SNR>103_init_delim_regexes_generator()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/loader.vim:616
Called 4 times
Total time:   0.003129
 Self time:   0.001791

count  total (s)   self (s)
    4              0.000009   let l:list = b:matchup_delim_lists[a:list_name].regex_capture
                            
                              " build the full regex strings: order matters here
    4              0.000004   let l:regexes = {}
   28              0.000039   for [l:key, l:sidelist] in items(s:sidedict)
   24              0.000026     let l:relist = []
                            
  168              0.000085     for l:set in l:list
  384              0.000216       for l:side in l:sidelist
  240              0.000264         if strlen(l:set[l:side])
  177              0.000236           call add(l:relist, l:set[l:side])
  240              0.000070         endif
  384              0.000104       endfor
  168              0.000044     endfor
                            
   24   0.001514   0.000175     let l:regexes[l:key] = matchup#loader#remove_capture_groups( '\%(' . join(l:relist, '\|') . '\)')
   28              0.000012   endfor
                            
    4              0.000002   return l:regexes

FUNCTION  wilder#pipeline#clear_handlers()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipeline.vim:6
Called 4 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    4              0.000009   let s:last_cleared_id = s:id_index
    4              0.000007   let s:handler_registry = {}
    4              0.000007   let s:partial_results = {}

FUNCTION  matchup#matchparen#status_str()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:1026
Called 19 times
Total time:   0.042837
 Self time:   0.013830

count  total (s)   self (s)
   19              0.000030   let l:opts = a:0 ? a:1 : {}
   19   0.001059   0.000430   let l:adjust = matchup#quirks#status_adjust(a:offscreen)
   19              0.000027   let l:lnum = a:offscreen.lnum + l:adjust
   19              0.000032   let l:line = getline(l:lnum)
                            
   19              0.000016   let l:sl = ''
   19              0.000016   let l:trimming = 0
   19              0.000028   if get(l:opts, 'compact', 0)
                                let l:trimming = 1
   19              0.000007   else
   19   0.001083   0.000104     let l:sl = s:format_gutter(l:lnum, l:opts)
   19              0.000007   endif
                            
   19              0.000025   if has_key(l:opts, 'width')
                                " TODO subtract the gutter above more accurately
                                let l:room = l:opts.width - (wincol()-virtcol('.'))
   19              0.000007   else
   19              0.000070     let l:room = min([300, winwidth(0)]) - (wincol()-virtcol('.'))
   19              0.000007   endif
   19              0.000043   let l:room -= l:adjust ? 3+strdisplaywidth(a:offscreen.match) : 0
   19              0.000016   let l:lasthi = ''
  394              0.000277   for l:c in range(strlen(l:line))
  375              0.000961     if !l:adjust && a:offscreen.cnum <= l:c+1 && l:c+1 <= a:offscreen.cnum - 1 + strlen(a:offscreen.match)
                                  " TODO: we can't overlap groups, this might not be totally correct
   64   0.000552   0.000275       let l:curhi = s:wordish(a:offscreen) ? 'MatchWord' : 'MatchParen'
  311              0.000359     elseif char2nr(l:line[l:c]) < 32
                                  let l:curhi = 'SpecialKey'
  311              0.000076     else
  311   0.028751   0.001629       let l:curhi = synIDattr(s:synID(l:lnum, l:c+1, 1), 'name')
  311              0.000373       if empty(l:curhi)
   68              0.000057         let l:curhi = 'Normal'
  311              0.000114       endif
  375              0.000093     endif
  375              0.000784     let l:sl .= (l:curhi !=# l:lasthi ? '%#'.l:curhi.'#' : '')
  375              0.000356     if l:trimming && l:line[l:c] !~? '\s'
                                  let l:trimming = 0
  375              0.000100     endif
  375              0.000211     if !l:trimming
  375              0.000288       let l:room -= 1
  375              0.000228       if l:room <= 0
                                    break
  375              0.000092       endif
  375              0.000089     endif
  375              0.000169     if l:trimming
  375              0.000378     elseif l:line[l:c] ==# "\t"
                                  let l:sl .= repeat(' ', strdisplaywidth(strpart(l:line, 0, 1+l:c)) - strdisplaywidth(strpart(l:line, 0, l:c)))
  375              0.000458     elseif char2nr(l:line[l:c]) < 32
                                  let l:sl .= strtrans(l:line[l:c])
  375              0.000315     elseif l:line[l:c] ==? '%'
                                  let l:sl .= '%%'
  375              0.000108     else
  375              0.000410       let l:sl .= l:line[l:c]
  375              0.000103     endif
  375              0.000279     let l:lasthi = l:curhi
  394              0.000172   endfor
   19              0.000198   let l:sl = substitute(l:sl, '\s\+$', '', '') . '%<%#Normal#'
   19              0.000015   if l:adjust
                                let l:sl .= '%#LineNr# … %#Normal#' . '%#MatchParen#' . a:offscreen.match . '%#Normal#'
   19              0.000007   endif
   19              0.000030   if empty(a:offscreen.links.close.match)
                                let l:hi = s:wordish(a:offscreen.links.open) ? 'MatchWord' : 'MatchParen'
                                let l:sl .= ' ' . g:matchup_matchparen_end_sign . ' %#' . l:hi . '#' . a:offscreen.links.open.match . '%#Normal#'
   19              0.000006   endif
                            
   19              0.000025   return [l:sl, l:lnum]

FUNCTION  <SNR>58_prompt_post_hook()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:419
Called 4 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    4              0.000012   call timer_stop(a:state.timer)

FUNCTION  matchup#ts_engine#is_enabled()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/ts_engine.vim:17
Called 4 times
Total time:   0.001031
 Self time:   0.000835

count  total (s)   self (s)
    4              0.000011   if !has('nvim-0.5.0')
                                return 0
    4              0.000002   endif
    4   0.001010   0.000814   return +s:forward('is_enabled', a:bufnr)

FUNCTION  <SNR>104_ensure_scroll_timer()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:1101
Called 19 times
Total time:   0.000224
 Self time:   0.000224

count  total (s)   self (s)
   19              0.000072   if has('timers') && exists('*timer_pause')
   19              0.000030     if !exists('s:scroll_timer')
    1              0.000004       let s:scroll_timer = timer_start(50, 'matchup#matchparen#scroll_callback', { 'repeat': -1 })
    1              0.000002       call timer_pause(s:scroll_timer, 1)
   19              0.000007     endif
   19              0.000007   endif
                            
   19              0.000023   return exists('s:scroll_timer')

FUNCTION  matchup#ts_engine#is_hl_enabled()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/ts_engine.vim:24
Called 4 times
Total time:   0.000352
 Self time:   0.000035

count  total (s)   self (s)
    4              0.000009   if !has('nvim-0.5.0')
                                return 0
    4              0.000001   endif
    4   0.000336   0.000019   return +s:forward('is_hl_enabled', a:bufnr)

FUNCTION  <SNR>54_get_attrs_as_list()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlight.vim:209
Called 96 times
Total time:   0.005037
 Self time:   0.005037

count  total (s)   self (s)
   96              0.000093   let l:res = []
                            
  864              0.000432   for l:attr in s:attr_list
  768              0.000702     if has_key(a:attrs, l:attr)
   56              0.000042       if l:attr ==# 'inverse'
                                    let l:attr = 'reverse'
   56              0.000015       endif
                            
   56              0.000044       if a:attrs[l:attr]
   56              0.000075         call add(l:res, l:attr)
                                  else
                                    call add(l:res, 'no' . l:attr)
   56              0.000018       endif
  768              0.000164     endif
  864              0.000243   endfor
                            
   96              0.000056   return l:res

FUNCTION  <SNR>127_get_initial_char()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/better-escape.vim/plugin/better_escape.vim:34
Called 1 time
Total time:   0.002191
 Self time:   0.002096

count  total (s)   self (s)
    1              0.000002   let initial_chars = []
    2              0.000004   for l:shortcut in g:better_escape_shortcut
    1   0.002172   0.002077     let l:ch = better_escape#CharAtIdx(l:shortcut, 0)
    1              0.000004     let initial_chars += [l:ch]
    2              0.000002   endfor
                            
    1              0.000001   return initial_chars

FUNCTION  wilder#cmdline#replace()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:721
Called 1 time
Total time:   0.000038
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000036   0.000007   let l:result = wilder#cmdline#parse(a:ctx.cmdline)
                            
    1              0.000001   if l:result.pos == 0
    1              0.000001     return a:x
                              endif
                            
                              if wilder#cmdline#is_user_command(l:result.cmd)
                                let l:pos = len(l:result.cmdline)
                                while l:pos >= l:result.pos
                                  if l:result.cmdline[l:pos] ==# ' ' || l:result.cmdline[l:pos] ==# "\t"
                                    break
                                  endif
                            
                                  let l:pos -= 1
                                endwhile
                              else
                                let l:pos = l:result.pos - 1
                              endif
                            
                              return l:result.cmdline[: l:pos] . a:x

FUNCTION  <SNR>58_prompt()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:165
Called 89 times
Total time:   0.025905
 Self time:   0.020371

count  total (s)   self (s)
   89              0.000152   let l:cmdline = getcmdline()
   89              0.000120   let a:state.cmdpos = getcmdpos()
   89   0.005998   0.000464   let l:cmdline_data = s:get_cmdline_data(a:state, l:cmdline)
   89              0.000095   let l:hl = a:state.hl
                            
                              " cmdpos includes the prompt character
   89              0.000116   let l:cursor_pos = a:state.cmdpos - 1
                              " -1 as the prompt char is always drawn
   89              0.000108   let l:max_displaywidth = a:ctx.width - 1
   89              0.000075   let l:displaywidth = 0
   89              0.000129   let l:previous_start = len(l:cmdline)
   89              0.000079   let l:previous_end = 0
                            
                              " cursor is at end of cmdline
   89              0.000115   if l:cursor_pos >= len(l:cmdline)
                                " -1 for the cursor
   89              0.000089     let l:max_displaywidth -= 1
   89              0.000064     let l:displaywidth = 0
   89              0.000075     let l:prompt_str = ''
                            
                                " draw entire cmdline starting from the back
   89              0.000134     let l:i = len(l:cmdline_data) - 1
  720              0.000422     while l:i >= 0
                                  " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
  631              0.000628       let l:data = l:cmdline_data[l:i]
                            
  631              0.000733       if l:displaywidth + l:data[2] > l:max_displaywidth
                                    break
  631              0.000164       endif
                            
  631              0.000648       let l:displaywidth += l:data[2]
  631              0.000819       let l:prompt_str = l:data[0] . l:prompt_str
  631              0.000620       let l:previous_start = l:data[3]
                            
  631              0.000436       let l:i -= 1
  720              0.000269     endwhile
                            
   89              0.000118     let l:previous_end = len(l:cmdline)
   89              0.000217     let l:chunks = [[l:prompt_str, l:hl], [' ', a:state.cursor_hl]]
                              else
                                let l:chunks = v:null
                            
                                " check if the cursor fits within previous_start and previous_end
                                " if it does, draw the prompt with the same bounds
                                if strdisplaywidth(l:cmdline) <= l:max_displaywidth || (l:cursor_pos >= a:state.previous_start && l:cursor_pos < a:state.previous_end)
                                  let l:start_seen = 0
                                  let l:cursor_char = ''
                                  let l:before_cursor_str = ''
                                  let l:after_cursor_str = ''
                            
                                  let l:i = 0
                                  while l:i < len(l:cmdline_data)
                                    " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                    let l:data = l:cmdline_data[l:i]
                            
                                    if l:data[3] < a:state.previous_start
                                      let l:i += 1
                                      continue
                                    endif
                            
                                    if !l:start_seen
                                      let l:start_seen = 1
                                      let l:previous_start = l:data[3]
                                    endif
                            
                                    if l:data[3] > a:state.previous_end
                                      break
                                    endif
                            
                                    if l:displaywidth + l:data[2] > l:max_displaywidth
                                      break
                                    endif
                            
                                    let l:displaywidth += l:data[2]
                            
                                    if l:data[3] == l:cursor_pos
                                      let l:cursor_char = l:data[0]
                                    elseif l:data[3] < l:cursor_pos
                                      let l:before_cursor_str .= l:data[0]
                                    else
                                      let l:after_cursor_str .= l:data[0]
                                    endif
                            
                                    let l:previous_end = l:data[1] + l:data[3]
                            
                                    let l:i += 1
                                  endwhile
                            
                                  " max_displaywidth reached but cursor is not inside bounds
                                  if l:cursor_char !=# ''
                                    let l:chunks = [[l:before_cursor_str, l:hl], [l:cursor_char, a:state.cursor_hl], [l:after_cursor_str, l:hl]]
                                  endif
                                endif
                            
                                " cursor is not within old bounds, draw new bounds with cursor starting
                                " at the front or end depending on which direction it moved
                                if l:chunks is v:null
                                  let l:displaywidth = 0
                            
                                  if l:cursor_pos < a:state.previous_cursor_pos
                                    " cursor at start
                                    let l:cursor_char = ''
                                    let l:prompt_str = ''
                            
                                    let l:i = 0
                                    while l:i < len(l:cmdline_data)
                                      " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                      let l:data = l:cmdline_data[l:i]
                            
                                      if l:data[3] < l:cursor_pos
                                        let l:i += 1
                                        continue
                                      endif
                            
                                      if l:displaywidth + l:data[2] > l:max_displaywidth
                                        break
                                      endif
                            
                                      let l:displaywidth += l:data[2]
                            
                                      if l:data[3] == l:cursor_pos
                                        let l:previous_start = l:data[3]
                                        let l:cursor_char = l:data[0]
                                      else
                                        let l:prompt_str .= l:data[0]
                                      endif
                            
                                      let l:previous_end = l:data[3] + l:data[1]
                            
                                      let l:i += 1
                                    endwhile
                            
                                    let l:chunks = [[l:cursor_char, a:state.cursor_hl], [l:prompt_str, l:hl]]
                                  else
                                    " cursor at end
                                    let l:cursor_char = ''
                                    let l:prompt_str = ''
                            
                                    let l:i = len(l:cmdline_data) - 1
                                    while l:i >= 0
                                      " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                      let l:data = l:cmdline_data[l:i]
                            
                                      if l:data[3] > l:cursor_pos
                                        let l:i -= 1
                                        continue
                                      endif
                            
                                      if l:displaywidth + l:data[2] > l:max_displaywidth
                                        break
                                      endif
                            
                                      let l:displaywidth += l:data[2]
                            
                                      if l:data[3] == l:cursor_pos
                                        let l:previous_end = l:data[3]
                                        let l:cursor_char = l:data[0]
                                      else
                                        let l:prompt_str = l:data[0] . l:prompt_str
                                      endif
                            
                                      let l:previous_start = l:data[3] + l:data[1]
                            
                                      let l:i -= 1
                                    endwhile
                            
                                    let l:chunks = [[l:prompt_str, l:hl], [l:cursor_char, a:state.cursor_hl]]
                                  endif
                                endif
   89              0.000034   endif
                            
                              " if there is space leftover, add characters depending on the direction
                              " which the cursor moved
   89              0.000085   if l:displaywidth < l:max_displaywidth
   89              0.000073     let l:str = ''
                            
                                " cursor moved left, add characters to the end
   89              0.000095     if l:cursor_pos < a:state.previous_cursor_pos
    9              0.000008       let l:i = 0
   59              0.000086       while l:i < len(l:cmdline_data)
                                    " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
   50              0.000072         let l:data = l:cmdline_data[l:i]
                            
   50              0.000069         if l:data[3] < l:previous_end
   50              0.000053           let l:i += 1
   50              0.000029           continue
                                    endif
                            
                                    if l:displaywidth + l:data[2] > l:max_displaywidth
                                      break
                                    endif
                            
                                    let l:displaywidth += l:data[2]
                                    let l:str .= l:data[0]
                                    let l:previous_end = l:data[1] + l:data[3]
                            
                                    let l:i += 1
    9              0.000007       endwhile
                            
    9              0.000022       call add(l:chunks, [l:str, l:hl])
   80              0.000034     else
                                  " cursor moved right, add characters to the start
   80              0.000108       let l:i = len(l:cmdline_data) - 1
  661              0.000362       while l:i >= 0
                                    " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
  581              0.000539         let l:data = l:cmdline_data[l:i]
                            
  581              0.000496         if l:data[3] >= l:previous_start
  581              0.000384           let l:i -= 1
  581              0.000212           continue
                                    endif
                            
                                    if l:displaywidth + l:data[2] > l:max_displaywidth
                                      break
                                    endif
                            
                                    let l:displaywidth += l:data[2]
                                    let l:str = l:data[0] . l:str
                                    let l:previous_start = l:data[3]
                            
                                    let l:i -= 1
   80              0.000047       endwhile
                            
   80              0.000189       call insert(l:chunks, [l:str, l:hl], 0)
   89              0.000035     endif
   89              0.000027   endif
                            
                              " add padding for the rest of the leftover space
   89              0.000077   if l:displaywidth < l:max_displaywidth
   89              0.000300     call add(l:chunks, [repeat(' ', l:max_displaywidth - l:displaywidth), l:hl])
   89              0.000029   endif
                            
   89              0.000205   call insert(l:chunks, [getcmdtype(), l:hl], 0)
                            
   89              0.000104   let a:state.previous_start = l:previous_start
   89              0.000084   let a:state.previous_end = l:previous_end
   89              0.000089   let a:state.previous_cursor_pos = l:cursor_pos
                            
   89              0.000063   return l:chunks

FUNCTION  <SNR>84_GetCurrentFile()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:423
Called 378 times
Total time:   0.006485
 Self time:   0.006485

count  total (s)   self (s)
  378              0.006233         return expand("%:p")

FUNCTION  wilder#cmdline#main#skip_nonwhitespace()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline/main.vim:699
Called 11 times
Total time:   0.000502
 Self time:   0.000372

count  total (s)   self (s)
   11              0.000022   if empty(a:ctx.cmdline[a:ctx.pos])
    1              0.000001     return 0
   10              0.000004   endif
                            
   34   0.000313   0.000184   while !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
   32              0.000033     let a:ctx.pos += 1
                            
   32              0.000050     if empty(a:ctx.cmdline[a:ctx.pos])
    8              0.000007       return 0
   24              0.000008     endif
   26              0.000011   endwhile
                            
    2              0.000001   return 1

FUNCTION  wilder#renderer#call_component_pre_hook()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer.vim:74
Called 52 times
Total time:   0.000328
 Self time:   0.000183

count  total (s)   self (s)
   52              0.000092   if type(a:component) is v:t_dict && has_key(a:component, 'pre_hook')
    4   0.000167   0.000023     call a:component['pre_hook'](a:ctx)
   52              0.000015   endif

FUNCTION  GetLuaIndent()
    Defined: /usr/share/nvim/runtime/indent/lua.vim:29
Called 4 times
Total time:   0.000265
 Self time:   0.000265

count  total (s)   self (s)
                              " Find a non-blank line above the current line.
    4              0.000029   let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
    4              0.000007   if prevlnum == 0
                                return 0
    4              0.000003   endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{'
    4              0.000009   let ind = indent(prevlnum)
    4              0.000007   let prevline = getline(prevlnum)
    4              0.000055   let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
    4              0.000004   if midx == -1
    4              0.000014     let midx = match(prevline, '{\s*$')
    4              0.000003     if midx == -1
    2              0.000014       let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
    4              0.000002     endif
    4              0.000001   endif
                            
    4              0.000002   if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
    2              0.000015     if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
    2              0.000003       let ind = ind + shiftwidth()
    2              0.000001     endif
    4              0.000001   endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until and '}'
                              " This is the part that requires 'indentkeys'.
    4              0.000031   let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\)')
    4              0.000009   if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
    1              0.000001     let ind = ind - shiftwidth()
    4              0.000001   endif
                            
    4              0.000003   return ind

FUNCTION  <SNR>110_get_delim_multi()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/delim.vim:43
Called 361 times
Total time:   0.202887
 Self time:   0.010482

count  total (s)   self (s)
  361              0.000506   let l:best = {}
  648              0.001962   for l:e in get(get(b:, 'matchup_active_engines', {}), a:opts.type, [])
  361   0.195535   0.003130     let l:res = call(s:engines[l:e].get_delim, [a:opts])
  361              0.000445     if empty(l:res)
  287              0.000213       continue
   74              0.000024     endif
   74              0.000075     if a:opts.direction ==# 'current'
   74              0.000052       return l:res
                                elseif a:opts.direction ==# 'next' && (empty(l:best) || matchup#pos#smaller(l:res, l:best))
                                  let l:best = l:res
                                elseif a:opts.direction ==# 'prev' && (empty(l:best) || matchup#pos#larger(l:res, l:best))
                                  let l:best = l:res
                                endif
  287              0.000191   endfor
  287              0.000249   return l:best

FUNCTION  <SNR>84_InitAndHandleActivity()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:720
Called 12 times
Total time:   0.005388
 Self time:   0.000256

count  total (s)   self (s)
   12   0.000148   0.000055         call s:SetupDebugMode()
   12   0.000361   0.000120         call s:SetupConfigFile()
   12   0.004867   0.000069         call s:HandleActivity(a:is_write)

FUNCTION  <SNR>54_make_hl_from_list()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlight.vim:158
Called 16 times
Total time:   0.002708
 Self time:   0.000900

count  total (s)   self (s)
   16   0.000607   0.000072   let l:term_hl = s:normalise_attrs(a:args[0])
   16   0.000727   0.000078   let l:cterm_hl = s:normalise_attrs(a:args[1])
   16   0.000695   0.000072   let l:gui_hl = s:normalise_attrs(a:args[2])
                            
   16              0.000022   let l:cmd = 'hi! ' . a:name . ' '
                            
   16              0.000018   let l:term_attr = l:term_hl[2:]
   16              0.000017   if len(l:term_hl) >= 2
                                let l:cmd .= 'term=' . join(l:term_attr, ',') . ' '
   16              0.000005   endif
                            
   16              0.000019   let l:cterm_attr = l:cterm_hl[2:]
   16              0.000017   if !empty(l:cterm_attr)
   12              0.000029     let l:cmd .= 'cterm=' . join(l:cterm_attr, ',') . ' '
   16              0.000005   endif
                            
   16              0.000015   if len(l:cterm_hl) >= 1
   16              0.000014     if l:cterm_hl[0] >= 0
   16              0.000027       let l:cmd .= 'ctermfg=' . l:cterm_hl[0] . ' '
   16              0.000005     endif
                            
   16              0.000024     if len(l:cterm_hl) >= 2 && l:cterm_hl[1] >= 0
   16              0.000022       let l:cmd .= 'ctermbg=' . l:cterm_hl[1] . ' '
   16              0.000005     endif
   16              0.000004   endif
                            
   16              0.000020   let l:gui_attr = l:gui_hl[2:]
   16              0.000016   if !empty(l:gui_attr)
   12              0.000027     let l:cmd .= 'gui=' . join(l:gui_attr, ',') . ' '
   16              0.000005   endif
                            
   16              0.000015   if len(l:gui_hl) >= 1
   16              0.000023     if type(l:gui_hl[0]) == v:t_number
                                  let l:cmd .= 'guifg=' . printf('#%06x', l:gui_hl[0]) . ' '
   16              0.000005     else
   16              0.000025       let l:cmd .= 'guifg=' . l:gui_hl[0] . ' '
   16              0.000005     endif
                            
   16              0.000015     if len(l:gui_hl) >= 2
   16              0.000019       if type(l:gui_hl[1]) == v:t_number
   16              0.000044         let l:cmd .= 'guibg=' . printf('#%06x', l:gui_hl[1]) . ' '
                                  else
                                    let l:cmd .= 'guibg=' . l:gui_hl[1] . ' '
   16              0.000005       endif
   16              0.000004     endif
   16              0.000004   endif
                            
   16              0.000078   exe l:cmd

FUNCTION  wilder#cmdline#prepare_getcompletion()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:20
Called 46 times
Total time:   0.001961
 Self time:   0.000803

count  total (s)   self (s)
   46              0.000075   let a:res.match_arg = a:res.arg
   46              0.000156   let a:res.expand_arg = has_key(a:res, 'subcommand_start') ? a:res.cmdline[a:res.subcommand_start :] : a:res.arg
                            
   46              0.000030   if !a:fuzzy
                                if a:res.expand ==# 'tags' && !empty(a:res.expand_arg) && a:res.expand_arg[0] !=# '/'
                                  " Search taglist for tags starting with expand_arg
                                  let a:res.expand_arg = '/^' . a:res.expand_arg
                                endif
                            
                                return a:res
   46              0.000013   endif
                            
   46   0.001411   0.000253   return s:prepare_fuzzy_completion(a:ctx, a:res, a:use_python)

FUNCTION  <lambda>155()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/component/popupmenu_devicons.vim:20
Called 86 times
Total time:   0.001194
 Self time:   0.000358

count  total (s)   self (s)
                            return s:devicons(l:state, ctx, result)

FUNCTION  <SNR>117_post_hook()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:236
Called 4 times
Total time:   0.001389
 Self time:   0.000099

count  total (s)   self (s)
    4   0.000052   0.000026   call wilder#pipeline#clear_handlers()
                            
    4              0.000010   if has_key(s:opts.renderer, 'post_hook')
    4   0.001306   0.000043     call s:opts.renderer.post_hook({})
    4              0.000001   endif
                            
    4              0.000006   if has_key(s:opts, 'post_hook')
                                call s:opts.post_hook({})
    4              0.000001   endif

FUNCTION  <lambda>157()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/component/popupmenu_scrollbar.vim:13
Called 86 times
Total time:   0.001936
 Self time:   0.000388

count  total (s)   self (s)
                            return s:scrollbar(l:state, ctx, result)

FUNCTION  wilder#wait()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder.vim:55
Called 46 times
Total time:   0.000596
 Self time:   0.000338

count  total (s)   self (s)
   46              0.000047   if !a:0
                                return wilder#pipeline#wait(a:f)
   46              0.000037   elseif a:0 == 1
   46   0.000427   0.000169     return wilder#pipeline#wait(a:f, a:1)
                              else
                                return wilder#pipeline#wait(a:f, a:1, a:2)
                              endif

FUNCTION  <lambda>50()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1127
Called 46 times
Total time:   0.000365
 Self time:   0.000198

count  total (s)   self (s)
                            return wilder#cmdline#is_file_expansion(res.expand)

FUNCTION  <SNR>68_post_hook()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/mux.vim:125
Called 4 times
Total time:   0.001174
 Self time:   0.000061

count  total (s)   self (s)
    4              0.000006   let a:state.active = 0
                            
    4              0.000006   let l:renderer = a:state.current
                            
    4              0.000004   if l:renderer is 0
                                return
    4              0.000002   endif
                            
    4              0.000003   let a:state.current = 0
                            
    4              0.000007   if has_key(l:renderer, 'post_hook')
    4   0.001134   0.000022     call l:renderer.post_hook(a:ctx)
    4              0.000002   endif

FUNCTION  wilder#cmdline#is_substitute_command()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:850
Called 149 times
Total time:   0.000328
 Self time:   0.000328

count  total (s)   self (s)
  149              0.000286   return has_key(s:substitute_commands, a:cmd)

FUNCTION  <SNR>121_run()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipeline.vim:118
Called 598 times
Total time:   0.391331
 Self time:   0.032817

count  total (s)   self (s)
  598              0.000834   if a:x is v:false || a:x is v:true
                                call a:on_finish(a:ctx, a:x)
                                return
  598              0.000185   endif
                            
  598              0.000734   if type(a:x) is v:t_func
                                let l:ctx = copy(a:ctx)
                                call s:prepare_call(a:x, a:pipeline, a:on_finish, a:on_error, l:ctx, a:i)
                                return
  598              0.000162   endif
                            
  598              0.000511   let l:x = a:x
  598              0.000446   let l:i = a:i
                            
 1472              0.001902   while l:i < len(a:pipeline)
 1288              0.001889     let l:F = a:pipeline[l:i]
                            
 1288              0.001552     if type(l:F) isnot v:t_func
                                  call a:on_error(a:ctx, 'pipeline: expected function but got: ' . string(l:F))
                                  return
 1288              0.000356     endif
                            
 1288              0.000464     try
 1288   0.175071   0.013003       let l:Result = l:F(a:ctx, l:x)
                                catch
                                  call a:on_error(a:ctx, 'pipeline: ' . v:exception)
                                  return
 1288              0.000514     endtry
                            
 1288              0.001690     if l:Result is v:false || l:Result is v:true
  230              0.006697       call a:on_finish(a:ctx, l:Result)
  230              0.000102       return
 1058              0.000304     endif
                            
 1058              0.001340     if type(l:Result) is v:t_func
  184              0.000365       let l:ctx = copy(a:ctx)
  184   0.004333   0.001161       call s:prepare_call(l:Result, a:pipeline, a:on_finish, a:on_error, l:ctx, l:i+1)
  184              0.000104       return
  874              0.000218     endif
                            
  874              0.000825     let l:x = l:Result
  874              0.000701     let l:i += 1
 1058              0.000529   endwhile
                            
  184   0.027567   0.000705   call a:on_finish(a:ctx, l:x)

FUNCTION  matchup#loader#refresh_match_words()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/loader.vim:107
Called 361 times
Total time:   0.008874
 Self time:   0.008874

count  total (s)   self (s)
  361              0.001191   if get(b:, 'match_words', ':') !~# ':'
                                call matchup#perf#tic('refresh')
                            
                                " protect the cursor from the match_words function
                                let l:save_pos = matchup#pos#get_cursor()
                                let l:match_words = ''
                                execute 'let l:match_words =' b:match_words
                                if l:save_pos != matchup#pos#get_cursor()
                                  call matchup#pos#set_cursor(l:save_pos)
                                endif
                            
                                call matchup#perf#toc('refresh', 'function')
                            
                                if has_key(s:match_word_cache, l:match_words)
                                  let b:matchup_delim_lists = s:match_word_cache[l:match_words].delim_lists
                                  let b:matchup_delim_re = s:match_word_cache[l:match_words].delim_regexes
                                  call matchup#perf#toc('refresh', 'cache_hit')
                                else
                                  " re-parse match words
                                  let b:matchup_delim_lists = s:init_delim_lists(0, 0)
                                  let b:matchup_delim_re = s:init_delim_regexes()
                                  let s:match_word_cache[l:match_words] = { 'delim_lists'  : b:matchup_delim_lists, 'delim_regexes': b:matchup_delim_re,}
                                  call matchup#perf#toc('refresh', 'parse')
                                endif
  361              0.000145   endif

FUNCTION  matchup#quirks#status_adjust()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/quirks.vim:40
Called 19 times
Total time:   0.000422
 Self time:   0.000411

count  total (s)   self (s)
   19   0.000056   0.000044   if a:offscreen.match ==# '{' && matchup#quirks#isclike()
                                let [l:a, l:b] = [indent(a:offscreen.lnum), indent(a:offscreen.links.close.lnum)]
                                if strpart(getline(a:offscreen.lnum),            0, a:offscreen.cnum-1) =~# '^\s*$'
                                  let l:target = l:a
                                elseif l:a != l:b
                                  let l:target = l:b
                                else
                                  return 0
                                endif
                                " go up to next line with same indent (up to s:adjust_max)
                                for l:adjust in range(-1, -s:adjust_max, -1)
                                  let l:lnum = a:offscreen.lnum + l:adjust
                                  if getline(l:lnum) =~? '^\s*$'
                                    break
                                  endif
                                  if indent(l:lnum) == l:target && getline(l:lnum) !~? '^\s*\%(#\|/\*\|//\)'
                                    return l:adjust
                                  endif
                                endfor
   19              0.000006   endif
                            
   19              0.000012   return 0

FUNCTION  wilder#renderer#pre_draw()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer.vim:52
Called 89 times
Total time:   0.014461
 Self time:   0.005894

count  total (s)   self (s)
   89              0.000108   let l:should_draw = 0
                            
 1068              0.000752   for l:Component in a:components
  979   0.012754   0.004187     let l:should_draw += s:pre_draw(l:Component, a:ctx, a:result)
 1068              0.000423   endfor
                            
   89              0.000076   return l:should_draw

FUNCTION  <SNR>110_get_delim()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/delim.vim:325
Called 361 times
Total time:   0.192405
 Self time:   0.067282

count  total (s)   self (s)
                              " arguments: {{{2
                              "   opts = {
                              "     'direction'   : 'next' | 'prev' | 'current'
                              "     'type'        : 'delim_tex'
                              "                   | 'delim_all'
                              "                   | 'all'
                              "     'side'        : 'open'     | 'close'
                              "                   | 'both'     | 'mid'
                              "                   | 'both_all' | 'open_mid'
                              "   }
                              "
                              "  }}}2
                              " returns: {{{2
                              "   delim = {
                              "     lnum     : line number
                              "     cnum     : column number
                              "     type     : e.g., 'delim_tex'
                              "     match    : the actual text match
                              "     side     : 'open' | 'close' | 'mid'
                              "     class    : [ c1, c2 ] identifies the kind of match_words
                              "     skip     : skip state
                              "     get_matching: callback used to get matching delims
                              "     highlighting: whether the request was for highlighting
                              "
                              "     ... Parser dependent ...
                              "     augment  : how to match a corresponding open
                              "     groups   : dict of captured groups
                              "     regexone : the regex items, like \1foo
                              "     regextwo : the regex_capture items, like \(group\)foo
                              "     midmap   : ??
                              "   }
                              "
                              " }}}2
                            
  361              0.000729   if !get(b:, 'matchup_delim_enabled', 0)
                                return {}
  361              0.000124   endif
                            
  361              0.001323   if has('*state') && state('a') !=# '' | return {} | endif
                            
  361   0.002544   0.001391   call matchup#perf#tic('s:get_delim')
                            
  361   0.002005   0.001360   let l:save_pos = matchup#pos#get_cursor()
                            
  361   0.010499   0.001625   call matchup#loader#refresh_match_words()
                            
                              " this contains all the patterns for the specified type and side
  361              0.001016   let l:re = b:matchup_delim_re[a:opts.type][a:opts.side]
                            
  361              0.000592   let l:cursorpos = col('.')
                            
  361              0.000649   let l:insertmode = get(a:opts, 'insertmode', 0)
  361              0.000431   if l:cursorpos > 1 && l:insertmode
  123              0.000179     let l:cursorpos -= 1
  361              0.000119   endif
  361              0.001279   if l:cursorpos > strlen(getline('.')) && stridx("vV\<c-v>", mode()) > -1
    4              0.000005     let l:cursorpos -= 1
  361              0.000101   endif
                            
  361   0.002300   0.001647   call matchup#delim#set_invert_skip(0)
                            
  361              0.000423   if a:opts.direction ==# 'current'
  361              0.001718     let l:check_skip = get(a:opts, 'check_skip', g:matchup_delim_noskips >= 2 || g:matchup_delim_noskips >= 1     && getline(line('.'))[l:cursorpos-1] =~? '[^[:punct:]]')
  361              0.000673     if l:check_skip && matchup#delim#skip(line('.'), l:cursorpos)
                                  return {}
  361              0.000123     endif
                              else
                                " check skip if cursor is not currently in skip
                                let l:check_skip = get(a:opts, 'check_skip', !matchup#delim#skip(line('.'), l:cursorpos) || g:matchup_delim_noskips >= 2)
  361              0.000123   endif
                            
  361              0.000518   let a:opts.cursorpos = l:cursorpos
                            
                              " for current, we want to find matches that end after the cursor
                              " note: we expect this to give false-positives with \ze
  361              0.000347   if a:opts.direction ==# 'current'
  361              0.000954     let l:re .= '\%>'.(l:cursorpos).'c'
  361              0.000135   endif
                            
                              " allow overlapping delimiters
                              " without this, the > in <tag> would not be found
  361              0.000839   if b:matchup_delim_re[a:opts.type]._engine_info.has_zs[a:opts.side]
                                let l:save_cpo = &cpo
                                noautocmd set cpo-=c
  361              0.000158   else
                                " faster than changing cpo but doesn't work right with \zs
  361              0.000446     let l:re .= '\&'
  361              0.000139   endif
                            
  361              0.000419   let l:need_restore_cursor = 0
                            
                              " stopline may depend on the current action
  361              0.000805   let l:stopline = get(a:opts, 'stopline', s:stopline)
                            
                              " in the first pass, we get matching line and column numbers
                              " this is intended to be as fast as possible, with no capture groups
                              " we look for a match on this line (if direction == current)
                              " or forwards or backwards (if direction == next or prev)
                              " for current, we actually search leftwards from the cursor
  361              0.000305   while 1
  361   0.002234   0.001432     let l:to = matchup#perf#timeout()
  361              0.016238     let [l:lnum, l:cnum] = a:opts.direction ==# 'next' ? searchpos(l:re, 'cnW', line('.') + l:stopline, l:to) : a:opts.direction ==# 'prev'   ? searchpos(l:re, 'bcnW',               max([line('.') - l:stopline, 1]), l:to)   : searchpos(l:re, l:insertmode ? 'bnW' : 'bcnW',               line('.'), l:to)
  361              0.000887     if l:lnum == 0 | break | endif
                            
                                " note: the skip here should not be needed
                                " in 'current' mode, but be explicit
   74              0.000509     if a:opts.direction !=# 'current' && (l:check_skip || g:matchup_delim_noskips == 1     && getline(l:lnum)[l:cnum-1] =~? '[^[:punct:]]') && matchup#delim#skip(l:lnum, l:cnum) && (a:opts.direction ==# 'prev' ? (l:lnum > 1 || l:cnum > 1)     : (l:lnum < line('$') || l:cnum < len(getline('$'))))
                            
                                  " invalid match, move cursor and keep looking
                                  call matchup#pos#set_cursor(a:opts.direction ==# 'next' ? matchup#pos#next(l:lnum, l:cnum) : matchup#pos#prev(l:lnum, l:cnum))
                                  let l:need_restore_cursor = 1
                                  continue
   74              0.000028     endif
                            
   74              0.000035     break
  361              0.000333   endwhile
                            
                              " restore cpo if necessary
                              " note: this messes with cursor position
  361              0.000545   if exists('l:save_cpo')
                                noautocmd let &cpo = l:save_cpo
                                let l:need_restore_cursor = 1
  361              0.000134   endif
                            
                              " restore cursor
  361              0.000264   if l:need_restore_cursor
                                call matchup#pos#set_cursor(l:save_pos)
  361              0.000110   endif
                            
  361   0.009282   0.001732   call matchup#perf#toc('s:get_delim', 'first_pass')
                            
                              " nothing found, leave now
  361              0.000286   if l:lnum == 0
  287   0.005593   0.001119     call matchup#perf#toc('s:get_delim', 'nothing_found')
  287              0.000299     return {}
   74              0.000022   endif
                            
   74   0.001140   0.000296   if matchup#perf#timeout_check()
                                return {}
   74              0.000022   endif
                            
   74              0.000086   let l:skip_state = 0
   74              0.000176   if !l:check_skip && (!&synmaxcol || l:cnum <= &synmaxcol)
                                " XXX: workaround an apparent obscure vim bug where the
                                " reported syntax id is incorrect on the first synID() call
   74   0.035244   0.000349     call matchup#delim#skip(l:lnum, l:cnum)
   74   0.001257   0.000389     if matchup#perf#timeout_check()
                                  return {}
   74              0.000027     endif
                            
   74   0.012940   0.000377     let l:skip_state = matchup#delim#skip(l:lnum, l:cnum)
   74              0.000040   endif
                            
                              " now we get more data about the match in this position
                              " there may be capture groups which need to be stored
                            
                              " result stub, to be filled by the parser when there is a match
   74              0.000413   let l:result = { 'lnum'     : l:lnum, 'cnum'     : l:cnum, 'type'     : '', 'match'    : '', 'side'     : '', 'class'    : [], 'skip'     : l:skip_state,}
                            
   74              0.000325   for l:P in s:engines.classic.parsers[a:opts.type]
   74   0.051034   0.000595     let l:parser_result = l:P(l:lnum, l:cnum, a:opts)
   74              0.000098     if !empty(l:parser_result)
   74              0.000357       let l:result = extend(l:parser_result, l:result, 'keep')
   74              0.000034       break
                                endif
   74              0.000042   endfor
                            
   74   0.001806   0.000443   call matchup#perf#toc('s:get_delim', 'got_results')
                            
   74              0.000138   return empty(l:result.type) ? {} : l:result

FUNCTION  <SNR>63_set_firstline()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:217
Called 89 times
Total time:   0.000821
 Self time:   0.000821

count  total (s)   self (s)
   89              0.000114   if self.state.window_state ==# 'hidden'
                                return
   89              0.000030   endif
                            
   89              0.000073   if self.state.window_state ==# 'pending'
                                let self.state.firstline = a:line
                                return
   89              0.000023   endif
                            
   89              0.000352   call nvim_win_set_cursor(self.state.win, [a:line, 0])

FUNCTION  <SNR>121_prepare_call()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 184 times
Total time:   0.003172
 Self time:   0.003172

count  total (s)   self (s)
  184              0.001377   let l:handler = { 'on_finish': {ctx, x -> s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)}, 'on_error': {ctx, x -> a:on_error(ctx, x)}, }
                            
  184              0.000207   let s:id_index += 1
  184              0.000220   let l:handler_id = s:id_index
  184              0.000386   let s:handler_registry[s:id_index] = l:handler
                            
  184              0.000749   call timer_start(0, {_ -> s:call(a:f, a:ctx, l:handler_id)})

FUNCTION  matchup#perf#toc()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/perf.vim:19
Called 1395 times
Total time:   0.024643
 Self time:   0.024643

count  total (s)   self (s)
 1395              0.004827   let l:elapsed = s:Reltimefloat(reltime(s:time_start[a:context]))
                            
 1395              0.002256   let l:key = a:context.'#'.a:state
 1395              0.002431   if has_key(g:matchup#perf#times, l:key)
 1395              0.002261     if l:elapsed > g:matchup#perf#times[l:key].maximum
   38              0.000078       let g:matchup#perf#times[l:key].maximum = l:elapsed
 1395              0.000492     endif
 1395              0.002197     let g:matchup#perf#times[l:key].last = l:elapsed
 1395              0.004075     let g:matchup#perf#times[l:key].emavg = s:alpha*l:elapsed + (1-s:alpha)*g:matchup#perf#times[l:key].emavg
                              else
                                let g:matchup#perf#times[l:key] = { 'maximum' : l:elapsed, 'emavg'   : l:elapsed, 'last'    : l:elapsed,}
 1395              0.000464   endif

FUNCTION  <SNR>40_mru_set()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cache.vim:45
Called 25 times
Total time:   0.000824
 Self time:   0.000186

count  total (s)   self (s)
   25              0.000057   let self['_cache'][a:key] = a:value
                            
   25   0.000749   0.000111   call self.mru_update(a:key)

FUNCTION  <SNR>61_render_lines_from_timer()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:275
Called 95 times
Total time:   0.696393
 Self time:   0.001627

count  total (s)   self (s)
                              " Multiple renders might be queued, skip if there is a newer render
   95              0.000190   if a:render_id != a:state.render_id || !a:state.active
    6              0.000004     return
   89              0.000033   endif
                            
   89   0.696010   0.001245   call s:render_lines(a:state, a:ctx, a:result)

FUNCTION  <SNR>63_new()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:43
Called 4 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
                              " If the buffer is somehow unloaded, bufload(self.state.buf) doesn't restore
                              " it so we have to create a new one
    4              0.000016   if !bufexists(self.state.buf) || !bufloaded(self.state.buf)
                                let self.state.buf = s:new_buf()
    4              0.000001   endif
                            
    4              0.000008   if !bufexists(self.state.dummy_buf) || !bufloaded(self.state.dummy_buf)
                                let self.state.dummy_buf = s:new_buf()
    4              0.000001   endif
                            
    4              0.000010   let self.state.normal_highlight = get(a:opts, 'normal_highlight', 'Normal')
    4              0.000007   let self.state.pumblend = get(a:opts, 'pumblend', -1)
    4              0.000006   let self.state.zindex = get(a:opts, 'zindex', 0)

FUNCTION  <SNR>84_StripWhitespace()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:269
Called 8 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
    8              0.000106         return substitute(a:str, '^\s*\(.\{-}\)\s*$', '\1', '')

FUNCTION  wilder#cmdline#skip_range#do()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline/skip_range.vim:3
Called 24 times
Total time:   0.000788
 Self time:   0.000788

count  total (s)   self (s)
   24              0.000109   while a:ctx.pos < len(a:ctx.cmdline) && stridx(s:chars, a:ctx.cmdline[a:ctx.pos]) != -1
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                                if l:char ==# '\'
                                  if a:ctx.pos + 1 >= len(a:ctx.cmdline)
                                    return 1
                                  endif
                            
                                  let l:second_char = a:ctx.cmdline[a:ctx.pos + 1]
                            
                                  if l:second_char ==# '?' || l:second_char ==# '/' || l:second_char ==# '&'
                                    let a:ctx.pos += 2
                                  else
                                    return 1
                                  endif
                                elseif l:char ==# "'"
                                  let a:ctx.pos += 1
                                elseif l:char ==# '/' || l:char ==# '?'
                                  let l:delim = l:char
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline) && a:ctx.cmdline[a:ctx.pos] !=# l:delim
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' && a:ctx.pos + 1 < len (a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos += 1
   24              0.000027   endwhile

FUNCTION  <SNR>120_redraw()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer.vim:9
Called 89 times
Total time:   0.145949
 Self time:   0.145949

count  total (s)   self (s)
   89              0.000208   if a:apply_incsearch_fix && &incsearch && (getcmdtype() ==# '/' || getcmdtype() ==# '?')
                                call feedkeys("\<C-R>\<BS>", 'n')
                                return
   89              0.000025   endif
                            
   89              0.000065   if a:is_redrawstatus
                                redrawstatus
   89              0.000032   else
   89              0.145216     redraw
   89              0.000126   endif

FUNCTION  matchup#matchparen#scroll_update()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:1121
Called 63 times
Total time:   0.000525
 Self time:   0.000525

count  total (s)   self (s)
   63              0.000292   if line('w0') <= a:lnum && a:lnum <= line('w$') && exists('s:scroll_timer')
    2              0.000005     call timer_pause(s:scroll_timer, 0)
   63              0.000035   endif
   63              0.000048   return ''

FUNCTION  <SNR>68_get_renderer()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/mux.vim:68
Called 103 times
Total time:   0.019303
 Self time:   0.001747

count  total (s)   self (s)
  206              0.000463   for [l:Check, l:renderer] in a:renderers
  206   0.018472   0.000915     if l:Check({})
  103              0.000086       return l:renderer
  103              0.000037     endif
  103              0.000052   endfor
                            
                              return 0

FUNCTION  <SNR>84_GetHeartbeatsJson()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:610
Called 5 times
Total time:   0.001183
 Self time:   0.000838

count  total (s)   self (s)
    5              0.000007         let arr = []
    5              0.000004         let loop_count = 1
   30              0.000025         for heartbeat in s:heartbeats_buffer
   25   0.000211   0.000130             let heartbeat_str = '{"entity": "' . s:JsonEscape(heartbeat.entity) . '", '
   25   0.000333   0.000129             let heartbeat_str = heartbeat_str . '"timestamp": ' . s:OrderTime(heartbeat.time, loop_count) . ', '
   25              0.000030             let heartbeat_str = heartbeat_str . '"is_write": '
   25              0.000019             if heartbeat.is_write
    8              0.000008                 let heartbeat_str = heartbeat_str . 'true'
   17              0.000005             else
   17              0.000017                 let heartbeat_str = heartbeat_str . 'false'
   25              0.000008             endif
   25              0.000030             if has_key(heartbeat, 'language')
   22   0.000171   0.000111                 let heartbeat_str = heartbeat_str . ', "alternate_language": "' . s:JsonEscape(heartbeat.language) . '"'
   25              0.000009             endif
   25              0.000028             let heartbeat_str = heartbeat_str . '}'
   25              0.000063             let arr = arr + [heartbeat_str]
   25              0.000023             let loop_count = loop_count + 1
   30              0.000014         endfor
    5              0.000041         let s:heartbeats_buffer = []
    5              0.000029         return '[' . join(arr, ',') . ']'

FUNCTION  matchup#ts_syntax#lang_skip()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/ts_syntax.vim:21
Called 480 times
Total time:   0.029559
 Self time:   0.002289

count  total (s)   self (s)
  480   0.029416   0.002147   return s:forward('lang_skip', a:lnum, a:col)

FUNCTION  <SNR>117_start()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:94
Called 4 times
Total time:   0.013805
 Self time:   0.000517

count  total (s)   self (s)
    4   0.000052   0.000024   if !wilder#main#in_mode() || !s:enabled
                                call wilder#main#stop()
                                return
    4              0.000003   endif
                            
    4              0.000007   if !s:init && wilder#options#get('use_python_remote_plugin')
                                let s:init = 1
                            
                                try
                                  if !has('nvim')
                                    " set up yarp
                                    call wilder#yarp#init()
                                  endif
                            
                                  call _wilder_init({'num_workers': s:opts.num_workers})
                                catch
                                  echohl ErrorMsg
                                  echomsg 'wilder: Python initialization failed'
                                  echomsg v:exception
                                  echohl Normal
                                endtry
    4              0.000001   endif
                            
    4              0.000004   if s:opts.use_cmdlinechanged
    4              0.000010     if !exists('#WilderCmdlineChanged')
    4              0.000016       augroup WilderCmdlineChanged
    4              0.000143         autocmd!
                                    " call from a timer so statusline does not change during mappings
    4              0.000024         autocmd CmdlineChanged * call timer_start(0, {_ -> s:do(1)})
    4              0.000002       augroup END
    4              0.000001     endif
                              elseif s:timer is v:null
                                  let s:timer = timer_start(s:opts.interval, {_ -> s:do(1)}, {'repeat': -1})
    4              0.000002   endif
                            
    4              0.000007   if !exists('#WilderCmdlineLeave')
    4              0.000003     augroup WilderCmdlineLeave
    4              0.000022       autocmd!
    4              0.000010       autocmd CmdlineLeave * call wilder#main#stop()
    4              0.000009       autocmd CmdwinEnter * call wilder#main#stop()
    4              0.000002     augroup END
    4              0.000001   endif
                            
    4              0.000005   if !exists('#WilderVimResized')
    4              0.000002     augroup WilderVimResized
    4              0.000015       autocmd!
    4              0.000010         autocmd VimResized * call timer_start(0, {_ -> s:draw_resized()})
    4              0.000002     augroup END
    4              0.000001   endif
                            
    4              0.000007   let s:active = 1
    4              0.000003   let s:hidden = 0
                            
    4              0.000013   if !has_key(s:opts, 'renderer')
                                let s:opts.renderer = wilder#wildmenu_renderer()
    4              0.000001   endif
                            
    4              0.000004   if !has_key(s:opts, 'pipeline')
                                let s:opts.pipeline = [ wilder#branch(   wilder#cmdline_pipeline(),   has('nvim') && has('python3')     ? wilder#python_search_pipeline()     : wilder#vim_search_pipeline(), ), ]
    4              0.000001   endif
                            
    4              0.000006   let s:session_id += 1
                            
    4   0.011636   0.000021   call s:pre_hook()
                            
    4   0.001662   0.000018   call s:do(0)

FUNCTION  matchup#delim#skip()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/delim.vim:868
Called 148 times
Total time:   0.047459
 Self time:   0.003938

count  total (s)   self (s)
  148              0.000163   if a:0 >= 2
  148              0.000310     let [l:lnum, l:cnum] = [a:1, a:2]
                              else
                                let [l:lnum, l:cnum] = matchup#pos#get_cursor()[1:2]
  148              0.000051   endif
                            
  148              0.000340   if empty(get(b:, 'matchup_delim_skip', ''))
                                return matchup#util#in_comment_or_string(l:lnum, l:cnum) ? !s:invert_skip : s:invert_skip
  148              0.000047   endif
                            
  148              0.000251   let s:eff_curpos = [l:lnum, l:cnum]
  148   0.045483   0.001962   execute 'return' (s:invert_skip ? '!(' : '(') b:matchup_delim_skip ')'

FUNCTION  <SNR>84_HandleActivity()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:726
Called 378 times
Total time:   0.056088
 Self time:   0.018684

count  total (s)   self (s)
  378   0.009246   0.002761         let file = s:GetCurrentFile()
  378              0.004381         if !empty(file) && file !~ "-MiniBufExplorer-" && file !~ "--NO NAME--" && file !~ "^term:"
  378   0.008362   0.001860             let last = s:GetLastHeartbeat()
  378              0.000629             let now = localtime()
                            
                                        " Create a heartbeat when saving a file, when the current file
                                        " changes, and when still editing the same file but enough time
                                        " has passed since the last heartbeat.
  378   0.005102   0.002855             if a:is_write || s:EnoughTimePassed(now, last) || file != last.file
   30   0.004621   0.000270                 call s:AppendHeartbeat(file, now, a:is_write, last)
  348              0.000205             else
  348              0.000555                 if now - s:last_heartbeat.last_activity_at > s:local_cache_expire
    8   0.000102   0.000047                     call s:SetLastHeartbeatInMemory(now, last.last_heartbeat_at, last.file)
  348              0.000147                 endif
  378              0.000136             endif
                            
                                        " When buffering heartbeats disabled, no need to re-check the
                                        " heartbeats buffer.
  378              0.000343             if s:buffering_heartbeats_enabled
                            
                                            " Only send buffered heartbeats every s:send_buffer_seconds
  378              0.000491                 if now - s:last_sent > s:send_buffer_seconds
    8   0.018002   0.000238                     call s:SendHeartbeats()
  378              0.000129                 endif
  378              0.000118             endif
  378              0.000112         endif

FUNCTION  <SNR>103_init_delim_lists()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/loader.vim:144
Called 4 times
Total time:   0.011379
 Self time:   0.008462

count  total (s)   self (s)
    4              0.000020   let l:lists = { 'delim_tex': {   'regex': [],   'regex_capture': [],   'midmap': {}, },}
                            
                              " very tricky examples:
                              " good: let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
                              " bad:  let b:match_words = '\(foo\)\(bar\):more\1:and\2:end\1\2'
                            
                              " *subtlety*: there is a huge assumption in matchit:
                              "   ``It should be possible to resolve back references
                              "     from any pattern in the group.''
                              " we don't explicitly check this, but the behavior might
                              " be unpredictable if such groups are encountered.. (ref-1)
                            
    4              0.000011   if exists('g:matchup_hotfix') && has_key(g:matchup_hotfix, &filetype)
                                call call(g:matchup_hotfix[&filetype], [])
    4              0.000010   elseif exists('g:matchup_hotfix_'.&filetype)
                                call call(g:matchup_hotfix_{&filetype}, [])
    4              0.000006   elseif exists('b:matchup_hotfix')
                                call call(b:matchup_hotfix, [])
    4              0.000002   endif
                            
                              " parse matchpairs and b:match_words
    4              0.000012   let l:match_words = !a:no_words ? get(b:, 'match_words', '') : ''
    4              0.000013   if !empty(l:match_words) && l:match_words !~# ':'
                                execute 'let l:match_words =' b:match_words
    4              0.000001   endif
    4              0.000006   let l:simple = empty(l:match_words)
                            
    4              0.000009   let l:mps = escape(&matchpairs, '[$^.*~\\/?]')
    4              0.000010   if !get(b:, 'matchup_delim_nomatchpairs', 0) && !empty(l:mps)
    4              0.000010     let l:match_words .= (l:simple ? '' : ',').l:mps
    4              0.000001   endif
                            
    4              0.000002   if l:simple
    1   0.000146   0.000008     return s:init_delim_lists_fast(l:match_words)
    3              0.000001   endif
                            
    3              0.000186   let l:sets = split(l:match_words, g:matchup#re#not_bslash.',')
                            
    3              0.000002   if a:filter_words
                                call filter(l:sets, 'v:val =~? "^[^a-zA-Z]\\{3,18\\}$"')
                                if empty(l:sets)
                                  return s:init_delim_lists_fast(l:match_words)
                                endif
    3              0.000001   endif
                            
                              " do not duplicate whole groups of match words
    3              0.000003   let l:seen = {}
   24              0.000019   for l:s in l:sets
                                " very special case, escape bare [:]
                                " TODO: the bare [] bug might show up in other places too
   21              0.000028     if l:s ==# '[:]' || l:s ==# '\[:\]'
    3              0.000003       let l:s = '\[:]'
   21              0.000006     endif
                            
   39              0.000037     if has_key(l:seen, l:s) | continue | endif
   21              0.000028     let l:seen[l:s] = 1
                            
   39              0.000062     if l:s =~# '^\s*$' | continue | endif
                            
   21              0.000240     let l:words = split(l:s, g:matchup#re#not_bslash.':')
                            
   39              0.000034     if len(l:words) < 2 | continue | endif
                            
                                " stores series-level information
   21              0.000022     let l:extra_info = {}
                            
                                " stores information for each word
   21              0.000069     let l:extra_list = map(range(len(l:words)), '{}')
                            
                                " pre-process various \g{special} instructions
   21              0.000045     let l:replacement = { 'hlend': '\%(hlend\)\{0}', 'syn': ''}
   66              0.000062     for l:i in range(len(l:words))
   45              0.000040       let l:special_flags = []
   45              0.000316       let l:words[l:i] = substitute(l:words[l:i], g:matchup#re#gspec, '\=[get(l:replacement,submatch(1),""),' . 'add(l:special_flags,' . '[submatch(1),submatch(2)])][0]', 'g')
   45              0.000045       for [l:f, l:a] in l:special_flags
                                    let l:extra_list[l:i][l:f] = len(l:a) ? l:a : 1
   45              0.000017       endfor
   66              0.000027     endfor
                            
                                " we will resolve backrefs to produce two sets of words,
                                " one with \(foo\)s and one with \1s, along with a set of
                                " bookkeeping structures
   21              0.000037     let l:words_backref = copy(l:words)
                            
                                " *subtlety*: backref numbers refer to the capture groups
                                " in the 'open' pattern so we have to carefully keep track
                                " of the group renumbering
   21              0.000022     let l:group_renumber = {}
   21              0.000020     let l:augment_comp = {}
   21              0.000020     let l:all_needed_groups = {}
                            
                                " *subtlety*: when replacing things like \1 with \(...\)
                                " the insertion could possibly contain back references of
                                " its own; this poses a very difficult bookkeeping problem,
                                " so we just disallow it.. (ref-2)
                            
                                " get the groups like \(foo\) in the 'open' pattern
   21   0.001911   0.000135     let l:cg = matchup#loader#get_capture_groups(l:words[0])
                            
                                " if any of these contain \d raise a warning
                                " and substitute it out (ref-2)
   27              0.000039     for l:cg_i in keys(l:cg)
    6              0.000033       if l:cg[l:cg_i].str =~# g:matchup#re#backref
                                    echohl WarningMsg
                                    echom 'match-up: capture group' l:cg[l:cg_i].str 'should not contain backrefs (ref-2)'
                                    echohl None
                                    let l:cg[l:cg_i].str = substitute(l:cg[l:cg_i].str, g:matchup#re#backref, '', 'g')
    6              0.000002       endif
   27              0.000012     endfor
                            
                                " for the 'open' pattern, create a series of replacements
                                " of the capture groups with corresponding \9, \8, ..., \1
                                " this must be done deepest to shallowest
   21              0.000020     let l:augments = {}
   21   0.000251   0.000131     let l:order = matchup#loader#capture_group_replacement_order(l:cg)
                            
   21              0.000026     let l:curaug = l:words[0]
                                " TODO: \0 should match the whole pattern..
                                " augments[0] is the original words[0] with original capture groups
   21              0.000033     let l:augments[0] = l:curaug " XXX does putting this in 0 make sense?
   27              0.000022     for l:j in l:order
                                  " these indexes are not invalid because we work backwards
    6              0.000030       let l:curaug = strpart(l:curaug, 0, l:cg[l:j].pos[0]) .('\'.l:j).strpart(l:curaug, l:cg[l:j].pos[1])
    6              0.000007       let l:augments[l:j] = l:curaug
   27              0.000009     endfor
                            
                                " TODO this logic might be bad BADLOGIC
                                " should we not fill groups that aren't needed?
                                " dragons: create the augmentation operators from the
                                " open pattern- this is all super tricky!!
                                " TODO we should be building the augment later, so
                                " we can remove augments that can never be filled
                            
                                " now for the rest of the words...
   45              0.000056     for l:i in range(1, len(l:words)-1)
                            
                                  " first get rid of the capture groups in this pattern
   24   0.000302   0.000147       let l:words_backref[l:i] = matchup#loader#remove_capture_groups( l:words_backref[l:i])
                            
                                  " get the necessary \1, \2, etc back-references
   24              0.000029       let l:needed_groups = []
   24              0.000173       call substitute(l:words_backref[l:i], g:matchup#re#backref, '\=len(add(l:needed_groups, submatch(1)))', 'g')
   24              0.000057       call filter(l:needed_groups, 'index(l:needed_groups, v:val) == v:key')
                            
                                  " warn if the back-referenced groups don't actually exist
   30              0.000027       for l:ng in l:needed_groups
    6              0.000008         if has_key(l:cg, l:ng)
    6              0.000008           let l:all_needed_groups[l:ng] = 1
                                    else
                                      echohl WarningMsg
                                      echom 'match-up: backref \' . l:ng 'requested but no ' . 'matching capture group provided'
                                      echohl None
    6              0.000002         endif
   30              0.000010       endfor
                            
                                  " substitute capture groups into the backrefs and keep
                                  " track of the mapping to the original backref number
   24              0.000037       let l:group_renumber[l:i] = {}
                            
   24              0.000028       let l:cg2 = {}
   30              0.000024       for l:bref in l:needed_groups
                            
                                    " turn things like \1 into \(...\)
                                    " replacement is guaranteed to exist and not contain \d
    6              0.000048         let l:words_backref[l:i] = substitute(l:words_backref[l:i], g:matchup#re#backref, '\='''.l:cg[l:bref].str."'", '')    " not global!!
                            
                                    " complicated: need to count the number of inserted groups
    6              0.000013         let l:prev_max = max(keys(l:cg2))
    6   0.000704   0.000035         let l:cg2 = matchup#loader#get_capture_groups(l:words_backref[l:i])
                            
   12              0.000018         for l:cg2_i in sort(keys(l:cg2), s:Nsort)
    6              0.000007           if l:cg2_i > l:prev_max
                                        " maps capture groups to 'open' back reference numbers
    6              0.000017             let l:group_renumber[l:i][l:cg2_i] = l:bref + (l:cg2_i - 1 - l:prev_max)
    6              0.000002           endif
   12              0.000004         endfor
                            
                                    " if any backrefs remain, replace with re-numbered versions
    6              0.000042         let l:words_backref[l:i] = substitute(l:words_backref[l:i], g:matchup#re#not_bslash.'\\'.l:bref, '\\\=l:group_renumber[l:i][submatch(1)]', 'g')
   30              0.000011       endfor
                            
                                  " mostly a sanity check
   24   0.000196   0.000137       if matchup#util#has_duplicate_str(values(l:group_renumber[l:i]))
                                    echohl ErrorMsg
                                    echom 'match-up: duplicate bref in set ' l:s ':' l:i
                                    echohl None
   24              0.000007       endif
                            
                                  " compile the augment list for this set of backrefs, going
                                  " deepest first and combining as many steps as possible
   24              0.000025       let l:resolvable = {}
   24              0.000026       let l:dependency = {}
                            
   24              0.000025       let l:instruct = []
   30              0.000022       for l:j in l:order
                                    " the in group is the local number from this word pattern
    6              0.000030         let l:in_grp_l = keys(filter( deepcopy(l:group_renumber[l:i]), 'v:val == l:j'))
                            
   12              0.000009         if empty(l:in_grp_l) | continue | endif
    6              0.000007         let l:in_grp = l:in_grp_l[0]
                            
                                    " if anything depends on this, flush out the current resolvable
    6              0.000007         if has_key(l:dependency, l:j)
                                      call add(l:instruct, copy(l:resolvable))
                                      let l:dependency = {}
    6              0.000002         endif
                            
                                    " walk up the tree marking any new dependency
    6              0.000005         let l:node = l:j
    6              0.000011         for l:dummy in range(11)
    6              0.000008           let l:node = l:cg[l:node].parent
   12              0.000007           if l:node == 0 | break | endif
                                      let l:dependency[l:node] = 1
    6              0.000004         endfor
                            
                                    " mark l:j as resolvable
    6              0.000008         let l:resolvable[l:j] = l:in_grp
   30              0.000010       endfor
                            
   24              0.000026       if !empty(l:resolvable)
    6              0.000012         call add(l:instruct, copy(l:resolvable))
   24              0.000008       endif
                            
                                  " *note*: recall that l:augments[2] is the result of augments
                                  " up to and including 2
                            
                                  " this is a set of instructions of which brefs to resolve
   24              0.000031       let l:augment_comp[l:i] = []
   30              0.000023       for l:instr in l:instruct
                                    " the smallest key is the greediest, due to l:order
    6              0.000012         let l:minkey = min(keys(l:instr))
    6              0.000027         call insert(l:augment_comp[l:i], { 'inputmap': {}, 'outputmap': {}, 'str': l:augments[l:minkey],})
                            
    6              0.000007         let l:remaining_out = {}
   12              0.000012         for l:out_grp in keys(l:cg)
    6              0.000008           let l:remaining_out[l:out_grp] = 1
   12              0.000004         endfor
                            
                                    " input map turns this word pattern numbers into 'open' numbers
   12              0.000017         for [l:out_grp, l:in_grp] in items(l:instr)
    6              0.000014           let l:augment_comp[l:i][0].inputmap[l:in_grp] = l:out_grp
    6              0.000009           if has_key(l:remaining_out, l:out_grp)
    6              0.000009             call remove(l:remaining_out, l:out_grp)
    6              0.000002           endif
   12              0.000003         endfor
                            
                                    " output map turns remaining group numbers into 'open' numbers
    6              0.000007         let l:counter = 1
    6              0.000012         for l:out_grp in sort(keys(l:remaining_out), s:Nsort)
                                      let l:augment_comp[l:i][0].outputmap[l:counter] = l:out_grp
                                      let l:counter += 1
    6              0.000002         endfor
   30              0.000009       endfor
                            
                                  " if l:instruct was empty, there are no constraints
   24              0.000037       if empty(l:instruct) && !empty(l:augments)
   18              0.000065         let l:augment_comp[l:i] = [{ 'inputmap': {}, 'outputmap': {}, 'str': l:augments[0],}]
   18              0.000023         for l:cg_i in keys(l:cg)
                                      let l:augment_comp[l:i][0].outputmap[l:cg_i] = l:cg_i
   18              0.000006         endfor
   24              0.000007       endif
   45              0.000015     endfor
                            
                                " strip out unneeded groups in output maps
   45              0.000041     for l:i in keys(l:augment_comp)
   48              0.000041       for l:aug in l:augment_comp[l:i]
   24              0.000046         call filter(l:aug.outputmap, 'has_key(l:all_needed_groups, v:key)')
   48              0.000017       endfor
   45              0.000013     endfor
                            
                                " TODO should l:words[0] actually be used? BADLOGIC
                                " the last element in the order gives the most augmented string
                                " this includes groups that might not actually be needed elsewhere
                                " as a concrete example,
                                " l:augments = { '0': '\<\(wh\%[ile]\|for\)\>', '1': '\<\1\>'}
                                " l:words[0] = \<\1\> (bad)
                                " instead, get the furthest out needed augment.. Heuristic TODO
   36              0.000058     for l:g in add(reverse(copy(l:order)), 0)
   21              0.000031       if has_key(l:all_needed_groups, l:g)
    6              0.000008         let l:words[0] = l:augments[l:g]
    6              0.000002         break
   15              0.000004       endif
   36              0.000011     endfor
                            
                                " check whether any of these patterns has \zs
   21              0.000139     let l:extra_info.has_zs = match(l:words_backref, g:matchup#re#zs) >= 0
                            
                                " check if hlend is used in any mid
   21              0.000073     if !empty(filter(copy(l:extra_list[1:-2]), 'get(v:val, "hlend")'))
                                  let l:extra_info.mid_hlend = 1
   21              0.000007     endif
                            
                                " this is the original set of words plus the set of augments
                                " TODO this should probably be renamed
                                " (also called regexone)
   21              0.000141     call add(l:lists.delim_tex.regex, { 'open'     : l:words[0], 'close'    : l:words[-1], 'mid'      : join(l:words[1:-2], '\|'), 'mid_list' : l:words[1:-2], 'augments' : l:augments,})
                            
                                " this list has \(groups\) and we also stuff recapture data
                                " TODO this should probably be renamed
                                " (also called regextwo)
   21              0.000179     call add(l:lists.delim_tex.regex_capture, { 'open'     : l:words_backref[0], 'close'    : l:words_backref[-1], 'mid'      : join(l:words_backref[1:-2], '\|'), 'mid_list' : l:words_backref[1:-2], 'need_grp' : l:all_needed_groups, 'grp_renu' : l:group_renumber, 'aug_comp' : l:augment_comp, 'extra_list' : l:extra_list, 'extra_info' : l:extra_info,})
   24              0.000020   endfor
                            
                              " load info for advanced mid-mapper
    3              0.000010   if exists('b:match_midmap') && type(b:match_midmap) == type([])
    3              0.000022     let l:elems = deepcopy(b:match_midmap)
    3              0.000023     let l:lists.delim_tex.midmap = { 'elements': l:elems, 'strike': '\%(' . join(map(range(len(l:elems)),   '"\\(".l:elems[v:val][1]."\\)"'), '\|') . '\)'}
    3              0.000001   endif
                            
                              " generate combined lists
    3              0.000003   let l:lists.delim_all = {}
    3              0.000003   let l:lists.all = {}
   12              0.000013   for l:k in ['regex', 'regex_capture', 'midmap']
    9              0.000015     let l:lists.delim_all[l:k] = l:lists.delim_tex[l:k]
    9              0.000012     let l:lists.all[l:k] = l:lists.delim_all[l:k]
   12              0.000004   endfor
                            
    3              0.000002   return l:lists

FUNCTION  <SNR>63_move()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:198
Called 89 times
Total time:   0.002351
 Self time:   0.002351

count  total (s)   self (s)
   89              0.000129   if self.state.window_state ==# 'hidden'
                                return
   89              0.000026   endif
                            
   89              0.000074   if self.state.window_state ==# 'pending'
                                let self.state.dimensions = [a:row, a:col, a:height, a:width]
                                return
   89              0.000022   endif
                            
   89              0.001805   call nvim_win_set_config(self.state.win, { 'relative': 'editor', 'row': a:row, 'col': a:col, 'height': a:height, 'width': a:width, })

FUNCTION  <SNR>61_draw_candidates_chunks()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:615
Called 584 times
Total time:   0.121074
 Self time:   0.016874

count  total (s)   self (s)
  584              0.000832   let l:is_selected = a:ctx.selected == a:i
                            
  584   0.023926   0.002482   let l:str = s:draw_candidate(a:state, a:ctx, a:result, a:i)
                            
  584              0.000867   let l:Highlighter = a:state.highlighter
                            
  584              0.000442   if l:Highlighter is 0
                                return [[l:str]]
  584              0.000159   endif
                            
  584   0.003058   0.001974   if !l:is_selected && a:state.highlight_cache.has_key(l:str)
  282   0.001322   0.000920     return copy(a:state.highlight_cache.get(l:str))
  302              0.000086   endif
                            
  302              0.000550   let l:data = get(a:result, 'data', {})
  302   0.067860   0.001064   let l:spans = l:Highlighter(a:ctx, l:str, l:data)
                            
  302              0.000217   if l:spans is 0
                                return [[l:str]]
  302              0.000090   endif
                            
  302              0.000330   if a:state.highlight_mode ==# 'basic'
                                let l:spans = s:merge_spans(l:spans)
  302              0.000088   endif
                            
  302   0.015927   0.002083   let l:chunks = wilder#render#spans_to_chunks( l:str, l:spans, l:is_selected, a:ctx.highlights)
                            
  302              0.000218   if !l:is_selected
  301   0.001715   0.001086     call a:state.highlight_cache.set(l:str, l:chunks)
  301              0.000473     let l:chunks = copy(l:chunks)
  302              0.000106   endif
                            
  302              0.000189   return l:chunks

FUNCTION  <lambda>36()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:883
Called 46 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
                            return getcmdtype() ==# ':'

FUNCTION  wilder#renderer#popupmenu#draw_column()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:572
Called 602 times
Total time:   0.079278
 Self time:   0.019962

count  total (s)   self (s)
  602              0.000763   let l:Column = a:column
  602              0.000591   let l:height = a:ctx.height
                            
  602              0.000769   if type(l:Column) is v:t_dict
                                let l:Column = l:Column.value
  602              0.000186   endif
                            
  602              0.000601   if type(l:Column) is v:t_func
  258   0.070213   0.010897     let l:Column = l:Column(a:ctx, a:result)
  602              0.000208   endif
                            
  602              0.000640   if type(l:Column) is v:t_string
  344              0.000321     if empty(l:Column)
  172              0.000117       return []
  172              0.000057     endif
                            
  172              0.000377     return repeat([[[l:Column]]], l:height)
  258              0.000078   endif
                            
                              " v:t_list
  258              0.000242   if empty(l:Column)
   61              0.000036     return []
  197              0.000052   endif
                            
  197              0.000241   if empty(l:Column[0])
                                return []
  197              0.000058   endif
                            
                              " highlight chunk
  197              0.000258   if type(l:Column[0]) is v:t_string
  172              0.000361     return repeat([[l:Column]], l:height)
   25              0.000007   endif
                            
                              " list of highlight chunks
   25              0.000032   if type(l:Column[0][0]) is v:t_string
                                return repeat([l:Column], l:height)
   25              0.000007   endif
                            
                              " list of list of highlight chunks
   25              0.000017   return l:Column

FUNCTION  matchup#ts_syntax#synID()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/ts_syntax.vim:17
Called 791 times
Total time:   0.080748
 Self time:   0.003769

count  total (s)   self (s)
  791   0.080536   0.003557   return s:forward('synID', a:lnum, a:col, a:trans)

FUNCTION  <SNR>121_handle()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipeline.vim:27
Called 184 times
Total time:   0.130116
 Self time:   0.007059

count  total (s)   self (s)
  184              0.000384   let l:handler_id = get(a:ctx, 'handler_id', 0)
                            
  184              0.000316   if !has_key(s:handler_registry, l:handler_id)
                                " only show error if handler has not been cleared
                                if l:handler_id > s:last_cleared_id
                                  let l:message = 'wilder#' . a:key . '()'
                                  let l:message .= ' handler not found - id: ' . l:handler_id
                                  let l:message .= ': ' . string(a:x)
                            
                                  call s:echoerr(l:message)
                                endif
                            
                                return
  184              0.000049   endif
                            
  184              0.000142   let l:X = a:x
  184              0.000271   let l:handler = s:handler_registry[l:handler_id]
                            
  184              0.000225   if get(a:ctx, 'partial', 0)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx, 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                if !has_key(s:partial_results, l:handler_id)
                                  let s:partial_results[l:handler_id] = l:X
                                else
                                  let s:partial_results[l:handler_id] += l:X
                                endif
                            
                                return
  184              0.000048   endif
                            
  184              0.000248   unlet s:handler_registry[l:handler_id]
                            
  184              0.000250   if has_key(s:partial_results, l:handler_id)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx, 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                let l:X = s:partial_results[l:handler_id] + l:X
                                unlet s:partial_results[l:handler_id]
  184              0.000047   endif
                            
  184              0.000150   if a:key ==# 'reject'
                                call l:handler.on_error(a:ctx, l:X)
                                return
  184              0.000043   endif
                            
  184              0.000064   try
  184   0.123621   0.000564     call l:handler.on_finish(a:ctx, l:X)
                              catch
                                call l:handler.on_error(a:ctx, 'pipeline: ' . v:exception)
  184              0.000081   endtry

FUNCTION  <SNR>110_effcol()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/delim.vim:929
Called 480 times
Total time:   0.000987
 Self time:   0.000987

count  total (s)   self (s)
  480              0.000882   return a:expr ==# '.' ? s:eff_curpos[1] : col(a:expr)

FUNCTION  <lambda>100()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 46 times
Total time:   0.005232
 Self time:   0.000200

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <lambda>3()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:985
Called 46 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
                            return getcmdtype() ==# ':'

FUNCTION  <lambda>4()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 46 times
Total time:   0.000882
 Self time:   0.000205

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  <lambda>5()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:985
Called 46 times
Total time:   0.001126
 Self time:   0.000162

count  total (s)   self (s)
                            return wilder#cmdline#parse(x)

FUNCTION  <lambda>6()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:985
Called 46 times
Total time:   0.000687
 Self time:   0.000230

count  total (s)   self (s)
                            return wilder#cmdline#prepare_user_completion(ctx, res)

FUNCTION  <lambda>7()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:985
Called 46 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                            return res[0] ? v:false : res[2]

FUNCTION  <lambda>8()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:985
Called 46 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
                            return res.expand ==# 'file' || res.expand ==# 'dir'

FUNCTION  wilder#renderer#redraw()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer.vim:1
Called 89 times
Total time:   0.146405
 Self time:   0.000456

count  total (s)   self (s)
   89   0.146372   0.000423   call s:redraw(a:apply_incsearch_fix, 0)

FUNCTION  <SNR>104_format_gutter()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:975
Called 19 times
Total time:   0.000979
 Self time:   0.000979

count  total (s)   self (s)
   19              0.000027   let l:opts = a:0 ? a:1 : {}
   19              0.000054   let l:padding = wincol()-virtcol('.')
   19              0.000014   let l:sl = ''
                            
   19              0.000032   let l:direction = a:lnum < line('.')
   19              0.000023   if &number || &relativenumber
   19              0.000069     let l:nw = max([strlen(line('$')), &numberwidth-1])
   19              0.000021     let l:linenr = a:lnum     " distinct for relativenumber
                            
   19              0.000014     if &relativenumber
   19              0.000038       let l:linenr = abs(l:linenr-line('.'))
   19              0.000008     endif
                            
   19              0.000055     let l:sl = printf('%'.(l:nw).'s', l:linenr)
   19              0.000030     if l:direction && !get(l:opts, 'noshowdir', 0)
   10              0.000017       let l:sl = '%#Search#' . l:sl . '∆%#Normal#'
    9              0.000003     else
    9              0.000015       let l:sl = '%#CursorLineNr#' . l:sl . ' %#Normal#'
   19              0.000006     endif
   19              0.000027     let l:padding -= l:nw + 1
   19              0.000007   endif
                            
   19              0.000039   if empty(l:sl) && l:direction && !get(l:opts, 'noshowdir', 0)
                                let l:sl = '%#Search#∆%#Normal#'
                                let l:padding -= 1    " OK if this is negative
                                if l:padding == -1 && indent(a:lnum) == 0
                                  let l:padding = 0
                                endif
   19              0.000006   endif
                            
                              " possible fold column, up to &foldcolumn characters
   19              0.000016   let l:fdcstr = ''
   19              0.000020   if &foldcolumn
                                let l:fdc = max([1, &foldcolumn-1])
                                let l:fdl = foldlevel(a:lnum)
                                let l:fdcstr = l:fdl <= l:fdc ? repeat('|', l:fdl) : join(range(l:fdl-l:fdc+1, l:fdl), '')
                                let l:fdcstr .= repeat(' ', &foldcolumn - len(l:fdcstr))
                                let l:padding -= len(l:fdcstr)
                                let l:fdcstr = '%#FoldColumn#' . l:fdcstr . '%#Normal#'
   19              0.000022   elseif empty(l:sl)
                                let l:sl = '%#Normal#'
   19              0.000006   endif
                            
                              " add remaining padding (this handles rest of fdc and scl)
   19              0.000047   let l:sl = l:fdcstr . repeat(' ', l:padding) . l:sl
   19              0.000014   return l:sl

FUNCTION  <lambda>66()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1161
Called 46 times
Total time:   0.012623
 Self time:   0.012623

count  total (s)   self (s)
                            return l:Filter(     ctx, xs, get(data, 'cmdline.match_arg', ''))

FUNCTION  <SNR>58_prompt_update_cursor()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:423
Called 651 times
Total time:   0.007932
 Self time:   0.004933

count  total (s)   self (s)
  651              0.002154   let l:cmdpos = getcmdpos()
                            
  651              0.001011   if a:state.cmdpos != l:cmdpos
    6   0.003021   0.000021     call wilder#main#draw()
  651              0.000325   endif

FUNCTION  <SNR>63_add_highlight()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:251
Called 1066 times
Total time:   0.003100
 Self time:   0.003100

count  total (s)   self (s)
 1066              0.002902   call nvim_buf_add_highlight(self.state.buf, self.state.ns_id, a:hl, a:line, a:col_start, a:col_end)

FUNCTION  <SNR>84_n2s()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:664
Called 98 times
Total time:   0.000463
 Self time:   0.000463

count  total (s)   self (s)
   98              0.000428         return substitute(printf('%d', a:number), ',', '.', '')

FUNCTION  <SNR>117_getcmdline()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:634
Called 55 times
Total time:   0.000210
 Self time:   0.000210

count  total (s)   self (s)
   55              0.000096   if s:opts.use_cmdlinechanged || !s:opts.before_cursor
   55              0.000069     return getcmdline()
                              endif
                            
                              if a:0
                                let l:cmdline = a:1
                                let l:cmdpos = a:2
                              else
                                let l:cmdline = getcmdline()
                                let l:cmdpos = getcmdpos()
                              endif
                            
                              if l:cmdpos <= 1
                                return ''
                              else
                                return l:cmdline[: l:cmdpos - 2]
                              endif

FUNCTION  matchup#ts_syntax#skip_expr()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/ts_syntax.vim:25
Called 480 times
Total time:   0.093379
 Self time:   0.008869

count  total (s)   self (s)
  480   0.031736   0.002178   if matchup#ts_syntax#lang_skip(a:lnum, a:col)
                                return 1
  480              0.000200   endif
                            
  480   0.057793   0.002842   let l:syn = synIDattr(matchup#ts_syntax#synID( a:lnum, a:col, 1), 'name')
  480              0.002854   return l:syn =~? '\%(String\|Comment\)'

FUNCTION  wilder#cmdline#is_file_expansion()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:600
Called 131 times
Total time:   0.000407
 Self time:   0.000407

count  total (s)   self (s)
  131              0.000370   return a:expand ==# 'file' || a:expand ==# 'file_in_path' || a:expand ==# 'dir' || a:expand ==# 'shellcmd' || a:expand ==# 'user'

FUNCTION  <SNR>74_try()
    Defined: ~/.local/share/nvim/site/pack/packer/start/indent-blankline.nvim/plugin/indent_blankline.vim:7
Called 517 times
Total time:   0.139033
 Self time:   0.139033

count  total (s)   self (s)
  517              0.000686     try
  517              0.136167         execute a:cmd
                                catch /E12/
                                    return
  517              0.000384     endtry

FUNCTION  <SNR>84_SendHeartbeats()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-wakatime/plugin/wakatime.vim:485
Called 8 times
Total time:   0.017764
 Self time:   0.015418

count  total (s)   self (s)
    8              0.000017         let start_time = localtime()
    8              0.000008         let stdout = ''
                            
    8              0.000015         if len(s:heartbeats_buffer) == 0
                                        let s:last_sent = start_time
                                        return
    8              0.000003         endif
                            
    8              0.000016         let heartbeat = s:heartbeats_buffer[0]
    8              0.000031         let s:heartbeats_buffer = s:heartbeats_buffer[1:-1]
    8              0.000010         if len(s:heartbeats_buffer) > 0
    5   0.001216   0.000033             let extra_heartbeats = s:GetHeartbeatsJson()
    3              0.000001         else
    3              0.000004             let extra_heartbeats = ''
    8              0.000003         endif
                            
    8              0.000022         let cmd = [s:wakatime_cli, '--entity', heartbeat.entity]
    8              0.000027         let cmd = cmd + ['--time', heartbeat.time]
                            
    8              0.000008         let editor_name = 'vim'
    8              0.000027         if has('nvim')
    8              0.000008             let editor_name = 'neovim'
    8              0.000003         endif
    8   0.000129   0.000079         let cmd = cmd + ['--plugin', printf('vim/%s %s-wakatime/%s', s:n2s(v:version), editor_name, s:VERSION)]
                            
    8              0.000007         if heartbeat.is_write
    5              0.000013             let cmd = cmd + ['--write']
    8              0.000003         endif
    8              0.000013         if has_key(heartbeat, 'language')
    7              0.000025             let cmd = cmd + ['--alternate-language', heartbeat.language]
    8              0.000003         endif
    8              0.000012         if !empty(extra_heartbeats)
    5              0.000012             let cmd = cmd + ['--extra-heartbeats']
    8              0.000003         endif
                            
                                    " overwrite shell
    8              0.000034         let [sh, shellcmdflag, shrd] = [&shell, &shellcmdflag, &shellredir]
    8   0.000078   0.000031         if !s:IsWindows()
    8              0.000063             set shell=sh shellredir=>%s\ 2>&1
    8              0.000004         endif
                            
    8              0.000006         if s:has_async
                                        if !s:IsWindows()
                                            let job_cmd = [&shell, &shellcmdflag, s:JoinArgs(cmd)]
                                        elseif &shell =~ 'sh\(\.exe\)\?$'
                                            let job_cmd = [&shell, '-c', s:JoinArgs(cmd)]
                                        else
                                            let job_cmd = [&shell, &shellcmdflag] + cmd
                                        endif
                                        let job = job_start(job_cmd, { 'stoponexit': '', 'callback': {channel, output -> s:AsyncHandler(output, cmd)}})
                                        if !empty(extra_heartbeats)
                                            let channel = job_getchannel(job)
                                            call ch_sendraw(channel, extra_heartbeats . "\n")
                                        endif
    8              0.000006         elseif s:nvim_async
    8   0.000054   0.000024             if s:IsWindows()
                                            let job_cmd = cmd
    8              0.000003             else
    8   0.001045   0.000043                 let job_cmd = [&shell, &shellcmdflag, s:JoinArgs(cmd)]
    8              0.000004             endif
    8              0.000019             let s:nvim_async_output = ['']
    8              0.000069             let job_opts = { 'on_stdout': function('s:NeovimAsyncOutputHandler'), 'on_stderr': function('s:NeovimAsyncOutputHandler'), 'on_exit': function('s:NeovimAsyncExitHandler')}
    8   0.000070   0.000035             if !s:IsWindows()
    8              0.000016                 let job_opts['detach'] = 1
    8              0.000003             endif
    8              0.013929             let job = jobstart(job_cmd, job_opts)
    8              0.000033             if !empty(extra_heartbeats)
    5              0.000035                 call jobsend(job, extra_heartbeats . "\n")
    8              0.000005             endif
                                    elseif s:IsWindows()
                                        if s:is_debug_on
                                            if !empty(extra_heartbeats)
                                                let stdout = system('(' . s:JoinArgs(cmd) . ')', extra_heartbeats)
                                            else
                                                let stdout = system('(' . s:JoinArgs(cmd) . ')')
                                            endif
                                        else
                                            if s:buffering_heartbeats_enabled
                                                echo "[WakaTime] Error: Buffering heartbeats should be disabled on Windows without async support."
                                            endif
                                            exec 'silent !start /b cmd /c "' . s:JoinArgs(cmd) . ' > nul 2> nul"'
                                        endif
                                    else
                                        if s:is_debug_on
                                            if !empty(extra_heartbeats)
                                                let stdout = system(s:JoinArgs(cmd), extra_heartbeats)
                                            else
                                                let stdout = system(s:JoinArgs(cmd))
                                            endif
                                        else
                                            if !empty(extra_heartbeats)
                                                let stdout = system(s:JoinArgs(cmd) . ' &', extra_heartbeats)
                                            else
                                                let stdout = system(s:JoinArgs(cmd) . ' &')
                                            endif
                                        endif
    8              0.000003         endif
                            
                                    " restore shell
    8              0.000118         let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                            
    8              0.000020         let s:last_sent = localtime()
                            
                                    " need to repaint in case a key was pressed while sending
    8              0.000014         if !s:has_async && !s:nvim_async && s:redraw_setting != 'disabled'
                                        if s:redraw_setting == 'auto'
                                            if s:last_sent - start_time > 0
                                                redraw!
                                            endif
                                        else
                                            redraw!
                                        endif
    8              0.000003         endif
                            
    8              0.000011         if s:is_debug_on && !empty(stdout)
                                        echoerr '[WakaTime] Command: ' . s:JoinArgs(cmd) . "\n[WakaTime] Error: " . stdout
    8              0.000003         endif

FUNCTION  <SNR>109_parse_args()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/pos.vim:124
Called 2030 times
Total time:   0.034378
 Self time:   0.020984

count  total (s)   self (s)
                              "
                              " The arguments should be in one of the following forms (when unpacked):
                              "
                              "   [lnum, cnum]
                              "   [bufnum, lnum, cnum, ...]
                              "   {'lnum' : lnum, 'cnum' : cnum}
                              "
                            
 2030              0.002828   if len(a:args) > 1
  938              0.001884     return s:parse_args([a:args])
 1092              0.001213   elseif len(a:args) == 1
 1092              0.002405     if type(a:args[0]) == type({})
   80              0.000218       return [get(a:args[0], 'lnum'), get(a:args[0], 'cnum')]
 1012              0.000408     else
 1012              0.001146       if len(a:args[0]) == 2
                                    return a:args[0]
 1012              0.000321       else
 1012              0.001690         return a:args[0][1:]
                                  endif
                                endif
                              else
                                return a:args
                              endif

FUNCTION  matchup#loader#capture_group_replacement_order()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/loader.vim:641
Called 21 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
   21              0.000060   let l:order = reverse(sort(keys(a:cg), s:Nsort))
   21              0.000036   call sort(l:order, 's:capture_group_sort', a:cg)
   21              0.000015   return l:order

FUNCTION  <SNR>121_call()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipeline.vim:95
Called 184 times
Total time:   0.132711
 Self time:   0.002156

count  total (s)   self (s)
  184              0.000310   let a:ctx.handler_id = a:handler_id
                            
  184              0.000100   try
  184   0.131733   0.001177     call a:f(a:ctx)
                              catch
                                call wilder#reject(a:ctx, 'pipeline: ' . v:exception)
  184              0.000085   endtry

FUNCTION  wilder#cmdline#profile#do()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline/profile.vim:1
Called 11 times
Total time:   0.000650
 Self time:   0.000149

count  total (s)   self (s)
   11              0.000017   let l:arg_start = a:ctx.pos
                            
   11   0.000569   0.000067   if !wilder#cmdline#main#skip_nonwhitespace(a:ctx)
    9              0.000011     let a:ctx.expand = 'profile'
    9              0.000010     let a:ctx.pos = l:arg_start
    9              0.000006     return
    2              0.000001   endif
                            
    2              0.000004   let l:subcommand = a:ctx.cmdline[l:arg_start : a:ctx.pos - 1]
                            
    2              0.000002   if l:subcommand ==# 'start'
                                let a:ctx.expand = 'files'
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
    2              0.000001   endif
                            
    2              0.000002   let a:ctx.expand = 'nothing'

FUNCTION  <SNR>117_run_pipeline()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:293
Called 46 times
Total time:   0.007907
 Self time:   0.000917

count  total (s)   self (s)
   46              0.000087   let s:run_id += 1
                            
   46              0.000206   let l:ctx = { 'input': a:input, 'run_id': s:run_id, 'session_id': s:session_id, }
                            
   46              0.000043   if a:0 > 0
                                call extend(l:ctx, a:1)
   46              0.000019   endif
                            
   46   0.007401   0.000411   call wilder#pipeline#run( s:opts.pipeline, function('wilder#main#on_finish'), function('wilder#main#on_error'), l:ctx, a:input, )

FUNCTION  <lambda>38()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:883
Called 46 times
Total time:   0.001059
 Self time:   0.000144

count  total (s)   self (s)
                            return wilder#cmdline#parse(x)

FUNCTION  <lambda>39()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:883
Called 46 times
Total time:   0.000340
 Self time:   0.000231

count  total (s)   self (s)
                            return wilder#cmdline#is_substitute_command(res.cmd)

FUNCTION  <SNR>125_ftcheck()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/quirks.vim:10
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000004   let l:ft = get(split(&filetype, '\.'), 0, '')
    1              0.000002   return index(a:fts, l:ft) > -1

FUNCTION  wilder#main#get_candidate()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:599
Called 585 times
Total time:   0.000840
 Self time:   0.000840

count  total (s)   self (s)
  585              0.000694   return a:result.value[a:index]

FUNCTION  wilder#in_context()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder.vim:1
Called 1 time
Total time:   0.000024
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000023   0.000007   return wilder#main#in_context()

FUNCTION  wilder#cmdline#main#do()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline/main.vim:36
Called 25 times
Total time:   0.012244
 Self time:   0.009549

count  total (s)   self (s)
                              " default
   25              0.000035   let a:ctx.expand = 'command'
   25              0.000032   let a:ctx.force = 0
                            
   25              0.000059   if empty(a:ctx.cmdline[a:ctx.pos :])
    1              0.000000     return
   24              0.000009   endif
                            
   24   0.000640   0.000136   if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
   24              0.000009   endif
                            
                              " check if comment
   24              0.000034   if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
   24              0.000008   endif
                            
                              " skip range
   24   0.000909   0.000120   call wilder#cmdline#skip_range#do(a:ctx)
                            
   24   0.000539   0.000129   if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
   24              0.000008   endif
                            
   24              0.000030   if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
   24              0.000007   endif
                            
                              " check if starts with | or :
                              " treat as a new command
   24              0.000048   if a:ctx.cmdline[a:ctx.pos] ==# '|' || a:ctx.cmdline[a:ctx.pos] ==# ':'
                                let a:ctx.pos += 1
                                let a:ctx.cmd = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
   24              0.000008   endif
                            
   24              0.000027   let l:is_user_cmd = 0
                            
   24              0.000042   if a:ctx.cmdline[a:ctx.pos] ==# 'k' && a:ctx.cmdline[a:ctx.pos + 1] !=# 'e'
                                let a:ctx.cmd = 'k'
                                let a:ctx.pos += 1
                            
                                return
   24              0.000009   else
   24              0.000029     let l:cmd_start = a:ctx.pos
                            
   24              0.000035     let l:char = a:ctx.cmdline[a:ctx.pos]
                            
   24              0.000033     if l:char >=# 'A' && l:char <=# 'Z'
                                  " user-defined command can contain digits
                                  while l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char >=# '0' && l:char <=# '9'
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                  endwhile
                            
                                  let a:ctx.cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
                                  let l:is_user_cmd = 1
   24              0.000010     else
                                  " non-alphabet command
   24              0.000042       if stridx('@*!=><&~#', l:char) != -1
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
   24              0.000009       else
                                    " py3, python3, py3file and py3do are the only commands with numbers
                                    " all other commands are alphabet only
   24              0.000074         if a:ctx.cmdline[a:ctx.pos] ==# 'p' && a:ctx.cmdline[a:ctx.pos + 1] ==# 'y' && a:ctx.cmdline[a:ctx.pos + 2] ==# '3'
                                      let a:ctx.pos += 3
                                      let l:char = a:ctx.cmdline[a:ctx.pos]
   24              0.000010         endif
                            
                                    " this should check for [a-zA-Z] only, but the Vim implementation
                                    " skips over wildcards. This matters for commands which accept
                                    " non-alphanumeric arugments e.g. 'e*' would be parsed as an 'edit'
                                    " command with a '*' argument otherwise. These commands typically
                                    " don't need a space between the command and argument e.g. 'e++opt'
                                    " is a valid command.
  147              0.000249         while l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char ==# '*'
  123              0.000101           let a:ctx.pos += 1
  123              0.000143           let l:char = a:ctx.cmdline[a:ctx.pos]
  147              0.000070         endwhile
   24              0.000010       endif
                            
   24              0.000027       if a:ctx.pos == l:cmd_start
                                    let a:ctx.expand = 'unsuccessful'
                                    return
   24              0.000008       endif
                            
                                  " find the command
   24              0.000022       if a:ctx.pos > l:cmd_start
   24              0.000061         let l:cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
   24              0.000031         let l:len = a:ctx.pos - l:cmd_start
                            
   24              0.000029         let l:char = l:cmd[0]
   24              0.000032         if l:char < 'a' || l:char > 'z'
                                      let l:char = 'z'
   24              0.000008         endif
                            
   24              0.000058         let l:next_char = nr2char(char2nr(l:char) + 1)
                            
   24              0.000057         let l:i = s:command_char_pos[l:char]
   24              0.000082         let l:end = get(s:command_char_pos, 'l:next_char', len(s:commands))
                            
  310              0.000221         while l:i < l:end
  310              0.000347           let l:command = s:commands[l:i]
  310              0.000383           if l:cmd ==# l:command[: l:len - 1]
   24              0.000025             let a:ctx.cmd = l:command
   24              0.000013             break
  286              0.000077           endif
                            
  286              0.000214           let l:i += 1
  310              0.000117         endwhile
   24              0.000009       endif
   24              0.000008     endif
   24              0.000008   endif
                            
                              " cursor is touching command and ends in alpha-numeric character
                              " complete the command name
   24              0.000038   if a:ctx.pos == len(a:ctx.cmdline)
   13              0.000018     let l:char = a:ctx.cmdline[a:ctx.pos - 1]
                            
   13              0.000026     if l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char >=# '0' && l:char <=# '9'
   13              0.000013       let a:ctx.pos = l:cmd_start
   13              0.000010       let a:ctx.cmd = ''
                                  " expand commands
   13              0.000007       return
                                endif
   11              0.000004   endif
                            
                              " no matching command found, treat as no arguments
   11              0.000016   if empty(a:ctx.cmd)
                                " 2 or 3-letter substitute command, takes no arguments
                                if a:ctx.cmdline[l:cmd_start] ==# 's' && stridx('cgriI', a:ctx.cmdline[l:cmd_start + 1]) != -1
                                  let a:ctx.cmd = 's'
                                endif
                            
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
   11              0.000004   endif
                            
   11              0.000012   let a:ctx.expand = 'nothing'
                            
                              " handle !
   11              0.000015   if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                let a:ctx.pos += 1
                                let a:ctx.force = 1
   11              0.000004   endif
                            
   11              0.000021   if has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
   11              0.000004   endif
                            
   11   0.000408   0.000067   call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
   11              0.000032   let l:flags = get(s:command_flags, a:ctx.cmd, 0)
                            
   11              0.000013   let l:use_filter = 0
                            
   11              0.000018   if a:ctx.cmd ==# 'write' || a:ctx.cmd ==# 'update'
                                if a:ctx.cmdline[a:ctx.pos] ==# '>'
                                  if a:ctx.cmdline[a:ctx.pos + 1] ==# '>'
                                    let a:ctx.pos += 2
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endif
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                endif
   11              0.000012   elseif a:ctx.cmd ==# 'read'
                                if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                else
                                  let l:use_filter = a:ctx.force
                                endif
   11              0.000015   elseif a:ctx.cmd ==# '<' || a:ctx.cmd ==# '>'
                                while a:ctx.cmdline[a:ctx.pos] ==# a:ctx.cmd
                                  let a:ctx.pos += 1
                                endwhile
                            
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
   11              0.000005   endif
                            
                              " Handle +cmd or ++opt
   11              0.000042   if a:ctx.cmdline[a:ctx.pos] ==# '+' && ((and(l:flags, s:EDITCMD) && !l:use_filter) || and(l:flags, s:ARGOPT))
                                let l:allow_opt = 1
                                let l:allow_cmd = and(l:flags, s:EDITCMD) && !l:use_filter
                            
                                while a:ctx.cmdline[a:ctx.pos] ==# '+' && a:ctx.pos < len(a:ctx.cmdline)
                                  let a:ctx.pos += 1
                            
                                  if a:ctx.cmdline[a:ctx.pos] ==# '+'
                                    if l:allow_opt
                                      let a:ctx.pos += 1
                                      let l:expand = 'file_opt'
                                    else
                                      let l:expand = 'nothing'
                                    endif
                                  elseif l:allow_cmd
                                    let l:expand = 'command'
                                    " ++opt must be before +cmd
                                    let l:allow_opt = 0
                                    " only 1 +cmd allowed
                                    let l:allow_cmd = 0
                                  else
                                    let l:expand = 'nothing'
                                  endif
                            
                                  let l:arg_start = a:ctx.pos
                            
                                  " skip to next arg
                                  while a:ctx.pos < len(a:ctx.cmdline) && !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' && a:ctx.pos + 1 < len(a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    " TODO: multibyte
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " still in command or option
                                  if empty(a:ctx.cmdline[a:ctx.pos])
                                    let a:ctx.pos = l:arg_start
                                    let a:ctx.expand = l:expand
                                    return
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endwhile
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                elseif a:ctx.cmd ==# 'read'
                                  if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                    let a:ctx.pos += 1
                                    let l:use_filter = 1
                                  else
                                    let l:use_filter = a:ctx.force
                                  endif
                                endif
   11              0.000004   endif
                            
                              " look for | for new command and " for comment
   11              0.000026   if and(l:flags, s:TRLBAR) && !l:use_filter
   11              0.000026     if a:ctx.cmd ==# 'redir' && a:ctx.cmdline[a:ctx.pos] ==# '@' && a:ctx.cmdline[a:ctx.pos + 1] ==# '"'
                                  let a:ctx.pos += 2
   11              0.000004     endif
                            
   11              0.000015     let l:lookahead = a:ctx.pos
   46              0.000071     while l:lookahead < len(a:ctx.cmdline)
   35              0.000088       if a:ctx.cmdline[l:lookahead] ==# "\<C-V>" || a:ctx.cmdline[l:lookahead] ==# '\'
                                    let l:lookahead += 1
                            
                                    if l:lookahead + 1 < len(a:ctx.cmdline)
                                      let l:lookahead += 1
                                    else
                                      break
                                    endif
   35              0.000011       endif
                            
                                  " Check if " indicates a comment or start of string
   35              0.000043       if a:ctx.cmdline[l:lookahead] ==# '"'
                                    let l:lookahead += 1
                            
                                    let l:end_quote_reached = 0
                                    " Consume until next char is " or end of cmdline is reached
                                    while l:lookahead < len(a:ctx.cmdline)
                                      if a:ctx.cmdline[l:lookahead] ==# '\'
                                        let l:lookahead += 1
                                      elseif a:ctx.cmdline[l:lookahead] ==# '"'
                                        let l:end_quote_reached = 1
                                        let l:lookahead += 1
                                        break
                                      endif
                            
                                      let l:lookahead += 1
                                    endwhile
                            
                                    " remaining part of cmdline is comment, treat as no arguments
                                    if !l:end_quote_reached
                                      let a:ctx.pos = len(a:ctx.cmdline)
                                      return
                                    endif
                            
                                  " start of new command
   35              0.000042       elseif a:ctx.cmdline[l:lookahead] ==# '|'
                                    let a:ctx.pos = l:lookahead + 1
                                    let a:ctx.cmd = ''
                                    let a:ctx.expand = ''
                            
                                    call wilder#cmdline#main#do(a:ctx)
                            
                                    return
   35              0.000012       endif
                            
                                  " TODO: multibyte
   35              0.000034       let l:lookahead += 1
   46              0.000029     endwhile
   11              0.000005   endif
                            
                              " command does not take extra arguments
   11              0.000026   if !and(l:flags, s:EXTRA) && !l:is_user_cmd
                                " consume whitespace
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                                " and check for | or "
                                if a:ctx.cmdline[a:ctx.pos] ==# '|'
                                  let a:ctx.pos += 1
                                  let a:ctx.cmd = ''
                                  let a:ctx.expand = ''
                            
                                  call wilder#cmdline#main#do(a:ctx)
                                  return
                                else
                                  " remaining part is either comment or invalid arguments
                                  " either way, treat as no arguments
                                  let a:ctx.pos = len(a:ctx.cmdline)
                                  let a:ctx.expand = 'nothing'
                                  return
                                endif
   11              0.000004   endif
                            
                            
   11              0.000023   if l:use_filter || a:ctx.cmd ==# '!' || a:ctx.cmd ==# 'terminal'
                                let l:before_args = a:ctx.pos
                            
                                if !wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                                  let a:ctx.pos = l:before_args
                                  let a:ctx.expand = 'shellcmd'
                                  return
                                endif
                            
                                " Reset pos back to before_args
                                let a:ctx.pos = l:before_args
   11              0.000004   endif
                            
   11              0.000015   if and(l:flags, s:XFILE)
                                " TODO: handle backticks :h backtick-expansion
                            
                                let l:arg_start = a:ctx.pos
                            
                                " Check if completing $ENV
                                if a:ctx.cmdline[a:ctx.pos] ==# '$'
                                  let l:arg_start = a:ctx.pos
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if !s:is_idc(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    let a:ctx.expand = 'environment'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                " Check if completing ~user
                                if a:ctx.cmdline[a:ctx.pos] ==# '~'
                                  let l:allow_backslash = has('win32') || has('win64')
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if l:char ==# '/' || l:allow_backslash && l:char ==# '\' || !s:is_filec(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " + 1 since we want to expand ~ to $HOME
                                  if a:ctx.pos == len(a:ctx.cmdline) && a:ctx.pos > l:arg_start + 1
                                    let a:ctx.expand = 'user'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos = l:arg_start
                                let a:ctx.expand = 'file'
                            
                                " vim assumes for XFILE, we can ignore arguments other than the last one but
                                " this is not necessarily true, we should not do this for NOSPC
                                if !and(l:flags, s:NOSPC)
                                  call s:move_pos_to_last_arg(a:ctx)
                                endif
   11              0.000004   endif
                            
   11              0.000029   if a:ctx.cmd ==# 'find' || a:ctx.cmd ==# 'sfind' || a:ctx.cmd ==# 'tabfind'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'file_in_path'
                                endif
                                return
   11              0.000043   elseif a:ctx.cmd ==# 'cd' || a:ctx.cmd ==# 'chdir' || a:ctx.cmd ==# 'lcd' || a:ctx.cmd ==# 'lchdir' || a:ctx.cmd ==# 'tcd' || a:ctx.cmd ==# 'tchdir'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'dir'
                                endif
                                return
   11              0.000011   elseif a:ctx.cmd ==# 'help'
                                let a:ctx.expand = 'help'
                                return
                              " command modifiers
   11              0.000021   elseif has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
   11              0.000010   elseif a:ctx.cmd ==# 'filter'
                                call wilder#cmdline#filter#do(a:ctx)
                                return
   11              0.000009   elseif a:ctx.cmd ==# 'match'
                                call wilder#cmdline#match#do(a:ctx)
                                return
   11              0.000010   elseif a:ctx.cmd ==# 'command'
                                call wilder#cmdline#command#do(a:ctx)
                                return
   11              0.000011   elseif a:ctx.cmd ==# 'delcommand'
                                let a:ctx.expand = 'user_commands'
                                return
   11              0.000016   elseif a:ctx.cmd ==# 'global' || a:ctx.cmd ==# 'vglobal'
                                call wilder#cmdline#global#do(a:ctx)
                                return
   11              0.000015   elseif a:ctx.cmd ==# '&' || a:ctx.cmd ==# 'substitute'
                                call wilder#cmdline#substitute#do(a:ctx)
                                return
   11              0.000056   elseif a:ctx.cmd ==# 'isearch' || a:ctx.cmd ==# 'dsearch' || a:ctx.cmd ==# 'ilist' || a:ctx.cmd ==# 'dlist' || a:ctx.cmd ==# 'ijump' || a:ctx.cmd ==# 'psearch' || a:ctx.cmd ==# 'djump' || a:ctx.cmd ==# 'isplit' || a:ctx.cmd ==# 'dsplit'
                                call wilder#cmdline#isearch#do(a:ctx)
                                return
   11              0.000010   elseif a:ctx.cmd ==# 'autocmd'
                                call wilder#cmdline#autocmd#do(a:ctx, 0)
                                return
   11              0.000016   elseif a:ctx.cmd ==# 'doautocmd' || a:ctx.cmd ==# 'doautoall'
                                call wilder#cmdline#autocmd#do(a:ctx, 1)
   11              0.000022   elseif a:ctx.cmd ==# 'set' || a:ctx.cmd ==# 'setglobal' || a:ctx.cmd ==# 'setlocal'
                                call wilder#cmdline#set#do(a:ctx)
                                return
   11              0.000059   elseif a:ctx.cmd ==# 'tag' || a:ctx.cmd ==# 'stag' || a:ctx.cmd ==# 'ptag' || a:ctx.cmd ==# 'ltag' || a:ctx.cmd ==# 'tselect' || a:ctx.cmd ==# 'stselect' || a:ctx.cmd ==# 'tjump' || a:ctx.cmd ==# 'stjump' || a:ctx.cmd ==# 'ptselect' || a:ctx.cmd ==# 'ptjump'
                                let a:ctx.expand = 'tags'
                                return
   11              0.000010   elseif a:ctx.cmd ==# 'augroup'
                                let a:ctx.expand = 'augroup'
   11              0.000009   elseif a:ctx.cmd ==# 'syntax'
                                call wilder#cmdline#syntax#do(a:ctx)
                                return
   11              0.000097   elseif a:ctx.cmd ==# 'let' || a:ctx.cmd ==# 'if' || a:ctx.cmd ==# 'elseif' || a:ctx.cmd ==# 'while' || a:ctx.cmd ==# 'for' || a:ctx.cmd ==# 'echo' || a:ctx.cmd ==# 'echon' || a:ctx.cmd ==# 'execute' || a:ctx.cmd ==# 'echomsg' || a:ctx.cmd ==# 'echoerr' || a:ctx.cmd ==# 'call' || a:ctx.cmd ==# 'return' || a:ctx.cmd ==# 'cexpr' || a:ctx.cmd ==# 'caddexpr' || a:ctx.cmd ==# 'cgetexpr' || a:ctx.cmd ==# 'lexpr' || a:ctx.cmd ==# 'laddexpr' || a:ctx.cmd ==# 'lgetexpr'
                                "TODO call has extra arugments
                                call wilder#cmdline#let#do(a:ctx)
                                return
   11              0.000010   elseif a:ctx.cmd ==# 'unlet'
                                call wilder#cmdline#unlet#do(a:ctx)
                                return
   11              0.000009   elseif a:ctx.cmd ==# 'function'
                                let a:ctx.expand = 'function'
                                return
   11              0.000010   elseif a:ctx.cmd ==# 'delfunction'
                                let a:ctx.expand = 'user_func'
                                return
   11              0.000009   elseif a:ctx.cmd ==# 'echohl'
                                let a:ctx.expand = 'highlight'
                                " TODO: include None
                                return
   11              0.000010   elseif a:ctx.cmd ==# 'highlight'
                                call wilder#cmdline#highlight#do(a:ctx)
                                return
   11              0.000021   elseif a:ctx.cmd ==# 'cscope' || a:ctx.cmd ==# 'lcscope' || a:ctx.cmd ==# 'scscope'
                                call wilder#cmdline#cscope#do(a:ctx)
                                return
   11              0.000009   elseif a:ctx.cmd ==# 'sign'
                                call wilder#cmdline#sign#do(a:ctx)
                                return
   11              0.000020   elseif a:ctx.cmd ==# 'bdelete' || a:ctx.cmd ==# 'bwipeout' || a:ctx.cmd ==# 'bunload'
                                let a:ctx.expand = 'buffer'
                                return
   11              0.000019   elseif a:ctx.cmd ==# 'buffer' || a:ctx.cmd ==# 'sbuffer' || a:ctx.cmd ==# 'checktime'
                                let a:ctx.expand = 'buffer'
                                return
   11              0.000038   elseif a:ctx.cmd ==# 'abbreviate' || a:ctx.cmd ==# 'unabbreviate' || a:ctx.cmd[-3 :] ==# 'map' || a:ctx.cmd[-6 :] ==# 'abbrev'
                                call wilder#cmdline#map#do(a:ctx)
                                return
   11              0.000012   elseif a:ctx.cmd[-8 :] ==# 'mapclear'
                                let a:ctx.expand = 'mapclear'
                                return
   11              0.000012   elseif a:ctx.cmd[-4 :] ==# 'menu'
                                call wilder#cmdline#menu#do(a:ctx)
                                return
   11              0.000011   elseif a:ctx.cmd ==# 'colorscheme'
                                let a:ctx.expand = 'color'
                                return
   11              0.000009   elseif a:ctx.cmd ==# 'compiler'
                                let a:ctx.expand = 'compiler'
                                return
   11              0.000009   elseif a:ctx.cmd ==# 'ownsyntax'
                                let a:ctx.expand = 'ownsyntax'
                                return
   11              0.000009   elseif a:ctx.cmd ==# 'packadd'
                                let a:ctx.expand = 'packadd'
                                return
   11              0.000009   elseif a:ctx.cmd ==# 'language'
                                let l:arg_start = a:ctx.pos
                                call wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                            
                                if a:ctx.pos == len(a:ctx.cmdline)
                                  let a:ctx.expand = 'language'
                                  let a:ctx.pos = l:arg_start
                                else
                                  let l:subcommand = a:ctx.cmdline[l:arg_start : a:ctx.pos - 1]
                                  if l:subcommand ==# 'messages' || l:subcommand ==# 'ctype' || l:subcommand ==# 'time'
                                    let a:ctx.expand = 'locales'
                                    call wilder#cmdline#main#skip_whitespace(a:ctx)
                                  endif
                                endif
   11              0.000010   elseif a:ctx.cmd ==# 'profile'
   11   0.000716   0.000066     call wilder#cmdline#profile#do(a:ctx)
   11              0.000005     return
                              elseif a:ctx.cmd ==# 'checkhealth'
                                let a:ctx.expand = 'checkhealth'
                                call s:move_pos_to_last_arg(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'behave'
                                let a:ctx.expand = 'behave'
                                return
                              elseif a:ctx.cmd ==# 'messages'
                                let a:ctx.expand = 'messages'
                                return
                              elseif a:ctx.cmd ==# 'history'
                                let a:ctx.expand = 'history'
                                return
                              elseif a:ctx.cmd ==# 'syntime'
                                let a:ctx.expand = 'syntime'
                                return
                              elseif a:ctx.cmd ==# 'argdelete'
                                let a:ctx.expand = 'arglist'
                                return
                              elseif a:ctx.cmd ==# 'lua'
                                let a:ctx.expand = 'lua'
                                return
                              endif

FUNCTION  <SNR>58_prompt_pre_draw()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:160
Called 89 times
Total time:   0.000332
 Self time:   0.000332

count  total (s)   self (s)
   89              0.000299   return a:state.cached_cmdline !=# getcmdline() || a:state.cmdpos != getcmdpos()

FUNCTION  <SNR>50_apply_first()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlighter.vim:5
Called 302 times
Total time:   0.065626
 Self time:   0.013067

count  total (s)   self (s)
  604              0.000793   for l:Highlighter in a:highlighters
  604   0.063322   0.010763     let l:highlight = l:Highlighter(a:ctx, a:x, a:data)
                            
  604              0.000486     if l:highlight isnot 0
  302              0.000207       return l:highlight
  302              0.000098     endif
  302              0.000102   endfor
                            
                              return 0

FUNCTION  <lambda>146()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 46 times
Total time:   0.000214
 Self time:   0.000214

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  <lambda>40()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 46 times
Total time:   0.000849
 Self time:   0.000164

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  <lambda>49()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1344
Called 46 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
                            return res[2]

FUNCTION  <SNR>58_prompt_pre_hook()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:409
Called 4 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    4              0.000010   call timer_stop(a:state.timer)
                            
    4              0.000004   let a:state.cmdpos = -1
    4              0.000003   let a:state.previous_start = -1
    4              0.000003   let a:state.previous_end = -1
                            
    4              0.000027   let a:state.timer = timer_start(a:state.cursor_check_interval, {-> s:prompt_update_cursor(a:state)}, {'repeat': -1})

FUNCTION  <SNR>61_post_hook()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:698
Called 4 times
Total time:   0.001026
 Self time:   0.000436

count  total (s)   self (s)
    4   0.000302   0.000020   call a:state.api.hide()
                            
   56              0.000098   for l:Component in [a:state.empty_message, a:state.error_message] + a:state.left + a:state.right + a:state.top + a:state.bottom
   52   0.000574   0.000266     call wilder#renderer#call_component_post_hook(a:ctx, l:Component)
   56              0.000021   endfor
                            
    4              0.000007   call timer_stop(a:state.empty_message_first_draw_timer)
                            
    4              0.000004   let a:state.active = 0

FUNCTION  <lambda>150()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/component/popupmenu_empty_message_with_spinner.vim:10
Called 3 times
Total time:   0.000123
 Self time:   0.000014

count  total (s)   self (s)
                            return s:make_empty_message(ctx, l:message, spinner_char, spinner_hl)

FUNCTION  <lambda>151()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/component/spinner.vim:10
Called 3 times
Total time:   0.000048
 Self time:   0.000012

count  total (s)   self (s)
                            return s:spin(l:state, done)

FUNCTION  <lambda>152()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/component/popupmenu_empty_message_with_spinner.vim:33
Called 3 times
Total time:   0.000244
 Self time:   0.000014

count  total (s)   self (s)
                            return s:message(l:state, ctx, result)

FUNCTION  <lambda>153()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/component/popupmenu_empty_message.vim:18
Called 3 times
Total time:   0.000427
 Self time:   0.000015

count  total (s)   self (s)
                            return s:empty_message(l:state, ctx, result)

FUNCTION  <lambda>156()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/component/popupmenu_buffer_flags.vim:47
Called 86 times
Total time:   0.001099
 Self time:   0.000387

count  total (s)   self (s)
                            return s:buffer_status(l:state, ctx, result)

FUNCTION  matchup#util#has_duplicate_str()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/util.vim:71
Called 24 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
   24              0.000051   if len(a:list) <= 1 | return 0 | endif
                              let l:seen = {}
                              for l:elem in a:list
                                if has_key(l:seen, l:elem)
                                  return 1
                                endif
                                let l:seen[l:elem] = 1
                              endfor
                              return 0

FUNCTION  <lambda>51()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 46 times
Total time:   0.000823
 Self time:   0.000156

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  <SNR>104_add_matches()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:1147
Called 74 times
Total time:   0.008804
 Self time:   0.007977

count  total (s)   self (s)
   74              0.000148   if !exists('w:matchup_match_id_list')
   74              0.000090     let w:matchup_match_id_list = []
   74              0.000024   endif
                            
                              " if MatchwordCur is undefined and MatchWord links to MatchParen
                              " (as default), behave like MatchWordCur is the same as MatchParenCur
                              " otherwise, MatchWordCur is the same as MatchWord
   74              0.000043   if a:0
   74              0.000391     let l:mwc = hlexists('MatchWordCur') ? 'MatchWordCur' : (synIDtrans(hlID('MatchWord')) == hlID('MatchParen')     ? 'MatchParenCur' : 'MatchWord')
   74              0.000023   endif
                            
  230              0.000193   for l:corr in a:corrlist
  156              0.000208     if a:0 && l:corr.match_index == a:1.match_index
   74   0.000678   0.000319       let l:group = s:wordish(l:corr) ? l:mwc : 'MatchParenCur'
   82              0.000031     else
   82   0.000821   0.000353       let l:group = s:wordish(l:corr) ? 'MatchWord' : 'MatchParen'
  156              0.000061     endif
                            
  156              0.000194     if exists('s:ns_id')
  156              0.000526       if strlen(l:corr.match) == 0 && matchup#loader#_treesitter_may_be_supported() && !matchup#ts_engine#get_option(   bufnr('%'), 'disable_virtual_text')
                                    if hlexists('MatchupVirtualText')
                                      let l:group = 'MatchupVirtualText'
                                    endif
                                    call nvim_buf_set_extmark(0, s:ns_id, l:corr.lnum - 1, l:corr.cnum - 1, {   'virt_text': [[' ' . g:matchup_matchparen_end_sign . ' '                  . a:corrlist[0].match, l:group]],   'virt_text_pos': 'overlay'})
  156              0.000063       else
  156              0.000885         call nvim_buf_add_highlight(0, s:ns_id, l:group, l:corr.lnum - 1, l:corr.cnum - 1, l:corr.cnum - 1 + strlen(l:corr.match))
  156              0.000058       end
                                elseif exists('*matchaddpos')
                                  call add(w:matchup_match_id_list, matchaddpos(l:group, [[l:corr.lnum, l:corr.cnum, strlen(l:corr.match)]], 0))
                                else
                                  call add(w:matchup_match_id_list, matchadd(l:group, '\%'.(l:corr.lnum).'l\%'.(l:corr.cnum).'c' . '.\+\%<'.(l:corr.cnum+strlen(l:corr.match)+1).'c', 0))
  156              0.000067     endif
  230              0.000136   endfor

FUNCTION  <SNR>121_wait_start()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipeline.vim:175
Called 46 times
Total time:   0.002600
 Self time:   0.000555

count  total (s)   self (s)
   46              0.000072   let a:state.wait_handler_id = a:ctx.handler_id
                            
   46              0.000273   let a:state.handler = { 'on_finish': {ctx, x -> s:wait_on_finish(a:state, ctx, x)}, 'on_error': {ctx, x -> s:wait_on_error(a:state, ctx, x)}, }
                            
   46   0.002215   0.000170   call s:wait_call(a:state, a:ctx)

FUNCTION  <SNR>63_clear_all_highlights()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:255
Called 89 times
Total time:   0.000896
 Self time:   0.000896

count  total (s)   self (s)
   89              0.000151   if !bufexists(self.state.buf)
                                return
   89              0.000025   endif
                            
   89              0.000625   call nvim_buf_clear_namespace(self.state.buf, self.state.ns_id, 0, -1)

FUNCTION  matchup#pos#get_cursor()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/pos.vim:17
Called 1626 times
Total time:   0.003217
 Self time:   0.003217

count  total (s)   self (s)
 1626              0.002748     return getcurpos()

FUNCTION  wilder#cmdline#main#skip_whitespace()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline/main.vim:683
Called 59 times
Total time:   0.001256
 Self time:   0.000955

count  total (s)   self (s)
   59              0.000112   if empty(a:ctx.cmdline[a:ctx.pos])
                                return 0
   59              0.000022   endif
                            
   69   0.000686   0.000385   while wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
   11              0.000012     let a:ctx.pos += 1
                            
   11              0.000017     if empty(a:ctx.cmdline[a:ctx.pos])
    1              0.000001       return 0
   10              0.000004     endif
   68              0.000042   endwhile
                            
   58              0.000038   return 1

FUNCTION  <SNR>104_synID()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/matchparen.vim:1203
Called 311 times
Total time:   0.027122
 Self time:   0.001326

count  total (s)   self (s)
  311   0.027045   0.001248     return matchup#ts_syntax#synID(a:lnum, a:col, a:trans)

FUNCTION  wilder#highlighter#python_pcre2_highlight()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/highlighter.vim:161
Called 302 times
Total time:   0.000784
 Self time:   0.000784

count  total (s)   self (s)
  302              0.000468   if !has_key(a:data, 'pcre2.pattern')
  302              0.000182     return 0
                              endif
                            
                              let l:pattern = a:data['pcre2.pattern']
                              let l:engine = get(a:opts, 'engine', 're')
                            
                              return _wilder_python_pcre2_highlight(l:pattern, a:x, l:engine)

FUNCTION  matchup#delim#fill_backrefs()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/delim.vim:939
Called 292 times
Total time:   0.001718
 Self time:   0.001718

count  total (s)   self (s)
  292              0.001633   return substitute(a:re, g:matchup#re#backref, '\=s:get_backref(a:groups, submatch(1), a:warn)', 'g')
                                    " \ '\=get(a:groups, submatch(1), "")', 'g')

FUNCTION  wilder#cmdline#is_user_command()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:608
Called 92 times
Total time:   0.000295
 Self time:   0.000295

count  total (s)   self (s)
   92              0.000265   return !empty(a:cmd) && a:cmd[0] >=# 'A' && a:cmd[0] <=# 'Z'

FUNCTION  <lambda>164()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:96
Called 89 times
Total time:   0.004494
 Self time:   0.000517

count  total (s)   self (s)
                            return s:make_top_or_bottom_border(ctx, 1, a:border_chars)

FUNCTION  <lambda>165()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:99
Called 89 times
Total time:   0.004225
 Self time:   0.000463

count  total (s)   self (s)
                            return s:make_top_or_bottom_border(ctx, 0, a:border_chars)

FUNCTION  <lambda>166()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:46
Called 3 times
Total time:   0.001093
 Self time:   0.000020

count  total (s)   self (s)
                            return s:wrap_message(ctx, result, a:opts.empty_message, l:border_chars, 'empty_message')

FUNCTION  matchup#delim#get_current()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/delim.vim:28
Called 361 times
Total time:   0.207406
 Self time:   0.004519

count  total (s)   self (s)
  361   0.207239   0.004352   return s:get_delim_multi(extend({ 'direction' : 'current', 'type' : a:type, 'side' : a:side,}, get(a:, '1', {})))

FUNCTION  <lambda>169()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 89 times
Total time:   0.026273
 Self time:   0.000368

count  total (s)   self (s)
                            return s:prompt(a:state, ctx, result)

FUNCTION  <lambda>64()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1161
Called 46 times
Total time:   0.002217
 Self time:   0.000256

count  total (s)   self (s)
                            return wilder#cmdline#prepare_getcompletion(ctx, res, l:fuzzy, l:use_python)

FUNCTION  <lambda>65()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1161
Called 46 times
Total time:   0.019506
 Self time:   0.000194

count  total (s)   self (s)
                            return s:getcompletion(ctx, res, l:fuzzy, l:use_python)

FUNCTION  wilder#lua#wrap()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/lua.vim:9
Called 27434 times
Total time:   0.440877
 Self time:   0.362813

count  total (s)   self (s)
27434              0.062131   if type(a:t) is v:t_string || type(a:t) is v:t_number || type(a:t) is v:t_bool || a:t is v:null
21617              0.012382     return a:t
 5817              0.001666   endif
                            
 5817              0.005359   if type(a:t) is v:t_func
   92   0.001492   0.000378     return s:wrap_function(a:t)
 5725              0.001668   endif
                            
 5725              0.005052   if type(a:t) is v:t_dict
 3450              0.002653     for l:key in keys(a:t)
 2944              0.003080       let l:Value = a:t[l:key]
 2944              0.003961       let a:t[l:key] = wilder#lua#wrap(l:Value)
 3450              0.001267     endfor
 5725              0.001591   endif
                            
                              " v:t_list
 5725              0.025962   return map(a:t, {_, x -> wilder#lua#wrap(x)})

FUNCTION  <lambda>67()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 46 times
Total time:   0.016260
 Self time:   0.000215

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <lambda>68()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder.vim:201
Called 46 times
Total time:   0.016377
 Self time:   0.000116

count  total (s)   self (s)
                            return a:p(ctx, x)

FUNCTION  <SNR>61_render()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:121
Called 99 times
Total time:   0.027885
 Self time:   0.008161

count  total (s)   self (s)
   99              0.000226   call timer_stop(a:state.empty_message_first_draw_timer)
                            
   99              0.000121   if a:state.run_id != a:ctx.run_id
   46              0.000050     let a:state.longest_line_width = 0
   46   0.000234   0.000140     call a:state.draw_cache.clear()
   46   0.000371   0.000127     call a:state.highlight_cache.clear()
   99              0.000037   endif
                            
   99              0.000120   let a:state.run_id = a:ctx.run_id
                            
   99              0.000071   if a:ctx.clear_previous
   46              0.000062     let a:state.page = [-1, -1]
   99              0.000031   endif
                            
   99   0.004468   0.000539   let l:page = s:make_page(a:state, a:ctx, a:result)
   99              0.000118   let a:ctx.page = l:page
   99              0.000101   let a:state.page = l:page
                            
   99              0.000283   let l:height = l:page == [-1, -1] ? 0 : l:page[1] - l:page[0] + 1
                            
   99   0.000942   0.000408   let l:min_height = a:state.get_min_height(a:ctx, a:result)
   99              0.000178   let l:min_height -= len(a:state.top)
   99              0.000143   let l:min_height -= len(a:state.bottom)
   99              0.000090   if l:height < l:min_height
                                let l:height = l:min_height
   99              0.000032   endif
                            
   99              0.000111   let a:ctx.height = l:height
   99              0.000125   let a:ctx.highlights = a:state.highlights
                            
                              " Hide popupmenu if there is nothing to draw and empty message is not set
   99              0.000302   if a:state.page == [-1, -1] && !has_key(a:ctx, 'error') && a:state.empty_message is 0
                                call a:state.api.hide()
                                return
   99              0.000028   endif
                            
   99              0.000127   let l:was_first_draw = a:state.is_first_draw
   99              0.000094   let a:state.is_first_draw = 0
                            
                              " Rough hack to prevent empty message from showing for the first draw.
                              " If the pipeline is async, the first draw will always have an empty result.
                              " This delays the empty message from showing to prevent flicker.
   99              0.000301   if l:was_first_draw && a:state.page == [-1, -1] && a:state.empty_message isnot 0 && !a:ctx.done && a:state.empty_message_first_draw_delay > 0
    4              0.000015     let a:state.empty_message_first_draw_timer = timer_start(a:state.empty_message_first_draw_delay, {-> wilder#main#draw()})
    4              0.000002     return
   95              0.000028   endif
                            
                              " If error or empty message is not showing, check if we need to draw.
   95   0.015814   0.001353   if !has_key(a:ctx, 'error') && a:state.page != [-1, -1] && !wilder#renderer#pre_draw(a:state.left + a:state.right + a:state.top + a:state.bottom, a:ctx, a:result)
                                return
   95              0.000030   endif
                            
   95              0.000102   let a:state.render_id += 1
                            
   95   0.000853   0.000390   if a:state.api.need_timer()
   95              0.000127     let l:render_id = a:state.render_id
   95              0.000455     call timer_start(0, {-> s:render_lines_from_timer(l:render_id, a:state, a:ctx, a:result)})
                              else
                                call s:render_lines(a:state, a:ctx, a:result)
   95              0.000033   endif

FUNCTION  <SNR>103_init_delim_lists_fast()
    Defined: ~/.local/share/nvim/site/pack/packer/opt/vim-matchup/autoload/matchup/loader.vim:523
Called 1 time
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
    1              0.000003   let l:lists = { 'delim_tex': { 'regex': [], 'regex_capture': [] } }
                            
    1              0.000004   let l:sets = split(a:mps, ',')
    1              0.000001   let l:seen = {}
                            
    4              0.000004   for l:s in l:sets
    5              0.000010     if l:s =~# '^\s*$' | continue | endif
                            
    3              0.000004     if l:s ==# '[:]' || l:s ==# '\[:\]'
    1              0.000001       let l:s = '\[:]'
    3              0.000001     endif
                            
    5              0.000006     if has_key(l:seen, l:s) | continue | endif
    3              0.000004     let l:seen[l:s] = 1
                            
    3              0.000009     let l:words = split(l:s, ':')
    5              0.000005     if len(l:words) < 2 | continue | endif
                            
    3              0.000015     call add(l:lists.delim_tex.regex, { 'open'     : l:words[0], 'close'    : l:words[-1], 'mid'      : '', 'mid_list' : [], 'augments' : {},})
    3              0.000022     call add(l:lists.delim_tex.regex_capture, { 'open'     : l:words[0], 'close'    : l:words[-1], 'mid'      : '', 'mid_list' : [], 'need_grp' : {}, 'grp_renu' : {}, 'aug_comp' : {}, 'has_zs'   : 0, 'extra_list' : [{}, {}], 'extra_info' : { 'has_zs': 0, },})
    4              0.000003   endfor
                            
                              " TODO if this is empty!
                            
                              " generate combined lists
    1              0.000002   let l:lists.delim_all = {}
    1              0.000001   let l:lists.all = {}
    3              0.000003   for l:k in ['regex', 'regex_capture']
    2              0.000004     let l:lists.delim_all[l:k] = l:lists.delim_tex[l:k]
    2              0.000003     let l:lists.all[l:k] = l:lists.delim_all[l:k]
    3              0.000002   endfor
                            
    1              0.000001   return l:lists

FUNCTION  <SNR>61_draw_columns()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:543
Called 172 times
Total time:   0.100567
 Self time:   0.021289

count  total (s)   self (s)
  172              0.000204   let l:height = a:ctx.height
                            
  774              0.000650   for l:Column in a:columns
  602   0.083325   0.004047     let l:column = wilder#renderer#popupmenu#draw_column(a:ctx, a:result, l:Column)
                            
  602              0.000580     if empty(l:column)
  233              0.000126       continue
  369              0.000107     endif
                            
  369              0.000278     let l:i = 0
 3130              0.002948     while l:i < len(l:column)
 2761              0.003323       let a:column_chunks[l:i] += l:column[l:i]
                            
 2761              0.001816       let l:i += 1
 3130              0.001027     endwhile
                            
  369              0.000273     if l:i < l:height
                                  let l:width = wilder#render#chunks_displaywidth(l:column[0])
                            
                                  while l:i < l:height
                                    let a:column_chunks[l:i] += [[repeat(' ', l:width)]]
                            
                                    let l:i += 1
                                  endwhile
  369              0.000098     endif
  541              0.000267   endfor

FUNCTION  wilder#main#in_context()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:57
Called 1 time
Total time:   0.000017
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000016   0.000006   return wilder#main#in_mode() && !s:hidden && s:enabled

FUNCTION  <SNR>40_mru_update()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cache.vim:56
Called 25 times
Total time:   0.000638
 Self time:   0.000638

count  total (s)   self (s)
   25              0.000040   let l:queue = self['_queue']
   25              0.000032   let l:counts = self['_counts']
                            
   25              0.000048   call add(l:queue, a:key)
   25              0.000043   if !has_key(l:counts, a:key)
   25              0.000034     let l:counts[a:key] = 1
                              else
                                let l:counts[a:key] += 1
   25              0.000009   endif
                            
   25              0.000043   if len(l:queue) > self['_max_size']
   25              0.000068     let l:removed_key = remove(l:queue, 0)
   25              0.000048     let l:counts[l:removed_key] -= 1
                            
   25              0.000039     if l:counts[l:removed_key] == 0
   25              0.000039       unlet l:counts[l:removed_key]
   25              0.000093       unlet self['_cache'][l:removed_key]
   25              0.000011     endif
   25              0.000008   endif

FUNCTION  <lambda>9()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 46 times
Total time:   0.000572
 Self time:   0.000165

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  <lambda>170()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 4 times
Total time:   0.000073
 Self time:   0.000021

count  total (s)   self (s)
                            return s:prompt_pre_hook(a:state)

FUNCTION  <lambda>171()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 4 times
Total time:   0.000034
 Self time:   0.000021

count  total (s)   self (s)
                            return s:prompt_post_hook(a:state)

FUNCTION  <lambda>172()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 89 times
Total time:   0.000746
 Self time:   0.000414

count  total (s)   self (s)
                            return s:prompt_pre_draw(a:state)

FUNCTION  <lambda>173()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:116
Called 89 times
Total time:   0.029757
 Self time:   0.000683

count  total (s)   self (s)
                            return s:wrap_string_or_func_with_border(ctx, result, l:Value, a:left, a:right)

FUNCTION  <lambda>174()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:99
Called 89 times
Total time:   0.004185
 Self time:   0.000449

count  total (s)   self (s)
                            return s:make_top_or_bottom_border(ctx, 0, a:border_chars)

FUNCTION  <lambda>175()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:456
Called 89 times
Total time:   0.001293
 Self time:   0.000410

count  total (s)   self (s)
                            return s:get_middle_position(ctx, dimensions, a:is_top)

FUNCTION  wilder#main#draw()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/main.vim:412
Called 6 times
Total time:   0.002999
 Self time:   0.000055

count  total (s)   self (s)
    6              0.000011   if !s:active || !s:enabled
                                return 0
    6              0.000003   endif
                            
    6   0.002970   0.000026   call s:draw()
    6              0.000004   return 1

FUNCTION  <lambda>71()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder.vim:198
Called 46 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>72()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 46 times
Total time:   0.003024
 Self time:   0.000179

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <lambda>73()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/cmdline.vim:1177
Called 46 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                            return res.expand ==# 'lua'

FUNCTION  <lambda>74()
    Defined: ~/.local/share/nvim/site/pack/packer/start/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 46 times
Total time:   0.000540
 Self time:   0.000164

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   95   0.696393   0.001627  <SNR>61_render_lines_from_timer()
   89   0.694766   0.121389  <SNR>61_render_lines()
 3314   0.571518   0.028506  wilder#lua#call_wrapped_function()
  492   0.492973   0.062910  4()
  469   0.478708   0.003669  3()
27434   0.440877   0.362813  wilder#lua#wrap()
  598   0.391331   0.032817  <SNR>121_run()
   86   0.288739   0.041480  <SNR>61_make_lines()
  414   0.272268   0.001498  wilder#pipeline#run()
  361   0.207406   0.004519  matchup#delim#get_current()
  361   0.202887   0.010482  <SNR>110_get_delim_multi()
  361   0.192405   0.067282  <SNR>110_get_delim()
  368   0.152017   0.003247  <SNR>48_on_finish()
   89   0.146405   0.000456  wilder#renderer#redraw()
   89   0.145949             <SNR>120_redraw()
  517   0.139033             <SNR>74_try()
  184   0.132711   0.002156  <SNR>121_call()
  184   0.130833   0.000716  wilder#pipeline#resolve()
  184   0.130116   0.007059  <SNR>121_handle()
  138   0.125651   0.003786  <SNR>48_branch()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
27434   0.440877   0.362813  wilder#lua#wrap()
   89              0.145949  <SNR>120_redraw()
  517              0.139033  <SNR>74_try()
   89   0.694766   0.121389  <SNR>61_render_lines()
 1271              0.104248  <SNR>123_forward()
  361   0.192405   0.067282  <SNR>110_get_delim()
  492   0.492973   0.062910  4()
   74   0.050439   0.046814  <SNR>110_parser_delim_new()
   86   0.288739   0.041480  <SNR>61_make_lines()
  598   0.391331   0.032817  <SNR>121_run()
 3314   0.571518   0.028506  wilder#lua#call_wrapped_function()
 1395              0.024643  matchup#perf#toc()
 1758              0.023808  wilder#render#chunks_displaywidth()
   80   0.090355   0.022165  <SNR>110_get_matching_delims()
  172   0.100567   0.021289  <SNR>61_draw_columns()
 2030   0.034378   0.020984  <SNR>109_parse_args()
  356   0.111645   0.020433  <SNR>61_draw_top_or_bottom_line()
   89   0.025905   0.020371  <SNR>58_prompt()
  602   0.079278   0.019962  wilder#renderer#popupmenu#draw_column()
  384   0.020089   0.019032  1()

